00:00:00.160 hey guys in this video you're going to
00:00:02.240 write your first c plus program so sit
00:00:05.520 back relax and well enjoy the show
00:00:09.920 hey if you wouldn't mind please like
00:00:11.759 comment and subscribe one like equals
00:00:14.480 one prayer for the youtube algorithm
00:00:17.119 i'm gonna tell you why you need to learn
00:00:19.199 c plus plus
00:00:20.640 c plus plus is a fast language like
00:00:23.760 really fast it's commonly used in
00:00:26.160 advanced graphics applications a few
00:00:28.640 examples would include adobe
00:00:30.240 applications video editing software
00:00:33.040 anything that's graphics intensive c
00:00:35.200 plus plus is considered a middle level
00:00:37.200 language therefore it's commonly used
00:00:39.600 with embedded systems and most
00:00:41.680 importantly it's commonly used with
00:00:43.760 creating video games i like video games
00:00:46.800 like a lot compared to other programming
00:00:48.879 languages you could say that c plus plus
00:00:51.760 is a middle level language programming
00:00:54.160 languages tend to be on a spectrum the
00:00:56.079 higher level of programming languages
00:00:58.079 the more it resembles human language
00:01:00.320 languages that are closer to being lower
00:01:02.239 level resemble hardware instructions
00:01:04.559 higher level languages such as python
00:01:06.960 java and c-sharp are very easy to write
00:01:09.600 with and to understand but they tend to
00:01:11.680 be slower c plus and c they take a
00:01:14.640 little more effort to write but they're
00:01:16.479 very fast they have the benefit of
00:01:18.479 working closely with machine hardware
00:01:20.400 while still somewhat resembling human
00:01:22.159 language just a fair warning there is a
00:01:24.240 learning curve with c plus plus but if
00:01:26.320 you can learn it it's worth it there's
00:01:28.240 two things you'll need to get started
00:01:30.159 one is a text editor a few options
00:01:32.640 include but are not limited to would be
00:01:35.840 vs code code blocks or even notepad vs
00:01:39.600 code and code blocks are also considered
00:01:42.119 ides integrated development environments
00:01:45.600 they are a text editor as well as a
00:01:47.520 workshop that contain a lot of useful
00:01:49.360 developer tools in this video i'm going
00:01:51.600 to show you how to download vs code but
00:01:54.320 feel free to use any text editor that
00:01:56.079 you're comfortable with secondly we'll
00:01:57.920 need a compiler a compiler is a piece of
00:02:01.040 software that will parse source code to
00:02:03.920 machine instructions and that's really
00:02:06.000 it if you're using windows or linux
00:02:08.239 you'll probably want to go with gcc if
00:02:10.878 you're running mac you'll probably go
00:02:12.480 with clang okay clang has a really cool
00:02:15.040 logo
00:02:16.000 it's blue eyes white dragon so let's get
00:02:18.400 started
00:02:19.440 well alright then everybody now we are
00:02:21.280 going to download vs code that text
00:02:23.440 editor i was talking about head to this
00:02:25.440 url code.visualstudio.com
00:02:29.200 then select the correct download for
00:02:30.800 your operating system i'm running
00:02:32.480 windows i'll select windows then i will
00:02:35.040 open this
00:02:36.879 read the agreement yes i actually did
00:02:38.800 read it that fast i accept the agreement
00:02:41.840 next
00:02:43.519 next
00:02:45.040 next
00:02:46.239 i'll create a desktop icon why not
00:02:48.840 next and install we might as well launch
00:02:52.000 it
00:02:52.800 finish
00:02:55.120 in vs code there's two extensions i
00:02:57.120 would recommend go to the left toolbar
00:02:59.519 underneath extensions we will look up c
00:03:03.440 c plus plus
00:03:04.959 and we would like to download this
00:03:06.560 extension
00:03:07.599 uh let's pretend that this wasn't
00:03:09.200 already installed so i'm going to
00:03:10.959 install it
00:03:12.159 then the next extension i recommend is
00:03:14.640 code runner
00:03:17.519 here it is
00:03:18.879 then just click this blue button to
00:03:20.400 install it
00:03:22.319 okay let's close out of this
00:03:25.040 we're going to create a new folder to
00:03:26.560 hold our c plus projects go to the left
00:03:29.360 toolbar explore
00:03:31.440 open folder i'll create a new folder on
00:03:33.680 my desktop
00:03:35.599 new
00:03:36.400 folder i'll name this c
00:03:39.040 plus
00:03:39.840 projects
00:03:41.200 that sounds good to me
00:03:42.959 then select folder
00:03:44.720 within this folder we'll create a new
00:03:46.560 file
00:03:47.840 i'll name this hello world dot cpp make
00:03:52.319 sure to get that cpp extension at the
00:03:54.560 end that means it's a c plus plus file
00:03:57.360 okay we now have a c plus file to work
00:04:00.080 with now we just need to download that
00:04:01.920 compiler that parses source code to
00:04:04.799 machine instructions
00:04:06.720 there's a great set of instructions at
00:04:08.799 this url code.visualstudio.com
00:04:13.280 docs let's head to c plus plus there's
00:04:16.639 different installation instructions
00:04:18.160 depending on your operating system
00:04:20.000 you'll be downloading gcc on linux if
00:04:22.720 you're running linux gcc on windows for
00:04:25.600 windows
00:04:26.800 and clang for mac os downloading a
00:04:29.520 compiler for linux and mac is actually
00:04:31.759 really easy i can cover that in like 30
00:04:33.759 seconds windows is a little more
00:04:35.600 complicated but let's begin with linux
00:04:38.720 so all you're going to do is open up
00:04:40.720 terminal and enter the following command
00:04:43.680 gcc
00:04:45.120 v that will check to see if it's
00:04:46.800 currently installed
00:04:48.160 if it's not you enter this command in
00:04:51.120 then you install the gnu compiler tools
00:04:53.680 by typing in this command right here and
00:04:56.479 that's all you need to do with linux
00:04:58.800 if you're on mac you'll download clang
00:05:02.560 open terminal
00:05:04.080 type in this command
00:05:05.759 if clang isn't installed all you type is
00:05:08.479 this command and that's it so pretty
00:05:10.880 easy right if you're using the windows
00:05:13.039 operating system there's way more steps
00:05:16.160 so let's head to step three we'll need
00:05:18.800 to install min gw64
00:05:22.240 you can click this link to the installer
00:05:24.880 this is an executable i'll open this
00:05:26.800 when it's done
00:05:29.520 click next
00:05:31.360 next
00:05:32.560 next
00:05:33.919 wait for it
00:05:35.120 we might as well run this
00:05:37.039 then finish
00:05:38.479 now we will follow the installation
00:05:40.240 instructions on this website
00:05:45.039 under step 5 we will type
00:05:48.080 pack man
00:05:49.919 dash
00:05:50.960 capital s y u enter
00:06:03.520 type y then enter to proceed with the
00:06:06.000 installation
00:06:10.560 type y then enter again to confirm to
00:06:13.360 proceed
00:06:14.720 now we'll need to find this program from
00:06:16.240 the start menu
00:06:18.319 m sys2 then type this command
00:06:22.639 pack man
00:06:24.400 dash s u enter
00:06:28.000 type y then enter to proceed with the
00:06:30.319 installation
00:06:35.199 now we'll need to enter this command in
00:06:38.560 there's a lot to type here
00:06:42.000 pacman dash s
00:06:44.960 dash dash
00:06:46.479 needed
00:06:47.680 base
00:06:49.360 dash
00:06:51.039 dev l
00:06:54.080 min
00:06:55.199 gw
00:06:56.639 dash w
00:06:58.479 64
00:07:00.240 dash
00:07:01.280 x
00:07:02.560 86
00:07:04.080 underscore
00:07:05.440 64
00:07:07.199 dash
00:07:08.479 tool
00:07:09.599 chain
00:07:10.479 then enter
00:07:12.800 then just hit enter
00:07:15.360 proceed with the installation type yes
00:07:17.919 type y
00:07:19.120 enter again
00:07:20.720 then give it a moment
00:07:23.759 then we can close out of this window
00:07:26.479 we'll have to find the bin folder of
00:07:28.800 mingw
00:07:30.800 it's likely going to be within your c
00:07:32.479 drive go to msys64
00:07:36.639 mingw64
00:07:38.800 bin
00:07:39.840 then copy this address
00:07:43.280 we'll need to add that path to the
00:07:45.199 windows path environment variable
00:07:48.160 to do so search settings
00:07:51.199 settings
00:07:55.120 we'll search edit environment variables
00:08:02.560 go to path
00:08:04.400 edit
00:08:05.919 let's pretend that this wasn't here
00:08:08.560 i'm going to go to new
00:08:11.120 paste that address
00:08:13.280 okay
00:08:14.720 okay
00:08:15.919 close out of this window
00:08:18.160 just to be sure that our compiler is
00:08:19.759 working and available let's open up
00:08:21.840 command prompt
00:08:23.360 command
00:08:24.840 prompt
00:08:26.800 then type in this command
00:08:28.639 g
00:08:29.360 plus plus
00:08:31.120 dash dash
00:08:32.399 version
00:08:33.599 enter
00:08:36.479 yeah it looks like it's good to go we
00:08:38.399 have now successfully installed our
00:08:40.080 compiler
00:08:41.760 all right everybody let's write our
00:08:43.360 first c plus plus program at the top of
00:08:46.000 our c plus file we are going to type
00:08:49.680 include
00:08:51.519 within angle brackets
00:08:53.360 io
00:08:54.480 stream
00:08:55.440 iostream is a header file that contains
00:08:57.760 functions for basic input and output
00:08:59.920 operations by writing include iostream
00:09:03.040 we're including that header file then we
00:09:04.959 have access to a whole bunch of useful
00:09:06.959 input and output operations now we'll
00:09:09.120 need a main function the main function
00:09:11.279 is where the program begins we'll type
00:09:13.680 int
00:09:14.720 main
00:09:15.519 parentheses curly braces we begin the
00:09:18.640 program by invoking the main function
00:09:20.959 and read any code within the main
00:09:22.720 function starting at the top and working
00:09:24.640 our way down at the end of our main
00:09:27.040 function we'll want return 0 then add a
00:09:30.880 semicolon if we reach return 0 that
00:09:34.160 means there were no problems in this
00:09:35.920 program however if one is returned that
00:09:39.040 means there was a problem there is an
00:09:40.800 issue so place return 0 at the end of
00:09:43.120 your main function what we'll do in this
00:09:44.959 lesson is write some basic output to
00:09:47.200 write some output you'll type
00:09:49.240 std contrary to what you might believe
00:09:52.240 in this case it doesn't mean sexually
00:09:54.160 transmitted diseases it means standard
00:09:56.640 follow std with two colons then type
00:10:00.800 c out
00:10:02.399 c means character out means output
00:10:05.279 altogether this means standard character
00:10:08.160 output we're going to display some
00:10:10.000 characters as output then follow c out
00:10:12.640 with two left angle brackets these
00:10:15.120 characters mean output it's also known
00:10:17.279 as the left shift operator when used
00:10:19.120 with numbers what characters would we
00:10:20.959 like to display as output within
00:10:22.640 quotation marks let's write something
00:10:24.959 what's a food you like
00:10:26.720 i
00:10:27.519 like pizza i'll type that then follow
00:10:30.880 this statement with a semicolon at the
00:10:33.200 end of statements we add a semicolon
00:10:35.360 that lets the compiler know that this
00:10:37.120 statement is done it's sort of like the
00:10:39.120 period at the end of a sentence that's
00:10:40.959 when you know the sentence is complete
00:10:42.800 so i'm going to save this i'll hold ctrl
00:10:45.600 s or you can go to file save then click
00:10:48.800 this button to run it
00:10:51.200 and there's my output i like pizza
00:10:54.000 on the next line i'll type std
00:10:57.360 two colons
00:10:58.720 c out two left angle brackets for output
00:11:02.079 i'll write a second line
00:11:04.959 it's really
00:11:06.959 good
00:11:09.360 then i'll run this again you can press
00:11:11.040 this icon to clear output
00:11:14.240 uh oh we have a problem i like pizza
00:11:16.560 it's really good all of this text is on
00:11:18.959 one line what if you need the next line
00:11:20.959 of text to be on well the next line when
00:11:23.440 you need to move your cursor down to the
00:11:24.959 next line you can follow some string of
00:11:27.120 text with
00:11:28.959 double left angle brackets
00:11:31.040 for output
00:11:32.560 std
00:11:34.640 colon colon
00:11:36.079 en dl that means end line
00:11:39.680 and i'll do the same for my second line
00:11:42.079 i'm going to save clear my output run
00:11:44.560 this again
00:11:46.079 yeah there we go i like pizza it's
00:11:48.640 really good each line of text is on a
00:11:51.200 different line another option for a new
00:11:53.200 line that's better performance wise
00:11:55.519 is to add a new line character
00:11:57.920 within single quotes type
00:12:00.240 backslash n
00:12:02.079 and let's replace that here as well
00:12:05.360 so i'm going to save clear my output run
00:12:08.000 this again
00:12:09.519 i like pizza it's really good adding a
00:12:11.839 new line character does the same thing
00:12:13.760 and it's better performance wise however
00:12:15.920 the benefit of using endline is that
00:12:18.560 endline will flush the output buffer
00:12:21.279 really you can use either one but i
00:12:22.959 thought that might be a nice trick to
00:12:24.160 show you now you can write a comment a
00:12:26.639 comment is ignored by the compiler
00:12:29.440 to write a comment you use two forward
00:12:31.519 slashes
00:12:33.680 this is a comment
00:12:36.399 comments are used for yourself for notes
00:12:39.040 or for notes for another developer so if
00:12:41.360 i were to run this again
00:12:44.160 this comment is ignored it's not used as
00:12:46.480 output or anything like that if you need
00:12:48.480 a multi-line comment you type forward
00:12:50.720 slash asterisk
00:12:52.560 wherever you need your comment to end
00:12:54.399 you'll place asterisk forward slash
00:12:56.880 again
00:12:58.160 this
00:13:00.240 is
00:13:01.120 a
00:13:02.720 multi-line
00:13:05.680 comment
00:13:07.200 and you can see that all of this is
00:13:08.880 ignored as well so comments are used as
00:13:11.519 notes for yourself or for other
00:13:13.440 developers yeah that's a quick
00:13:15.519 introduction to getting started with c
00:13:17.920 plus i'll post this code in the comment
00:13:19.760 section down below if you would like a
00:13:21.200 copy hey if you enjoyed this video
00:13:22.880 please be sure to smash that like button
00:13:25.120 leave a random comment down below and
00:13:26.959 subscribe if you'd like to become a
00:13:28.320 fellow bro
00:13:32.480 hey guys i'm going to explain what
00:13:34.560 variables are a variable you probably
00:13:36.639 remember from middle school math class a
00:13:38.959 variable is a representation of some
00:13:41.440 number or value there are two steps to
00:13:43.680 creating and using a variable
00:13:45.440 declaration and assignment we'll begin
00:13:47.920 with declaration to declare a variable
00:13:50.320 we need to list the data type of what
00:13:52.399 we're storing exactly in programming you
00:13:54.639 can store more than just numbers you can
00:13:56.480 store characters even whole sentences
00:13:59.519 etc let's work with whole numbers to
00:14:01.839 store a whole number we will type int
00:14:04.160 for integer then we need a unique
00:14:06.320 identifier for this variable for now
00:14:08.800 let's just say x we're used to working
00:14:10.720 with like x and y in math class right we
00:14:12.959 will end the statement with a semicolon
00:14:15.680 this step is declaration
00:14:19.199 now to assign a variable you take the
00:14:21.600 variable's name that unique identifier
00:14:24.399 then we will set this equal to
00:14:26.720 some number since we declared this
00:14:28.399 variable as an int it will store an
00:14:31.120 integer maybe like five now this
00:14:34.000 variable behaves as if it was the value
00:14:36.320 that it contains it will behave as if it
00:14:38.720 was the number five then to display a
00:14:40.639 variable we can use standard output std
00:14:45.120 c out
00:14:47.199 we will display
00:14:48.800 x
00:14:49.680 and let's see what we have
00:14:54.800 there's our value five this first step
00:14:57.120 is declaration
00:14:58.480 the second step is assignment the nice
00:15:00.959 thing about doing this in two steps is
00:15:02.639 that you can later assign your variable
00:15:04.800 a value if you know what value you would
00:15:06.880 like to give your variable right away
00:15:08.399 you can do that at the beginning of your
00:15:09.760 program you could combine both of those
00:15:11.600 steps
00:15:12.480 int x equals 5 and that would do the
00:15:15.279 same thing in cases where you don't know
00:15:17.199 what value you would like to give a
00:15:18.560 variable you could assign it later such
00:15:20.800 as when you accept user input you don't
00:15:22.720 know what the user is going to type so
00:15:24.320 let's create another
00:15:25.839 int
00:15:26.800 y equals six
00:15:28.959 then let's display whatever y is
00:15:31.440 i'll add a new line
00:15:33.600 let's copy this paste it
00:15:37.199 okay
00:15:38.639 x is five y is six we could even do
00:15:41.440 something like this let's say int sum
00:15:44.880 equals x plus y
00:15:48.000 then we'll display whatever our sum
00:15:49.600 variable is
00:15:51.360 c out sum
00:15:53.440 the sum of x plus y is 11. now there's
00:15:56.560 different data types depending on what
00:15:58.320 you need to store within a variable
00:15:59.680 exactly the int data type stores a whole
00:16:02.880 integer let's think of a few examples of
00:16:05.120 whole integers what about an age
00:16:08.399 that's typically a whole number
00:16:10.480 inch age equals 21. let's think of two
00:16:14.399 more examples
00:16:15.759 what about a year
00:16:17.199 int year equals
00:16:19.920 20
00:16:20.880 23 how about days int days equals seven
00:16:26.560 the int data type can only store a whole
00:16:28.720 number
00:16:29.600 with days what if we assign this a value
00:16:31.920 of 7.5 let me show you what happens
00:16:37.759 all right i will display days
00:16:45.600 all right that decimal portion is
00:16:47.519 truncated when i display days and we
00:16:50.000 attempt to assign 7.5
00:16:52.480 well this variable can't store that
00:16:54.079 decimal so it's truncated if you need a
00:16:56.880 number that includes a decimal portion
00:16:58.639 there's a different data type for that
00:17:01.040 and that is a double
00:17:05.679 this is a number
00:17:08.240 including
00:17:09.599 decimal
00:17:10.640 a few examples of a double would be
00:17:12.559 maybe a price there's dollars and cents
00:17:16.160 double
00:17:17.599 price
00:17:19.199 equals
00:17:20.400 10.99
00:17:23.199 what about a gpa a grade point average
00:17:26.079 that includes a decimal
00:17:28.160 double gpa equals 2.5
00:17:33.440 uh then maybe a temperature
00:17:36.960 double
00:17:38.640 temperature
00:17:40.960 equals 25.1
00:17:44.320 i guess this could be in either celsius
00:17:46.160 or fahrenheit then let's display maybe
00:17:48.559 price
00:17:51.520 price
00:17:54.880 yeah and that decimal portion is not
00:17:57.280 truncated much like what you see with
00:17:59.600 whole integers if you need a number that
00:18:01.679 includes a decimal portion use a double
00:18:04.080 now we have the char data type that
00:18:06.000 stores a single character
00:18:09.440 type char
00:18:11.120 maybe we're working with student grades
00:18:13.440 i'll name this variable grade
00:18:16.640 equals
00:18:17.840 then to store a single character you use
00:18:19.919 single quotes this student has an a
00:18:24.000 two more examples what about an initial
00:18:28.160 singular not initials
00:18:30.320 char
00:18:31.840 initial
00:18:33.840 what about b
00:18:35.760 so i'm going to display initial
00:18:41.679 initial
00:18:45.120 okay
00:18:45.919 we have our single character of b
00:18:48.720 now check this out what if i attempt to
00:18:50.480 store more than one character i'll add c
00:18:53.520 we have a warning we have an overflow in
00:18:55.600 conversion from int to char
00:18:58.240 so what's displayed is the last
00:19:00.480 character just c so chars can only store
00:19:03.919 a single character here's one more
00:19:05.919 example of a char data type what if
00:19:07.919 we're working with currency what type of
00:19:10.080 currency will we work with
00:19:12.080 char
00:19:13.679 currency
00:19:15.360 equals
00:19:16.960 maybe a dollar sign
00:19:18.559 if we're working with a different type
00:19:20.160 of currency we could change this to a
00:19:22.320 different symbol yeah that's the char
00:19:24.480 data type it stores a single character
00:19:27.440 next on our list is booleans
00:19:30.640 boolean a variable that's boolean has
00:19:33.679 only two states
00:19:35.360 true or false to create a boolean
00:19:38.559 variable you type bool
00:19:41.039 then a variable name so these are
00:19:43.360 applicable to anything that has two
00:19:45.360 states what if somebody is a student
00:19:47.760 they're either a student or not a
00:19:49.520 student
00:19:51.120 bull student
00:19:53.039 equals true
00:19:54.799 if they're not enrolled in classes or
00:19:57.200 they graduated you could set this to be
00:19:58.960 false think of a light switch the light
00:20:01.280 switch can either be on or off you can
00:20:03.840 say a light switch is boolean there's
00:20:05.760 only two states true or false how about
00:20:08.799 bull power is something powered on or
00:20:11.520 not
00:20:12.559 power equals true if it's turned off
00:20:15.440 that could be false maybe we have a
00:20:17.440 store and we need to mark if something
00:20:19.520 is for sale or not like is it available
00:20:23.200 bool
00:20:24.240 for sale
00:20:26.000 equals true
00:20:27.679 if an item in our store isn't for sale
00:20:29.679 like it's not available we could set
00:20:31.200 this to be false so that's the idea
00:20:33.440 behind boolean values it has two states
00:20:36.320 true or false the last data type i'll
00:20:38.880 cover is strings a string is technically
00:20:41.919 an object that represents a sequence of
00:20:45.039 text think of it as the char data type
00:20:47.679 but we can store more than one character
00:20:50.000 even whole sentences like a name or an
00:20:52.720 address
00:20:53.679 strings are provided from the standard
00:20:55.679 namespace to declare a string we would
00:20:58.000 type standard
00:21:00.840 string then a variable name
00:21:04.080 what about just name like we're storing
00:21:06.080 a user's name
00:21:07.360 place your text within a set of double
00:21:09.520 quotes then why don't you type your
00:21:11.200 first name
00:21:12.240 then we will store that within this
00:21:13.679 variable name then to test it let's
00:21:16.000 display it
00:21:18.080 standard output we will display
00:21:20.880 name
00:21:23.679 and there is your first name
00:21:25.840 let's create a couple more examples
00:21:28.159 what about a day of the week
00:21:30.640 standard string
00:21:32.880 day
00:21:34.640 then pick a day i like friday
00:21:38.000 what about food
00:21:40.000 standard string
00:21:42.000 food
00:21:43.520 i like pizza
00:21:45.440 i'll store this series of text as a
00:21:47.440 string
00:21:48.640 then maybe an address standard
00:21:51.679 string
00:21:54.159 address
00:21:56.159 equals make up some address
00:21:58.480 one two three fake street
00:22:01.200 basically speaking a string is a type of
00:22:04.240 object that represents a sequence of
00:22:07.200 text such as a name
00:22:09.760 a day
00:22:10.880 an address etc
00:22:13.200 now i'm going to show you how we can
00:22:14.480 display a variable along with some text
00:22:17.440 i would like to display
00:22:19.039 hello then whatever your name is i will
00:22:21.440 type what is known as a string literal
00:22:23.600 we're literally printing a string hello
00:22:28.480 follow this string of text with a
00:22:30.400 variable
00:22:31.919 my variable name is good
00:22:33.840 then let's display it
00:22:38.559 hello then whatever your first name is
00:22:40.640 but you do have to pay attention to
00:22:42.320 spacing
00:22:43.760 after my word hello i'm going to add a
00:22:45.679 space
00:22:48.400 there hello
00:22:49.919 bro
00:22:50.799 then let's display our age
00:22:55.360 so i'm going to add a new line character
00:23:01.679 standard output we will display
00:23:04.960 u r
00:23:07.440 age
00:23:09.919 years old
00:23:15.679 there hello bro you are 21 years old uh
00:23:19.200 make sure to pay attention to the
00:23:20.320 spacing as well because it's easy to
00:23:21.919 mess that up
00:23:23.520 alright so those are variables we
00:23:26.080 covered a few of the basic data types
00:23:27.840 but there's more advanced data types
00:23:29.520 once we gain a little bit more
00:23:30.640 experience with this that i'll cover we
00:23:32.559 have integers which store a whole number
00:23:35.360 doubles which are numbers that include a
00:23:37.600 decimal portion
00:23:39.120 chars are single characters booleans are
00:23:42.000 either true or false then strings
00:23:44.640 represent a sequence of text an
00:23:47.360 important note with strings is that you
00:23:49.360 can include numbers but they're treated
00:23:51.440 differently so yeah those are variables
00:23:54.320 in c plus your assignment is to in the
00:23:57.200 comment section post a integer variable
00:24:00.400 a double
00:24:01.520 a character boolean and a string think
00:24:04.240 of some examples preferably some
00:24:06.320 examples that i may have not covered
00:24:07.919 already that would be good practice well
00:24:10.159 yeah and that's an introduction to
00:24:11.919 variables in c plus plus
00:24:16.400 all right welcome back everybody in this
00:24:18.240 video we're going to discuss the const
00:24:20.240 keyword the const keyword specifies that
00:24:23.039 a variable's value is constant it tells
00:24:26.000 the compiler to prevent anything from
00:24:28.159 modifying it so that it's effectively
00:24:30.640 read-only here's an example let's create
00:24:33.200 a program to calculate the circumference
00:24:35.440 of a circle we'll first define the
00:24:37.360 variables that we'll need we have
00:24:40.159 double
00:24:41.279 pi
00:24:42.240 pi equals
00:24:44.960 five 3.14159
00:24:47.039 then we have double
00:24:49.120 radius pick some radius i'll pick ten
00:24:53.520 then double
00:24:55.520 circumference
00:24:58.960 equals and here's the formula to
00:25:01.039 calculate the circumference of a circle
00:25:03.279 it's two
00:25:04.799 times
00:25:06.080 pi
00:25:07.279 times
00:25:08.480 radius
00:25:10.080 then we will display our circumference
00:25:12.960 standard output
00:25:14.880 we will display
00:25:16.960 circumference
00:25:19.679 then i'll add maybe centimeters
00:25:23.200 our circumference is
00:25:26.679 62.83 centimeters
00:25:29.120 any variable we do not want to be able
00:25:31.120 to be changed at all we can turn into a
00:25:33.039 constant
00:25:34.240 let's say that somebody goes into our
00:25:36.240 program and changes pi to a different
00:25:38.240 number like
00:25:39.520 420 69 well then this is going to change
00:25:43.200 the result of our program we may have
00:25:45.200 not realized that somebody changed the
00:25:46.799 value of pi before 2069 so any variable
00:25:50.000 you do not want changed you can prefix
00:25:52.320 this keyword const
00:25:54.960 const double pi now a common naming
00:25:57.760 convention for constants
00:25:59.679 is to make all of the letters uppercase
00:26:02.480 so let's change pi from lowercase to all
00:26:04.799 uppercase
00:26:06.240 and we'll need to make that change here
00:26:07.679 as well
00:26:08.720 now let's try and change pi to 420 69
00:26:12.559 again then see what happens
00:26:15.200 okay we have an error assignment of
00:26:17.039 read-only variable pi
00:26:19.039 so by including constants it adds some
00:26:21.039 data security we can't normally change
00:26:23.360 any value that's a constant a couple
00:26:25.760 other examples of variables that you
00:26:27.600 could turn into constants could be maybe
00:26:29.600 the speed of light maybe you have a
00:26:31.679 physics calculator so const
00:26:35.039 int
00:26:36.840 light speed
00:26:39.120 the speed of light in meters per second
00:26:41.520 is two nine nine seven nine two
00:26:45.039 four five eight
00:26:46.880 let's think of one more example perhaps
00:26:48.799 you're working with screen resolutions
00:26:51.360 we have const
00:26:53.600 int
00:26:54.559 width
00:26:55.679 of
00:26:56.720 1920
00:26:58.559 then const
00:27:00.159 int
00:27:01.120 height
00:27:02.480 of 1080.
00:27:04.799 these may be a few examples
00:27:06.400 of variables you do not want to be
00:27:08.080 changed or altered at all you only want
00:27:09.760 them to be read-only yeah that's a const
00:27:12.159 everybody it's a keyword that will
00:27:14.559 modify a variable or some value so that
00:27:16.960 it's read-only and can't be changed you
00:27:19.360 should use constants as often as
00:27:21.039 possible only if you know that a
00:27:22.720 variable is not going to be changed at
00:27:24.799 all your assignment is to think of a
00:27:26.880 constant and post it in the comment
00:27:28.960 section hey if you're enjoying the
00:27:30.320 series please be sure to smash that like
00:27:32.399 button leave a random comment down below
00:27:34.240 and subscribe if you'd like to become a
00:27:35.840 fellow bro
00:27:39.279 hey everyone i have a quick video on
00:27:41.600 namespaces a namespace provides a
00:27:43.919 solution for preventing name conflicts
00:27:46.559 especially in larger projects each
00:27:48.720 entity needs a unique name a namespace
00:27:51.679 allows for identically named entities as
00:27:54.640 long as the namespaces are different now
00:27:56.960 what the heck does that mean suppose we
00:27:59.120 have variable x x equals zero
00:28:02.720 each variable needs a unique name i
00:28:05.039 couldn't create a second variable named
00:28:06.880 x and give this a different value if i
00:28:09.279 were to compile and run this program we
00:28:11.200 would run into an error read declaration
00:28:13.840 of int x
00:28:15.360 so each entity needs unique name but if
00:28:18.000 we use namespaces then two or more
00:28:20.240 entities can share the same name to
00:28:22.080 create a namespace
00:28:23.679 let's do so outside of the main function
00:28:26.799 i will type
00:28:28.080 namespace
00:28:29.760 then some name for the namespace let's
00:28:31.760 say first then a set of parentheses
00:28:34.799 i could create a different version of x
00:28:37.919 i'll give this a different value like
00:28:40.080 one
00:28:40.960 well this would run and compile just
00:28:42.640 fine
00:28:43.520 you can have different versions of the
00:28:45.679 same variable as long as they're within
00:28:47.840 a different namespace just for fun let's
00:28:49.919 create a second namespace namespace
00:28:52.559 second
00:28:53.600 x equals two this is also valid
00:28:57.120 so just to demonstrate a few things i'm
00:28:59.120 going to display what x is
00:29:01.600 if i don't explicitly state what
00:29:03.679 namespace we're using we will use the
00:29:06.080 local version of an entity
00:29:08.559 if i display x
00:29:10.320 x would be zero if i would like the
00:29:12.880 version of x that is found within the
00:29:14.960 first namespace
00:29:16.399 i would take that entity in this case x
00:29:19.840 prefix the namespace let's say first
00:29:23.120 then two colons
00:29:24.880 the two colons is known as the scope
00:29:27.120 resolution operator i'm referring to the
00:29:30.000 version of x that is found within the
00:29:31.840 first namespace
00:29:33.440 and that version of x has a value of one
00:29:37.039 if i need the value of x found within
00:29:39.679 the second namespace i would precede
00:29:42.240 that entity with the second namespace
00:29:44.960 followed by the scope resolution
00:29:46.559 operator
00:29:47.919 so that version of x is 2.
00:29:50.799 so entities can have the same name as
00:29:53.200 long as they're within a different
00:29:54.399 namespace now one line that you may see
00:29:56.960 is
00:29:57.760 using
00:29:58.880 namespace
00:30:00.080 then the name of a namespace let's say
00:30:01.919 first if we have some entity without a
00:30:04.640 prefix of the namespace it's assumed
00:30:07.039 that we're using the entity found within
00:30:09.360 that particular namespace
00:30:11.679 so if i was to display x
00:30:14.320 while we're using namespace first
00:30:17.679 x would be one
00:30:19.200 and i don't need to add that prefix but
00:30:21.600 if i need xbond within the second
00:30:23.600 namespace i would still need to prefix
00:30:25.679 it with second
00:30:28.399 x is two
00:30:29.760 if i changed using namespace to second
00:30:32.559 it's implied we're using the second
00:30:34.240 namespace and i don't need that prefix
00:30:38.799 2 but i still would if i need x from the
00:30:41.120 first name space
00:30:44.320 1.
00:30:45.440 now there's this evil line called using
00:30:48.240 it namespace std for standard now the
00:30:50.799 reason that people include this line is
00:30:52.720 to save a little bit of typing
00:30:54.720 if we're using a namespace std we don't
00:30:57.600 need to include that prefix when we
00:30:59.279 declare strings or we display output
00:31:01.600 with c out just for example like this
00:31:04.240 would still compile and run
00:31:06.000 however the standard namespace has
00:31:08.080 hundreds of different entities let me
00:31:10.720 show you
00:31:12.000 standard
00:31:13.679 there's a high likelihood of a naming
00:31:15.760 conflict for example we have an entity
00:31:18.480 named data
00:31:19.919 one alternative is that we could say
00:31:22.720 using
00:31:24.640 standard
00:31:25.840 output
00:31:26.880 that will cut down on some of the
00:31:28.080 repetitions or
00:31:30.000 using
00:31:31.200 standard
00:31:32.399 string
00:31:36.320 it's a safer alternative to using
00:31:38.480 namespace standard
00:31:40.640 in the future i'm not going to be using
00:31:42.320 namespace standard because i would like
00:31:44.480 to steer people away from that but just
00:31:46.559 in case you see that line you know what
00:31:48.159 it's there for
00:31:49.440 so in conclusion a namespace provides a
00:31:52.000 solution for preventing name conflicts
00:31:55.120 each entity needs a unique name and a
00:31:57.679 namespace allows for identically named
00:32:00.000 entities as long as the namespaces are
00:32:02.240 different so those are namespaces hey if
00:32:05.360 you're enjoying this series let me know
00:32:07.039 by smashing that like button leave a
00:32:08.799 random comment down below and subscribe
00:32:10.799 if you'd like to become a fellow bro
00:32:14.799 hey everyone in this topic i'm going to
00:32:16.720 explain typedefs and type aliases now
00:32:20.159 typedef is a reserved keyword used to
00:32:22.399 create an additional name for another
00:32:24.480 data type kind of like a nickname it's a
00:32:26.799 new identifier for an existing type one
00:32:29.120 of the reasons that people use typedef
00:32:31.120 is that it helps with readability and
00:32:32.960 reduces typos here's an example in this
00:32:35.919 example i'll need to include this header
00:32:38.000 file
00:32:39.039 include
00:32:40.640 vector
00:32:41.760 suppose we have this very long data type
00:32:44.559 and i would like to give it a nickname
00:32:46.159 an alias
00:32:48.399 i would type the keyword typedef then
00:32:51.200 list the original data type so we're
00:32:53.279 used to strings ins doubles well here's
00:32:56.559 a really complicated one and of course i
00:32:58.720 don't expect anybody to know this at
00:33:00.320 this level yet
00:33:01.760 standard
00:33:03.440 vector
00:33:06.320 standard
00:33:07.919 pair
00:33:10.000 standard
00:33:11.519 string
00:33:12.880 int so this is one really long data type
00:33:16.480 this could be a data type for a pair
00:33:18.399 list but i don't want to have to type
00:33:20.159 all of this so what i could do is give
00:33:22.640 this data type an alias using this type
00:33:25.440 dev keyword after the original data type
00:33:28.080 i'll come up with a new name a new
00:33:29.760 identifier let's say pair
00:33:32.480 list
00:33:33.519 that's a lot easier to write than all of
00:33:35.519 this for the data type
00:33:37.120 a common convention when using the
00:33:38.960 typedef keyword the new identifier
00:33:41.679 usually ends with underscore t for type
00:33:45.840 now suppose i declare a variable of this
00:33:47.919 data type
00:33:50.559 standard vector standard pair standard
00:33:52.880 string int let's say the name is pair
00:33:56.399 list in place of using the original data
00:33:58.960 type we can use the new identifier
00:34:04.320 pair list underscore t so that's one of
00:34:06.880 the main benefits of using the typedef
00:34:08.800 keyword we can give a new identifier to
00:34:11.520 an existing data type it helps with code
00:34:13.918 readability and helps reduce typos this
00:34:16.800 data type is way beyond our level of
00:34:18.800 understanding right now let's try some
00:34:20.879 simple examples i'll turn this line into
00:34:22.960 a comment
00:34:25.119 then get rid of that
00:34:26.719 let's create a typedef for standard
00:34:29.040 strings
00:34:30.159 type
00:34:31.119 def
00:34:32.000 then we list the original data type
00:34:34.639 standard string
00:34:36.960 in place of using standard string as the
00:34:39.040 data type i'll create a new identifier
00:34:40.960 for this data type as maybe just text
00:34:44.320 text underscore t if i need to create a
00:34:46.639 string i could use this new identifier
00:34:49.520 in place of saying standard string then
00:34:52.239 maybe first name
00:34:55.679 i can replace the data type with the new
00:34:57.760 identifier if i choose to
00:34:59.760 text t
00:35:01.359 and i'll set my first name equal to
00:35:03.280 whatever my first name is feel free to
00:35:05.200 set it to your own first name and this
00:35:07.040 variable behaves exactly like a string
00:35:10.240 so let's display it standard output
00:35:13.680 first name
00:35:17.520 and then we should have our first name
00:35:21.680 yeah there we are
00:35:23.119 okay now let's try this with an integer
00:35:27.119 type
00:35:28.000 def we list the old data type int
00:35:31.119 let's create an identifier for int as
00:35:34.079 number
00:35:35.200 that's more descriptive
00:35:36.960 underscore t
00:35:38.560 although it's more to write technically
00:35:40.880 in place of using the int data type i
00:35:43.280 could use
00:35:44.640 number t and this is technically an
00:35:46.880 integer
00:35:48.160 let's say age then make up some age
00:35:51.520 standard output i will display my age
00:35:54.800 then i will add a new line
00:36:01.920 yep we have our first name and our age
00:36:05.040 now typedef has largely been replaced
00:36:07.520 with the using keyword that's because
00:36:09.680 the using keyword works better with
00:36:11.599 templates which is a topic for another
00:36:13.920 video so in place of using typedef i
00:36:16.480 recommend using the using keyword
00:36:20.640 so i'm going to turn these lines into
00:36:22.320 comments
00:36:24.160 now if we were to use the using keyword
00:36:26.320 we would type using
00:36:28.800 then the new data type
00:36:31.119 so let's say text t
00:36:33.599 equals the old data type
00:36:36.320 standard string
00:36:39.760 then let's do that with number
00:36:42.240 using
00:36:43.680 the new identifier number t
00:36:46.560 equals int
00:36:48.320 and that would work the same
00:36:50.800 we have our first name and our age the
00:36:53.280 using keyword is more popular than
00:36:55.200 typedef nowadays just because it's more
00:36:57.280 suitable for templates and like i said
00:36:59.359 that's a topic for another video all
00:37:01.359 right everybody that is the typedef
00:37:03.440 keyword and type aliases typedef along
00:37:07.119 with the using keyword they're used to
00:37:09.280 create an additional name an alias or
00:37:12.320 nickname for another data type it's a
00:37:14.960 new identifier for an existing data type
00:37:17.680 it helps with readability and it reduces
00:37:20.079 typos however you should really only be
00:37:22.160 using the typedef and using keywords
00:37:24.160 when there is a clear benefit so yeah
00:37:26.400 that is typedefs and type aliases your
00:37:29.599 assignment is to post a typedef in the
00:37:31.680 comments section down below and well
00:37:34.000 yeah those are defs and type aliases in
00:37:37.280 c plus
00:37:41.040 all right everybody welcome we are going
00:37:43.040 to discuss arithmetic operators
00:37:44.800 arithmetic operators return the result
00:37:47.040 of a specific arithmetic operation such
00:37:49.760 as addition subtraction multiplication
00:37:52.320 and division let's say we have 20
00:37:54.240 students int
00:37:56.000 students equals 20. if a new student
00:37:58.880 joins our class we would like to add one
00:38:00.720 student well if we're working with the
00:38:02.320 variable we could say students equals
00:38:05.680 whatever students is plus one then we
00:38:08.320 could display this
00:38:10.079 standard output i will display
00:38:12.720 students the current number of students
00:38:14.960 that we have
00:38:16.240 are 21. there is a shorthand way of
00:38:18.480 writing this too in place of saying
00:38:20.560 students equal students plus one we
00:38:22.720 could shorten this to
00:38:24.640 students plus equals one that would do
00:38:27.599 the same thing
00:38:29.680 21 if we need to add two students
00:38:32.640 this would be students equal students
00:38:35.200 plus two
00:38:36.560 or
00:38:37.440 students plus equals two
00:38:40.160 then we have 22 students if you need to
00:38:42.560 add one to a variable you could also use
00:38:45.280 the increment operator this is another
00:38:47.599 option and the preferred way if you only
00:38:49.680 need to add one you would say
00:38:52.320 students plus plus
00:38:54.800 we now have 21 students you tend to see
00:38:57.520 this in a lot of loops which we'll cover
00:38:59.440 later okay now we have subtraction
00:39:03.040 students equals students minus one
00:39:07.040 there are now 19 students
00:39:09.200 we could shorten this to
00:39:11.680 students
00:39:13.040 minus equals 1
00:39:15.440 there are 19 students if you need to
00:39:17.760 subtract 2 we could say either students
00:39:20.079 equal students minus 2 or
00:39:22.800 students minus equals 2.
00:39:25.440 that would do the same thing
00:39:27.119 there are 18 students another option is
00:39:29.839 the decrement operator if you need to
00:39:31.839 decrement a variable by one you would
00:39:34.000 say
00:39:35.040 students minus minus
00:39:37.680 this only subtracts one from a variable
00:39:40.640 there are 19 students so that's
00:39:42.960 subtraction to use multiplication you
00:39:45.440 use an asterisk i'm going to double the
00:39:47.520 amount of students that we have
00:39:50.000 students equals students times 2.
00:39:54.640 there are 40 students
00:39:56.880 or we could shorten this to
00:39:59.119 students
00:40:00.400 times equals 2.
00:40:02.560 and again there are 40 students
00:40:05.440 for division you use a forward slash
00:40:09.599 i'm going to divide our class in half
00:40:12.000 students equal students divided by two
00:40:16.800 there are 10 students
00:40:18.640 the shorthand way is students
00:40:21.440 divided by equals 2.
00:40:25.119 there are 10 students now check this out
00:40:27.520 we have 20 students what if i divide
00:40:29.920 students by 3
00:40:34.160 we're working with an int variable so
00:40:36.160 this variable can't hold any decimal
00:40:38.079 portion 20 divided by 3
00:40:40.640 that is 6. so any decimal portion is
00:40:43.839 lost it's truncated
00:40:45.680 but if we change students to be a double
00:40:48.480 well then that decimal portion is
00:40:50.160 retained 6.6 repeating students if you
00:40:53.599 need the remainder of any division you
00:40:55.280 can use the modulus operator let's
00:40:57.599 create a new variable int remainder
00:41:01.040 equals students modulus 2. we'll divide
00:41:04.560 our group of 20 students into groups of
00:41:06.880 two then i'll display the remainder
00:41:09.280 okay 20 divides by two evenly so there's
00:41:11.760 no remainder but what if we divide
00:41:14.079 students by three and get the remainder
00:41:16.400 our class of students is being divided
00:41:18.720 into groups of three for maybe like a
00:41:20.400 project but 20 doesn't divide by three
00:41:22.880 evenly therefore our remainder is two
00:41:26.079 there will be six groups of three
00:41:27.839 students and one group of two students
00:41:29.920 now using the modulus operator is a
00:41:31.599 great way to find out if a number is
00:41:33.359 even or odd take some value or variable
00:41:35.839 you would like to check modulus 2. if
00:41:38.240 that number divides by 2 evenly where
00:41:40.480 the remainder is 0 well it's even if the
00:41:43.200 remainder is 1 well then it's an odd
00:41:45.359 number 21 doesn't divide by two evenly
00:41:48.800 so that is the modulus operator it gives
00:41:50.880 you the remainder of any division these
00:41:52.800 arithmetic operators have an order of
00:41:54.720 precedence we resolve any arithmetic
00:41:57.040 operations that are first within
00:41:58.560 parentheses then multiplication and
00:42:01.280 division then lastly addition and
00:42:03.440 subtraction perhaps we have this formula
00:42:07.280 students equals
00:42:09.839 6
00:42:11.520 minus 5 plus 4
00:42:15.119 times 3 divided by 2. so what do we
00:42:18.480 solve first in this equation we would
00:42:20.720 check any parentheses first which there
00:42:22.960 aren't any of
00:42:24.160 then we resolve any multiplication and
00:42:26.160 division
00:42:27.440 so let's go through this so we have some
00:42:29.599 multiplication here we would resolve
00:42:31.440 four times three first that is twelve
00:42:33.839 then we have some division twelve
00:42:35.359 divided by two is six
00:42:37.520 then any addition and subtraction
00:42:40.240 six minus five is one
00:42:42.160 one plus six is seven
00:42:44.880 and let's check to see if that's right
00:42:46.480 so students should be seven
00:42:48.960 yep students is seven now you can force
00:42:51.760 operator precedence by surrounding some
00:42:53.760 part of your equation with parentheses
00:42:56.000 i'll surround this part of the equation
00:42:57.280 with the set of parentheses the new
00:42:59.280 result is negative seven well yeah
00:43:02.640 everybody those are some basic
00:43:04.160 arithmetic operators they return the
00:43:06.240 result of a specific arithmetic
00:43:08.319 operation hey if you would like a copy
00:43:10.000 of this code i'll post this in the
00:43:11.440 comments section down below and pin it
00:43:13.040 to the top and well yeah those are some
00:43:15.280 basic arithmetic operators in c plus
00:43:17.760 plus
00:43:20.800 hey what's going on everybody in this
00:43:22.480 video i'm going to explain very basic
00:43:24.880 type conversion type conversion is the
00:43:27.359 conversion of a value of one data type
00:43:30.079 to another two ways in which we can do
00:43:32.319 this are implicit and explicit implicit
00:43:35.680 is done automatically if done explicitly
00:43:38.640 we precede a value with the new data
00:43:40.800 type within a set of parentheses you
00:43:42.640 list the new data type put it before a
00:43:44.560 variable or a value
00:43:46.319 let's perform an implicit cast suppose
00:43:49.040 we have variable
00:43:51.119 int x
00:43:52.640 i will assign x the value 3.14
00:43:56.240 integers can only hold a whole number
00:43:58.720 if i were to display x standard output x
00:44:04.800 well the value is 3.
00:44:06.640 we truncated the decimal portion and
00:44:09.119 implicitly converted this number into an
00:44:11.680 integer what if x was of the double data
00:44:14.240 type
00:44:15.359 double x
00:44:16.880 equals 3.14
00:44:19.200 well then we would retain that decimal
00:44:20.960 portion what would happen if i cast
00:44:23.800 3.14 as an integer then assigned it to a
00:44:26.880 double variable
00:44:28.800 before the value
00:44:30.480 add a set of parentheses then the new
00:44:32.240 data type i will convert 3.14 to an
00:44:35.599 integer
00:44:36.400 then store it within the stubble x
00:44:38.960 x now equals three it's a whole integer
00:44:41.359 that is one example of implicit and
00:44:43.440 explicit type conversion here's a few
00:44:45.440 other examples i have character x
00:44:50.400 equals some number like 100
00:44:53.920 if i were to display what x was standard
00:44:56.640 output
00:44:57.760 x
00:44:58.640 well we will implicitly cast this number
00:45:01.520 100 as a character will convert it using
00:45:04.480 the ascii table to whatever its
00:45:06.160 equivalent is
00:45:07.599 the number 100 converted to a character
00:45:11.280 is the letter d
00:45:13.760 let's try an explicit cast
00:45:16.480 i will display the number 100
00:45:19.920 explicitly cast to a character
00:45:24.079 and that value is the letter d as output
00:45:27.359 how is this useful suppose we have an
00:45:29.359 online exam we have to give the user a
00:45:31.520 score how many questions did they get
00:45:33.440 right divided by how many questions were
00:45:36.000 total let's write something like this
00:45:38.319 int correct equals maybe eight
00:45:42.079 the user has eight questions that are
00:45:43.920 right and questions
00:45:46.400 equals 10. there are 10 total questions
00:45:49.440 i need to calculate the score as a
00:45:51.359 percentage
00:45:52.640 we could say
00:45:54.240 double score
00:45:56.240 equals
00:45:57.760 correct
00:45:58.800 divided by questions
00:46:01.680 times 100 then let's display whatever
00:46:04.640 the result is standard output
00:46:07.760 score
00:46:09.280 then i'll add a percent sign to the end
00:46:13.359 8 divided by 10 is 0.8 right times 100
00:46:17.359 that should give us 80
00:46:20.800 uh we have zero percent
00:46:22.800 well that's because we're using integer
00:46:24.800 division questions is of the int data
00:46:27.359 type when we're dividing 8 by 10 we're
00:46:30.079 truncating that decimal portion we're
00:46:31.839 getting rid of it then multiplying
00:46:33.520 whatever remains by 100 i'm going to
00:46:36.160 explicitly cast questions as a double of
00:46:39.520 the double data type
00:46:41.599 and we should retain that decimal
00:46:43.200 portion
00:46:45.040 yeah there we go 80
00:46:47.280 where you'll use type conversion it
00:46:49.040 really varies but you should be aware
00:46:50.800 that you can do it such as when using
00:46:52.800 integer division so yeah that's type
00:46:55.200 conversion in c plus plus hey if you're
00:46:57.440 enjoying this series let me know by
00:46:59.119 smashing that like button leave a random
00:47:01.119 comment down below and subscribe if
00:47:03.040 you'd like to become a fellow bro
00:47:07.200 all right let's get started everybody in
00:47:09.359 this video i'm going to show you how we
00:47:10.960 can accept some user input in c plus
00:47:13.280 plus we're familiar with c out followed
00:47:15.839 by the insertion operator which is two
00:47:18.240 left angle brackets well to accept some
00:47:20.480 input we would type c in for character
00:47:23.440 input followed by the extraction
00:47:25.599 operator which is two right angle
00:47:27.680 brackets here's a demonstration let's
00:47:29.839 ask a user for their name i'll create a
00:47:32.400 string variable standard
00:47:34.880 string
00:47:36.079 the name will be well name then i'll
00:47:38.640 create a prompt which will ask the user
00:47:40.319 what their name is standard
00:47:42.559 output
00:47:43.599 insertion operator
00:47:46.240 what's your name
00:47:49.520 then to accept some user input we would
00:47:52.160 type
00:47:53.200 standard
00:47:54.880 cn for character input
00:47:57.200 extraction operator then where would we
00:47:59.599 like to store the user input let's store
00:48:01.680 it within our variable name at the end
00:48:03.760 of our program let's display what the
00:48:05.440 user's name is
00:48:07.040 standard output
00:48:10.000 insertion operator
00:48:12.240 hello
00:48:15.520 name okay we're going to have one
00:48:16.800 problem though if we're using vs code as
00:48:19.040 our text editor we need to begin using
00:48:21.040 the terminal tab previously we've been
00:48:22.960 using output so i can't actually type in
00:48:25.119 anything to this because it's well for
00:48:26.800 output if you're using vs code this is
00:48:29.040 what we'll need to do if you're not you
00:48:30.640 can skip this step we're going to go to
00:48:32.960 file preferences
00:48:35.359 settings
00:48:36.559 look up code runner
00:48:39.359 then we are looking for run in terminal
00:48:42.800 which is right about here
00:48:46.319 check that
00:48:47.599 close this tab let's stop this from
00:48:49.760 running
00:48:50.640 and we'll run it again okay here we go
00:48:53.359 what's your name i'll type in my first
00:48:55.440 name hit enter
00:48:57.440 hello
00:48:58.400 bro or whatever your first name was this
00:49:00.880 time let's ask a user for what their age
00:49:02.880 is i'll store this within a variable
00:49:05.280 named age
00:49:07.280 int age
00:49:09.280 standard
00:49:10.640 output
00:49:13.040 what's your age
00:49:17.599 standard
00:49:19.200 input
00:49:20.640 extraction operator
00:49:22.559 age
00:49:25.359 standard
00:49:26.559 output
00:49:27.839 insertion operator
00:49:29.920 you
00:49:30.880 are
00:49:32.559 age
00:49:34.880 years
00:49:35.839 old
00:49:37.839 and i think we'll need some new line
00:49:39.599 characters right about here just one
00:49:43.599 okay this should work let's try it
00:49:47.440 what's your name i'll type in my first
00:49:49.119 name hit enter what's your age i'll make
00:49:51.839 up an age i like to think that i'm 21
00:49:54.000 still hit enter
00:49:55.839 hello bro you are 21 years old so that's
00:49:58.720 how to accept some user input you can
00:50:00.559 use cn for character input but there's
00:50:03.920 just one problem though if you type in a
00:50:06.400 string that has spaces well once we hit
00:50:08.800 a space we stop reading that string this
00:50:11.359 time let's ask a user to type in their
00:50:13.520 full name
00:50:15.359 okay type in your first name and your
00:50:17.119 last name
00:50:18.880 hit enter what's your full name bro code
00:50:22.240 what's your age hello bro you are zero
00:50:24.800 years old if we need to read a string
00:50:27.119 that could contain spaces there's a
00:50:29.680 function that we can use to help us with
00:50:31.359 that that is the get line function
00:50:35.280 standard
00:50:36.720 get line add a set of parentheses within
00:50:39.920 the parentheses we will type standard
00:50:43.040 c in then comma our variable name now we
00:50:47.280 should be able to type in a string
00:50:48.720 including any spaces
00:50:51.359 what's your full name type in your own
00:50:53.119 first name and last name
00:50:54.880 hit enter what's your age i'll type in
00:50:57.119 21
00:50:58.160 hello bro code you are 21 years old if
00:51:01.119 you need to accept a string that
00:51:02.800 includes any white spaces you're better
00:51:04.960 off using the getline function and if
00:51:07.359 you forget i'll post this in the
00:51:08.640 comments section so you can always take
00:51:10.319 a look at it if you don't remember okay
00:51:12.000 there's just one issue with this though
00:51:13.680 i'm going to move the second question
00:51:15.839 above the first
00:51:19.200 let's take a look to see what happens
00:51:21.760 what's your age 21 what's your full name
00:51:24.559 hello you are 21 years old here's the
00:51:27.040 issue if we accept some user input with
00:51:29.520 cn followed by get line well in our
00:51:32.720 input buffer there's a new line
00:51:34.960 character and we don't pick up that new
00:51:37.040 line character when we reach the getline
00:51:39.280 function it accepts the newline
00:51:41.040 character that's still within the buffer
00:51:42.960 so to prevent that from happening
00:51:44.640 there's one change that we can make to
00:51:46.319 the getline function
00:51:47.920 after cn add this
00:51:50.800 extraction operator
00:51:52.800 standard ws for any white spaces this
00:51:56.160 portion will eliminate any new line
00:51:58.160 characters or any white spaces before
00:52:00.559 any user input so let's try this again
00:52:03.119 what's your age i'll type in 21 type in
00:52:05.520 your full name
00:52:07.440 and there we go hello bro code you are
00:52:09.680 21 years old so yeah everybody that's
00:52:12.079 how to accept some user input basically
00:52:14.640 you can just use cn followed by the
00:52:16.880 extraction operator but if you need a
00:52:18.960 string that could include spaces i
00:52:21.280 recommend using the getline function so
00:52:23.760 yeah that's how to accept some user
00:52:25.440 input in c plus plus if you would like a
00:52:27.599 copy of all this code i'll post this in
00:52:29.440 the comments section down below and well
00:52:31.440 yeah that's how to accept some user
00:52:33.200 input in c plus
00:52:37.599 hey guys in this video i'm going to show
00:52:39.680 you eight useful math related functions
00:52:42.240 in c plus plus let's begin by creating
00:52:44.880 three variables
00:52:46.559 double x and i will set this to be three
00:52:50.720 double y that will be four
00:52:53.599 then double z we will declare this but
00:52:56.160 not yet assign it the first useful math
00:52:58.400 related function is the max function
00:53:00.559 which will return the greater of two
00:53:02.480 values or variables
00:53:04.640 i'll assign the result within z z equals
00:53:09.040 standard max parentheses within the
00:53:12.160 parentheses add two values or variables
00:53:15.520 i'll compare x and y then let's display
00:53:18.400 the result
00:53:19.599 standard output i would like to display
00:53:21.760 whatever z is
00:53:23.119 the greater number between three and
00:53:24.960 four as well you guessed it four
00:53:27.440 alternatively there's the min function
00:53:30.480 z
00:53:31.359 equals standard
00:53:33.520 min
00:53:34.720 let's compare x then y
00:53:37.839 so the minimum between these two values
00:53:41.040 would be three
00:53:42.640 so that's max and min
00:53:44.400 now the rest of these functions are
00:53:45.839 found within the c math header file at
00:53:48.640 the top of our file let's include
00:53:51.359 c
00:53:52.160 math
00:53:53.200 we have the pow function to raise a base
00:53:55.440 to a given power
00:53:58.000 z equals pow
00:54:00.480 for power
00:54:01.839 let's raise 2 to the power of 3
00:54:07.280 z would be 8
00:54:09.760 two to the power of four
00:54:11.440 would be
00:54:13.119 sixteen that's the power function
00:54:15.839 then we have square root z equals
00:54:19.319 sqrt what's the square root of nine well
00:54:22.880 the square root of 9
00:54:25.599 is 3
00:54:27.280 then we have absolute value z equals abs
00:54:31.520 if you place a negative number within
00:54:33.440 the absolute value function it will give
00:54:35.440 you the positive version of that number
00:54:37.839 how far it is away from zero so negative
00:54:40.480 three
00:54:41.599 the absolute value of negative three
00:54:43.760 would be
00:54:45.359 three
00:54:46.240 that is the absolute value function
00:54:48.799 next we have the round function let's
00:54:50.799 change x to 3.14
00:54:54.799 z
00:54:55.680 equals round let's round x
00:54:59.960 3.14 rounded
00:55:02.720 would be 3. if you need to round up
00:55:05.119 there's a ceiling function
00:55:07.599 z equals seal seal means ceiling let's
00:55:11.680 round x
00:55:13.200 x rounded up
00:55:16.319 is four
00:55:17.599 alternatively there's the floor function
00:55:19.520 which will always round down
00:55:21.920 let's change x to 3.99 to test it
00:55:26.559 z
00:55:27.440 equals
00:55:28.640 floor
00:55:30.559 x
00:55:32.000 x rounded down
00:55:34.480 is three so yeah everybody that is a
00:55:37.359 super quick video on a few useful math
00:55:39.839 related functions
00:55:41.599 if you head to this url c plus plus dot
00:55:43.920 com slash reference slash c math there's
00:55:47.119 a lot more useful math functions that
00:55:48.960 you may be interested in but we just
00:55:50.960 covered a few of the basics in the next
00:55:52.960 topic we're going to create a practice
00:55:54.720 program to find the hypotenuse of a
00:55:56.799 right triangle so yeah those are a few
00:55:59.280 useful math related functions in c plus
00:56:01.680 plus
00:56:05.119 okay everybody this is going to be a
00:56:07.119 practice project to calculate the
00:56:09.280 hypotenuse of a right triangle
00:56:11.599 which we can find with this formula c
00:56:14.240 equals the square root of a squared plus
00:56:16.799 b squared we'll begin by declaring our
00:56:18.880 variables
00:56:20.319 double a
00:56:22.880 double b
00:56:25.040 double c
00:56:26.640 make sure you include c math as well
00:56:28.640 because we'll be using the power
00:56:30.000 function as well as the square root
00:56:31.440 function
00:56:32.400 at this point we'll accept some user
00:56:33.920 input for sides a and b
00:56:36.640 standard
00:56:37.920 output
00:56:39.040 will create a prompt
00:56:41.440 enter side a
00:56:46.880 standard
00:56:48.240 input
00:56:49.839 a
00:56:52.480 then we'll need side b
00:56:54.640 standard
00:56:56.839 output enter
00:56:59.280 side b
00:57:02.799 standard input
00:57:05.760 b
00:57:08.160 we can handle this formula step by step
00:57:10.319 we could reassign a equal to
00:57:14.960 power function
00:57:16.640 a to the power of two
00:57:19.440 b
00:57:20.319 equals power function
00:57:22.720 b to the power of two
00:57:25.680 side c
00:57:27.119 equals
00:57:28.480 the square root
00:57:30.240 of a plus b
00:57:34.640 then at the end we will display whatever
00:57:36.319 side c is
00:57:37.760 standard
00:57:39.440 output
00:57:42.799 side c
00:57:47.440 c
00:57:49.520 okay let's try this
00:57:52.559 enter side a
00:57:54.480 i'll type in three
00:57:56.160 side b will be four
00:57:58.240 side c is five
00:58:00.240 we could shorten this code too we could
00:58:02.240 say the square root of
00:58:05.119 a to the power of two
00:58:07.359 plus b to the power of two
00:58:11.520 then we no longer need these two lines
00:58:14.480 that's another way of writing it in less
00:58:16.160 lines of code let's try this again
00:58:20.160 this time side a will be four
00:58:22.480 side b will be five
00:58:24.799 side c is six point four so yeah
00:58:27.440 everybody that's a simple practice
00:58:29.520 project
00:58:30.559 just to get us used to accepting user
00:58:32.319 input as well as some math related
00:58:34.559 functions
00:58:35.599 if you would like a copy of this program
00:58:37.200 i'll post this in the comments section
00:58:38.720 down below and well yeah that's a simple
00:58:41.280 practice project in c plus
00:58:46.400 all right guys we are on if statements
00:58:49.200 with an if statement you do something if
00:58:51.760 a condition you set is true if not then
00:58:55.119 don't do it it's as simple as that we'll
00:58:57.200 ask a user what their age is if their
00:58:59.520 age is greater than or equal to 18
00:59:02.079 they'll be allowed into our site if
00:59:03.760 they're under 18 well we won't let them
00:59:05.839 in let's declare variable age int
00:59:08.799 age then we'll create a prompt
00:59:11.359 standard
00:59:12.480 output
00:59:14.240 enter your
00:59:16.079 age
00:59:19.520 standard
00:59:21.280 input
00:59:23.440 age
00:59:24.559 okay this is how to write an if
00:59:26.000 statement you type if then a set of
00:59:28.640 parentheses then a set of curly braces
00:59:31.440 if some condition within the parentheses
00:59:34.079 is true
00:59:35.440 you perform some subset of code we are
00:59:37.920 going to check if age is greater than or
00:59:41.119 equal to 18. greater than or equal to is
00:59:44.559 a comparison operator there's other
00:59:46.319 comparison operators such as less than
00:59:48.880 or equals to
00:59:50.400 less than greater than
00:59:52.640 if you need to compare if two values are
00:59:54.640 equal you use two equal signs you don't
00:59:56.799 want to say equals because then you're
00:59:58.720 setting age equal to 18 equals is the
01:00:01.280 assignment operator so let's check to
01:00:03.200 see if age is greater than or equal to
01:00:05.200 18. then we'll print a message
01:00:07.440 standard output
01:00:11.920 welcome to the site
01:00:16.160 okay let's try this
01:00:19.599 enter your age
01:00:20.960 let's say that i'm 12.
01:00:22.799 well it doesn't do anything since this
01:00:25.040 condition evaluated to be false we skip
01:00:28.160 over this body of code
01:00:30.480 if it were true then we execute it this
01:00:33.599 time my age is 21 i hit enter
01:00:36.799 welcome to the site if you would rather
01:00:38.799 do something else if a condition is
01:00:40.400 false you can use an else statement
01:00:42.720 an else statement you will place at the
01:00:44.319 end
01:00:45.040 there is no condition
01:00:46.720 else we will print
01:00:48.559 standard output you are not old enough
01:00:53.440 to
01:00:54.839 enter okay let's try this again
01:00:58.880 and to your age i'll say that i'm 12
01:01:01.599 you are not old enough to enter that's
01:01:03.839 an if statement if some condition is
01:01:05.680 true you do something
01:01:07.599 if not you can do something else or
01:01:10.000 nothing at all there are more conditions
01:01:12.079 you can check by using an else if
01:01:13.839 statement we can check another condition
01:01:15.839 by adding else if
01:01:19.040 if this condition is false
01:01:21.040 check this else if condition
01:01:23.280 uh let's check to see if age is
01:01:26.480 less than zero
01:01:28.640 that means somebody hasn't been born yet
01:01:34.160 you
01:01:34.960 haven't been
01:01:36.720 born yet
01:01:39.359 okay now check this out
01:01:41.680 let's say that my age is negative 10
01:01:45.440 then i hit enter
01:01:47.200 you haven't been born yet
01:01:49.440 since this condition was false we
01:01:51.920 skipped this section of code then we
01:01:53.920 check the else if statement since this
01:01:56.400 condition was true we execute this body
01:01:59.119 of code then skip over the else
01:02:00.960 statement let's add one more else if
01:02:03.200 statement
01:02:04.480 else if
01:02:07.920 age is greater than or equal to 100
01:02:13.599 standard
01:02:15.760 output
01:02:18.799 you are too old to enter this site
01:02:24.480 okay enter your age i am 120 years old i
01:02:28.079 hit enter
01:02:29.520 welcome to the site we check these
01:02:31.280 conditions one by one starting from the
01:02:33.039 top we stated that our age was 120 years
01:02:36.079 old even though we were expecting to
01:02:38.079 execute this body of code we instead
01:02:40.480 executed this body of code within the if
01:02:42.960 statement that's because our age was
01:02:45.280 technically still greater than or equal
01:02:47.359 to 18. so the order of your if and else
01:02:50.160 if statements does matter it makes a
01:02:51.839 difference if we need to execute this
01:02:53.920 body of code if somebody's age is
01:02:55.680 greater than or equal to 100 well then
01:02:58.160 we should probably move that to the top
01:03:00.160 then turn it into an if statement
01:03:02.559 else if age is greater than or equal to
01:03:05.039 18 we will display this message let's
01:03:07.839 try this one more time and to your age i
01:03:09.920 am 120 years old i hit enter
01:03:12.799 you are too old to enter the site so
01:03:15.359 yeah that's an if statement
01:03:17.119 you do something if a condition is true
01:03:20.000 if not then you don't do it if you would
01:03:22.319 rather do something else you can use an
01:03:24.160 else statement if there's other
01:03:25.599 conditions you would like to check
01:03:26.960 before reaching the else statement you
01:03:28.880 can use an else if statement and there's
01:03:31.280 really no limit to these if you would
01:03:33.119 like a copy of this code i'll post this
01:03:35.119 in the comments section down below and
01:03:36.799 well yeah those are if statements in c
01:03:39.680 plus
01:03:42.880 all right everybody today we're going to
01:03:44.880 discuss switches a switch is an
01:03:47.119 alternative to using many else if
01:03:49.200 statements it compares one value against
01:03:52.240 many matching cases here's an example of
01:03:54.799 what you don't want to do i have this
01:03:57.039 program we have variable month month is
01:03:59.680 of the integer data type the user will
01:04:01.760 type in a number 1 through 12 to
01:04:03.599 represent the month if month is equal to
01:04:06.079 1 it is january
01:04:08.319 else if month is equal to 2 it is
01:04:10.960 february else if month is three four
01:04:14.319 five so on and so forth this is what you
01:04:16.960 don't want to do because it's
01:04:18.319 inefficient it's how the game yandere
01:04:20.319 simulator was created if you know what
01:04:22.000 that is a better solution would be to
01:04:24.000 use a switch this is how to write one
01:04:26.640 i'm going to delete all of this
01:04:29.599 we will type switch parentheses curly
01:04:32.799 braces what value would we like to
01:04:35.200 examine against matching cases let's
01:04:37.839 examine our month to write a case we
01:04:40.720 would type case
01:04:42.240 then the value let's check to see if
01:04:44.960 month is equal to one
01:04:46.960 so case one colon on the next line what
01:04:50.640 we want to do if month is equal to one
01:04:53.520 let's display a message
01:04:55.280 standard output
01:04:58.319 it is
01:04:59.839 january
01:05:02.000 at the end of this case add break to
01:05:04.400 break out of the switch
01:05:06.000 so that is case one let's work on case
01:05:08.319 two
01:05:09.760 so case two
01:05:11.599 it is february
01:05:13.680 i think the rest is self-explanatory
01:05:15.440 i'll speed up the footage
01:05:41.520 we have our 12 cases 1 through 12. each
01:05:44.720 case corresponding with a month of the
01:05:46.640 year
01:05:47.520 let's run this
01:05:48.880 enter the month
01:05:50.480 let's say that the month is 4 for april
01:05:53.839 it is april
01:05:55.119 one more time
01:05:56.559 the month is 12 it is december so a
01:05:59.520 switch is an alternative to using many
01:06:01.599 else if statements it's more efficient
01:06:03.520 and easier to read if there are no
01:06:05.680 matching cases we can execute a default
01:06:08.240 case type
01:06:10.079 default
01:06:12.079 then what would we like to do
01:06:14.480 standard output
01:06:16.880 let's say please enter in only numbers
01:06:23.920 1 through 12.
01:06:31.599 enter the month
01:06:32.960 uh let's type negative 42.
01:06:36.880 please enter in only numbers 1 through
01:06:38.880 12. so the default case is kind of like
01:06:41.359 the else statement if there are no
01:06:43.359 matching cases we execute whatever's
01:06:45.200 within the default case let's try one
01:06:47.680 more example this time we'll have a user
01:06:50.000 enter in a character a letter grade will
01:06:52.480 display a custom message depending on
01:06:54.240 what grade they have
01:06:56.480 char
01:06:58.240 grid
01:07:00.559 standard
01:07:02.079 output
01:07:05.599 what
01:07:06.480 letter grade
01:07:11.599 standard
01:07:13.520 input
01:07:16.400 grade
01:07:17.920 then we'll create a switch
01:07:19.599 switch parentheses curly braces
01:07:22.640 we're examining our letter grade against
01:07:24.640 matching cases the first case will be
01:07:27.839 the character a
01:07:29.839 what will we display if somebody
01:07:31.599 receives an a
01:07:33.599 standard output
01:07:36.160 you did great
01:07:40.000 then
01:07:40.839 break case
01:07:43.119 b
01:07:46.079 standard
01:07:47.280 output
01:07:50.319 you
01:07:51.119 did good
01:07:54.319 then break
01:07:57.680 case c
01:08:01.200 standard
01:08:02.720 output
01:08:06.319 you did
01:08:08.000 okay
01:08:10.480 break
01:08:12.400 case d
01:08:16.880 standard output
01:08:19.920 you did not
01:08:22.719 do
01:08:23.520 good
01:08:26.719 break
01:08:28.319 case f
01:08:32.000 standard output
01:08:35.679 you failed
01:08:39.040 break then let's add a default case
01:08:48.238 please
01:08:49.439 only enter in a letter grade
01:08:54.399 a through f
01:08:57.439 let's try it
01:08:59.120 what letter grade i received in a you
01:09:01.359 did great
01:09:03.359 what letter grade f
01:09:05.198 you failed then let's test our default
01:09:07.759 case what letter grid
01:09:09.679 pizza
01:09:11.359 please only enter in a letter grade a
01:09:13.520 through f so yeah that's a switch
01:09:15.679 everybody it's an alternative to using
01:09:18.080 many else if statements it's more
01:09:20.238 efficient and easier to read your
01:09:22.000 assignment is to create a switch and
01:09:23.839 post it in the comments section and well
01:09:25.920 yeah those are switches in c plus
01:09:31.600 hey guys in this video we're going to
01:09:33.439 create a simple calculator program now
01:09:35.839 that we know how switches work this will
01:09:37.679 be a very simple program let's begin by
01:09:40.238 declaring our variables at the top we'll
01:09:42.238 need a character for an operator
01:09:44.799 we'll name this op the operator will be
01:09:47.040 either addition subtraction
01:09:48.799 multiplication or division
01:09:51.600 double
01:09:52.560 num1
01:09:54.400 double
01:09:55.280 num2
01:09:57.040 double result
01:09:59.360 this next part isn't necessary but i'm
01:10:01.360 just going to add one line of text when
01:10:03.520 we begin the program
01:10:05.440 i'll add a bunch of asterisks let's say
01:10:07.679 calculator
01:10:12.239 then i'll add a new line to the
01:10:14.840 end wherever my program ends i will
01:10:17.920 create another line of asterisks
01:10:22.719 and i can get rid of that new line
01:10:24.080 character
01:10:25.920 our code for our program will be within
01:10:27.840 these two lines of output let's ask the
01:10:30.159 user what operand they would like
01:10:32.880 standard output
01:10:36.080 enter either
01:10:38.640 addition subtraction multiplication or
01:10:41.280 division
01:10:44.560 standard
01:10:46.159 input
01:10:48.000 will store the response within the
01:10:49.679 variable op
01:10:52.000 standard output
01:10:55.280 enter number one
01:11:02.159 standard input
01:11:04.400 num1
01:11:06.560 let's copy these two lines
01:11:09.120 paste them
01:11:10.880 change one here
01:11:12.880 and here
01:11:14.560 now we need a switch
01:11:17.199 switch parentheses curly braces
01:11:20.080 we're examining our operator against
01:11:22.159 matching cases
01:11:23.920 the first case will be addition
01:11:27.600 make sure the operand is within single
01:11:29.280 quotes because it's a character
01:11:31.040 if the user wants to add two numbers
01:11:33.199 we'll take result equals num1 plus num2
01:11:39.040 display the result
01:11:40.480 standard output
01:11:42.480 will display the word result
01:11:45.199 followed by the variable result
01:11:48.400 then i'll add a new line to the end
01:11:52.560 then break then we need a case for
01:11:55.120 subtraction
01:11:59.920 case
01:12:00.880 subtraction
01:12:02.239 num1 minus num2
01:12:06.640 multiplication
01:12:09.040 case multiplication
01:12:11.520 num1
01:12:13.679 times num2
01:12:15.679 then division
01:12:19.440 case division
01:12:21.120 num1 divided by num2
01:12:24.000 what if somebody doesn't type in a valid
01:12:25.760 operator let's add a default case
01:12:28.560 default
01:12:31.120 standard output
01:12:33.920 that wasn't a valid
01:12:36.960 response
01:12:40.080 then break
01:12:41.440 i'll add a new line too
01:12:44.159 okay we are good to go let's save run
01:12:46.480 this
01:12:51.040 calculator
01:12:53.120 let's add two numbers
01:12:55.199 enter number one
01:12:56.800 one point two three
01:12:59.040 enter number two three point one four
01:13:01.920 the result is 4.37
01:13:04.880 let's run this again
01:13:07.360 we will subtract two numbers
01:13:10.320 1.23
01:13:11.920 minus 3.14 is negative 1.91
01:13:16.320 let's multiply two numbers
01:13:18.960 1.23
01:13:22.159 times 3.14
01:13:24.480 that's 3.8622
01:13:28.560 now we will divide two numbers
01:13:30.640 1.23
01:13:32.159 divided by 3.14
01:13:34.560 that is 0.39172
01:13:38.960 let's type in an operator that's not
01:13:40.560 valid
01:13:42.000 how about a w
01:13:43.920 enter number one 1.23
01:13:46.360 3.14
01:13:47.920 that wasn't a valid response
01:13:50.159 actually i think it would be better if
01:13:51.440 we said that wasn't a valid operator
01:13:55.040 all right everybody that is a simple
01:13:57.440 calculator program in c plus using a
01:14:00.640 switch
01:14:01.679 if you would like a copy of this code
01:14:03.199 i'll post this in the comment section
01:14:04.719 down below if you're enjoying this
01:14:06.159 series please let me know by smashing
01:14:08.000 that like button leave a random comment
01:14:09.920 down below and subscribe if you'd like
01:14:11.760 to become a fellow bro
01:14:15.600 okay guys we are talking about the
01:14:17.840 ternary operator which is represented by
01:14:20.400 a question mark followed by a colon it's
01:14:22.880 a replacement to using an if else
01:14:25.360 statement you write a condition then add
01:14:27.600 a question mark kind of like you're
01:14:29.199 asking a question
01:14:30.800 is something true if that condition is
01:14:32.960 true we can do some code if it's false
01:14:35.760 we do some other code here's an example
01:14:38.320 we have a grade my grade is 75. if grade
01:14:41.440 is greater than or equal to 60 i'll
01:14:43.840 output you pass
01:14:45.760 else will output you fail my grade is 75
01:14:50.640 therefore i pass another way of writing
01:14:53.120 this is to use the ternary operator
01:14:55.760 first we write a condition so let's get
01:14:57.760 rid of this if statement
01:15:00.640 after our condition we'll add a question
01:15:02.400 mark
01:15:03.280 now parentheses are optional then we
01:15:05.280 write some expression
01:15:10.159 standard output you pass
01:15:12.480 we do this if our condition is true
01:15:14.719 colon what will we do if that condition
01:15:17.120 is false
01:15:18.400 well let's use whatever's within our
01:15:20.080 else statement
01:15:22.719 and this would work the same if my grade
01:15:24.880 is 75
01:15:28.880 you pass
01:15:31.600 if it's 50
01:15:35.600 you fail
01:15:37.040 let's come up with a few other examples
01:15:39.920 let's check to see if a number is even
01:15:42.000 or odd
01:15:44.239 int number equals
01:15:47.120 what about nine
01:15:48.640 we write a condition
01:15:50.480 we'll check if number
01:15:52.800 modulus two remember modulus gives you
01:15:55.520 the remainder of any division does
01:15:57.600 number divide by two evenly so this
01:16:00.000 returns a one or a zero if number
01:16:03.280 modulus two
01:16:05.040 is equal to 1
01:16:07.760 question mark then let's display
01:16:13.199 odd
01:16:15.120 if it's false we'll display standard
01:16:18.480 output
01:16:20.640 even
01:16:23.520 okay odd let's change number to eight
01:16:28.960 now it's even you don't necessarily need
01:16:31.360 equals one or equal zero the number 1
01:16:34.800 does correspond to true and 0
01:16:36.960 corresponds to false so you could write
01:16:38.960 it like this too
01:16:40.239 8 divides by 2 evenly that's even
01:16:43.440 if it's 9
01:16:45.360 that is odd
01:16:47.120 okay last example
01:16:49.280 let's examine a boolean variable bull
01:16:52.640 how about hungry is somebody hungry
01:16:55.920 i'll set this to be true
01:16:58.719 let's write our condition
01:17:01.040 hungry
01:17:03.440 equals true question mark now if you're
01:17:06.480 examining to see if a boolean variable
01:17:08.800 is true you don't necessarily need
01:17:11.280 equals true you can just say that
01:17:13.199 boolean variable hungry question mark
01:17:15.679 like you're asking a question so if
01:17:17.679 hungry is true
01:17:19.679 we will do this standard
01:17:22.159 output
01:17:24.560 you are hungry
01:17:27.440 colon
01:17:28.400 what will we do if it's false standard
01:17:31.440 output
01:17:33.760 you
01:17:34.719 are
01:17:35.679 full
01:17:38.159 hungry is set to true
01:17:41.040 you are hungry if it were false
01:17:46.159 you are full if we're displaying output
01:17:48.320 there's a couple different ways in which
01:17:49.920 we could write this it's up to you how
01:17:51.679 you want to handle it
01:17:53.120 so another way of writing the same code
01:17:54.880 would be
01:17:56.840 standard output
01:18:00.320 then within a set of parentheses then we
01:18:02.239 could use our canary operator
01:18:05.679 hungry question mark
01:18:08.880 you are hungry
01:18:12.239 else
01:18:13.760 you
01:18:14.640 are
01:18:15.520 full
01:18:17.679 this would work as well let's just check
01:18:19.360 that hungry is set to false
01:18:21.760 you are full
01:18:23.120 let's set it to true
01:18:27.520 you are hungry so yeah that's the
01:18:29.600 ternary operator everybody it's a
01:18:31.920 question mark followed by a colon you
01:18:34.159 write a condition as if you're asking a
01:18:35.920 question if that condition is true you
01:18:38.719 do some expression if not you do some
01:18:41.440 other expression it's a replacement to
01:18:43.679 an if else statement your assignment is
01:18:46.400 to post a use of the trinary operator in
01:18:48.719 the comments section and well yeah
01:18:50.560 that's the ternary operator in c plus
01:18:52.800 plus
01:18:55.760 hey guys in this video i'm going to
01:18:57.360 discuss the and or as well as not
01:19:00.719 logical operators we'll begin with and
01:19:03.040 the and logical operator will check to
01:19:05.120 see if two conditions are true here's an
01:19:07.920 example we'll ask a user what the
01:19:09.679 temperature is int temp short for
01:19:12.400 temperature
01:19:13.679 standard output this will be a prompt
01:19:17.040 enter the
01:19:18.640 temperature
01:19:23.040 standard
01:19:24.400 input
01:19:25.920 temp
01:19:27.120 with the andological operator we check
01:19:29.440 to see if two or more conditions are
01:19:31.920 true let's see if our temperature falls
01:19:33.920 within a certain range if
01:19:36.800 condition then a set of curly braces
01:19:39.280 we'll check to see if our temperature is
01:19:41.679 above zero if temp
01:19:44.000 is above zero
01:19:46.800 and
01:19:47.920 temp
01:19:48.880 is less than let's say 30. in order for
01:19:52.159 us to execute this if statement both of
01:19:54.480 these conditions must be true
01:19:56.960 this condition
01:19:58.239 and this condition must be true if one
01:20:00.960 of them is false we skip over this if
01:20:03.040 statement so if our temperature falls
01:20:05.280 within that range
01:20:08.480 the
01:20:09.600 temperature
01:20:11.840 is
01:20:13.520 good
01:20:16.840 else
01:20:18.560 standard
01:20:19.679 output
01:20:22.320 the temperature
01:20:26.320 is bad
01:20:29.360 okay let's try
01:20:30.840 it enter the temperature uh let's say
01:20:34.639 it's 25 degrees this will be in celsius
01:20:38.400 the temperature is good
01:20:40.239 let's try it again
01:20:41.520 uh what about negative 100 degrees
01:20:44.840 celsius uh the temperature is bad yeah
01:20:47.520 no kidding one more time uh positive 100
01:20:51.120 degrees celsius
01:20:52.639 the temperature is bad so with the and
01:20:55.040 logical operator we check to see if two
01:20:57.760 or more conditions are true there's
01:20:59.600 another way of writing the same program
01:21:01.280 too we can use the or logical operator
01:21:04.239 which is represented by two vertical
01:21:06.159 bars it checks to see if at least one of
01:21:09.600 two conditions are true
01:21:11.679 if temp
01:21:13.360 is less than or equal to zero
01:21:17.040 or
01:21:18.000 temp is greater than or equal to 30. the
01:21:21.360 temperature is bad
01:21:23.520 else the temperature is good
01:21:26.480 in order for us to execute this if
01:21:28.080 statement only one condition has to be
01:21:30.639 true if both of them are false we don't
01:21:33.120 do anything
01:21:34.639 what's the temperature the temperature
01:21:36.480 is 25 that's within that range
01:21:39.360 the temperature is good
01:21:41.280 one more time
01:21:42.480 enter the temperature it is negative 100
01:21:45.280 degrees celsius
01:21:46.960 the temperature is bad
01:21:48.800 all right so that's the and as well as
01:21:51.040 the or logical operator there's one more
01:21:53.920 the not logical operator which is an
01:21:56.320 exclamation point it reverses the
01:21:58.560 logical state of its operand meaning if
01:22:01.440 a condition is true it becomes false if
01:22:04.320 it's originally false it becomes true
01:22:06.800 let's create another variable this will
01:22:08.639 be a boolean sunny
01:22:11.280 sunny can be true or false
01:22:14.560 i'll write another if statement
01:22:17.280 if
01:22:18.560 sunny
01:22:19.600 is equal to true
01:22:22.000 now if you're examining to see if a
01:22:24.080 boolean variable is true you don't
01:22:26.560 necessarily need to say
01:22:28.400 equals true you could just type the name
01:22:30.880 of the boolean variable
01:22:32.560 if sunny
01:22:34.719 if sunny is true we'll display a message
01:22:38.400 standard output
01:22:40.159 it is sunny outside
01:22:46.080 else
01:22:47.360 standard
01:22:48.560 output
01:22:50.400 it is cloudy
01:22:53.199 outside
01:22:55.520 okay one more time
01:22:59.280 enter the temperature it's 20 degrees
01:23:01.440 celsius
01:23:03.040 i should probably add some new line
01:23:04.239 characters
01:23:06.480 there enter the temperature it's 25
01:23:08.560 degrees celsius the temperature is good
01:23:11.280 it is sunny outside if we use the not
01:23:13.760 logical operator we can precede a
01:23:15.840 condition with an exclamation point
01:23:18.000 we're checking to see if it's not sunny
01:23:21.440 that means we would want to change our
01:23:22.960 output
01:23:24.239 it is cloudy outside else it is sunny
01:23:27.679 outside
01:23:28.880 let's change sunny to be false
01:23:31.760 enter the temperature it is 50 degrees
01:23:33.920 celsius
01:23:35.440 the temperature is bad it is cloudy
01:23:37.360 outside so yeah everybody those are
01:23:39.760 logical operators and
01:23:41.920 or
01:23:42.719 not your assignment is to use either the
01:23:45.120 and or or otherwise not logical operator
01:23:48.880 then post it in the comment section down
01:23:50.320 below whatever you wrote so yeah those
01:23:52.400 are logical operators in c plus
01:23:57.440 okay guys in this video we're going to
01:23:59.679 create a temperature conversion program
01:24:02.480 to convert from fahrenheit to celsius or
01:24:04.800 celsius to fahrenheit at the top of our
01:24:07.199 program let's declare our variables
01:24:09.440 double temp
01:24:10.800 temp is short for temperature
01:24:12.800 then char unit
01:24:15.440 will the user select celsius or
01:24:17.199 fahrenheit
01:24:18.560 now with my programs i like to add a
01:24:20.239 title at the beginning
01:24:21.760 standard output
01:24:27.639 temperature
01:24:29.360 conversion
01:24:31.440 it's totally not necessary but it's
01:24:33.440 something that i like to do
01:24:35.280 then i'll add another line of output at
01:24:37.280 the end of my program to show the user
01:24:39.199 that the program is over
01:24:40.960 i'll just add a bunch of asterisks
01:24:43.120 like i said totally not necessary but
01:24:44.880 it's something i just like to do i will
01:24:46.880 display a couple lines of output
01:24:51.360 f
01:24:52.159 equals
01:24:54.159 fair and height i can never spell
01:24:56.560 fahrenheit right i think that's okay
01:24:59.520 i'll add a new line
01:25:02.320 standard
01:25:03.760 output
01:25:05.600 c equals
01:25:08.400 celsius
01:25:10.400 add a new line
01:25:13.600 standard output
01:25:17.120 what unit
01:25:18.639 would
01:25:19.679 you like to convert
01:25:23.120 to
01:25:27.600 standard input
01:25:29.840 unit
01:25:32.400 the user will hopefully type in f or c
01:25:35.760 depending on what they want to convert
01:25:37.280 to
01:25:38.239 let's check to see if the user types in
01:25:40.400 f first
01:25:41.760 if
01:25:42.639 unit
01:25:43.600 is equal to the character f that's a
01:25:46.239 capital left
01:25:47.679 but you know maybe the user types in
01:25:49.440 lowercase f i'll add an or conditional
01:25:51.920 operator or unit
01:25:55.040 is equal to
01:25:56.639 a lowercase f that's also a valid
01:25:58.880 response
01:26:00.000 if the user would like to convert a
01:26:01.600 temperature to fahrenheit
01:26:03.520 these are the steps we can do
01:26:06.960 standard
01:26:08.480 output
01:26:10.960 enter the
01:26:13.040 temperature
01:26:15.520 in
01:26:17.040 celsius
01:26:23.040 input
01:26:24.719 temp to store the temperature
01:26:27.199 to convert our temperature from celsius
01:26:29.120 to fahrenheit we can assign temp
01:26:32.000 equal to now here's the formula
01:26:34.840 1.8
01:26:36.560 times
01:26:38.000 our temp
01:26:39.679 plus
01:26:40.800 32
01:26:43.199 then we will display the temperature
01:26:45.440 standard output
01:26:50.320 temperature
01:26:53.760 is
01:26:57.920 temp
01:27:00.000 degrees
01:27:02.840 fahrenheit then i'll add a new line
01:27:06.639 if the user would like to convert to
01:27:08.159 celsius i'll add an else if statement
01:27:11.520 else if
01:27:13.040 unit is equal to
01:27:16.159 the character capital c
01:27:18.560 or
01:27:19.440 unit is equal to the character lowercase
01:27:23.120 c
01:27:25.120 we can copy these two lines of code and
01:27:27.120 reuse them
01:27:28.239 we'll just repurpose them
01:27:30.000 enter the temperature in fahrenheit
01:27:34.320 here is the formula to convert from
01:27:35.920 fahrenheit to celsius
01:27:38.639 temp
01:27:39.600 equals
01:27:41.360 our current temperature minus 32
01:27:44.800 divided by 1.8
01:27:48.639 then let's display our temperature i'll
01:27:50.880 copy this line of code paste it
01:27:54.000 change fahrenheit to celsius
01:27:57.440 now what if the user doesn't type in a
01:27:58.800 valid response
01:28:00.960 else
01:28:02.239 standard output
01:28:05.280 please enter in only c
01:28:08.800 or f
01:28:12.000 add a new line
01:28:14.719 and that should be everything let's try
01:28:16.320 this
01:28:18.800 temperature conversion program what unit
01:28:21.600 would you like to convert to i would
01:28:23.199 like to convert to fahrenheit
01:28:25.920 enter the temperature in celsius so
01:28:27.920 what's zero degrees celsius converted to
01:28:29.920 fahrenheit
01:28:32.000 that is 32 degrees fahrenheit
01:28:34.960 let's go again let's convert to celsius
01:28:38.080 enter the temperature in fahrenheit
01:28:40.639 what's 100 degrees in celsius
01:28:45.960 37.7 degrees celsius
01:28:48.880 let's type in a response that's not
01:28:50.400 valid
01:28:51.520 uh i would like to convert to pizza
01:28:54.080 please enter in only c or f
01:28:57.360 all right everybody that is a program to
01:28:59.520 convert from fahrenheit to celsius or
01:29:01.760 vice versa i thought we could use some
01:29:03.920 practice using conditional operators
01:29:06.400 as well as if statements if you would
01:29:08.800 like a copy of this code i'll post this
01:29:10.560 in the comment section down below and
01:29:12.239 well yeah that's a temperature
01:29:13.920 conversion program in c plus plus
01:29:18.960 hey what's going on everybody so in this
01:29:21.040 video i'm going to explain some useful
01:29:23.360 string methods that you might be
01:29:25.120 interested in let's begin by creating a
01:29:27.120 variable named name standard string
01:29:31.520 name
01:29:32.719 we'll accept some user input we'll need
01:29:34.639 a prompt
01:29:35.679 standard
01:29:36.840 output
01:29:38.480 enter your name
01:29:42.639 a user's name may contain spaces we're
01:29:45.199 better off using the getline function
01:29:47.360 standard
01:29:50.840 getline standard cn
01:29:56.560 name the first useful method is the
01:29:58.880 length method type your string name
01:30:01.760 follow it with dot
01:30:04.719 length parenthesis
01:30:06.480 the length method will give you the
01:30:08.320 length of a string let's write this
01:30:10.080 within an if statement
01:30:12.159 if
01:30:13.520 name dot length method is greater than
01:30:16.480 12
01:30:17.600 we'll print a message
01:30:19.120 such as your name can't be over 12
01:30:21.280 characters long
01:30:23.520 standard output
01:30:26.880 your
01:30:28.239 name
01:30:29.760 can't be over 12
01:30:32.800 characters
01:30:36.239 else will print a different message
01:30:38.880 standard
01:30:40.080 output
01:30:43.760 welcome
01:30:47.280 the user's name
01:30:49.440 enter your name type in your full name
01:30:54.159 welcome whatever your name is okay now
01:30:56.800 what if our name is over 12 characters
01:31:01.440 type in your full name
01:31:03.679 then just add a bunch of characters
01:31:07.120 your name can't be over 12 characters
01:31:09.760 that is the built-in length method of
01:31:12.080 strings you type a string follow it with
01:31:14.400 dot length parenthesis wherever you
01:31:17.280 invoke this method in that spot you will
01:31:19.679 return the length of that string in
01:31:21.920 characters the empty method will return
01:31:24.480 if a string is empty or not
01:31:27.199 type your string name
01:31:29.120 dot empty parenthesis
01:31:32.000 this returns a boolean value
01:31:35.120 if
01:31:36.080 name is empty
01:31:38.400 will display a message
01:31:42.080 you
01:31:42.880 didn't enter your name
01:31:47.679 else
01:31:52.960 hello whatever your name is
01:31:58.000 okay i'm just going to hit enter
01:32:00.560 you didn't enter your name but if i do
01:32:02.639 enter my name
01:32:04.239 it works normally hello whatever your
01:32:06.400 name is
01:32:07.360 that is the empty method of strings
01:32:09.600 you'll check to see if a string is empty
01:32:11.679 or not a useful case of this is to check
01:32:14.000 to see if somebody enters in some user
01:32:15.840 input another is clear
01:32:18.239 name dot clear
01:32:21.440 then let's display our name
01:32:24.239 standard output
01:32:27.840 hello
01:32:30.400 name
01:32:32.480 enter your name type in your first name
01:32:34.080 and last name
01:32:36.480 hello and we don't have a name anymore
01:32:38.639 because that name has been cleared
01:32:40.960 so that is the clear method we can
01:32:43.360 append a string to another string
01:32:45.679 after my name i will use append
01:32:48.719 parenthesis within the parentheses we
01:32:51.199 can add a string to the end of another
01:32:53.199 string i'll add at gmail.com
01:32:57.440 standard output
01:33:01.280 your username is now
01:33:07.120 name
01:33:08.719 enter your name
01:33:12.719 your username is yourname
01:33:15.440 with at gmail.com appended to it that is
01:33:18.560 the append method
01:33:20.159 we can return a character at a given
01:33:22.560 position within a string
01:33:25.440 standard output
01:33:27.679 type your string name
01:33:29.760 dot at parentheses
01:33:32.880 so the first character in a string has
01:33:34.960 an index of zero i'll display whatever
01:33:37.360 that character is
01:33:39.280 enter your name
01:33:41.600 so the first character in my string is a
01:33:44.000 capital b
01:33:45.280 the character at index one
01:33:47.360 well that would be
01:33:49.520 r we can insert a character at a given
01:33:51.920 position type your string
01:33:54.880 follow it with insert
01:33:58.719 there will be two arguments we'll list
01:34:00.400 within the parentheses and index so the
01:34:02.880 beginning of our string would have an
01:34:04.159 index of zero comma then what would we
01:34:07.120 like to insert i'll insert the at sign
01:34:09.679 at the beginning of my name
01:34:12.400 then let's display our name
01:34:22.960 okay so we now have the at sign inserted
01:34:26.400 at the beginning of our string or you
01:34:28.159 could pick a different position the
01:34:29.679 index of one would be the second
01:34:31.199 character technically so yeah pick a
01:34:33.920 position then you can insert a string
01:34:36.000 now we can find a certain character i
01:34:38.159 would like to find if there's any spaces
01:34:39.760 within my name
01:34:41.119 name dot find
01:34:43.920 then place a character i'll look for any
01:34:46.239 white spaces this method will give me
01:34:48.639 the position of the first space type in
01:34:51.280 your first name and last name
01:34:53.840 the index of the first white space
01:34:55.520 within my name has an index of three the
01:34:58.000 first character is always zero zero one
01:35:01.280 two three okay then lastly erase
01:35:04.719 name
01:35:05.600 dot erase
01:35:07.840 we can erase a portion of a string we'll
01:35:10.639 need a beginning index
01:35:12.480 and an ending index i'll eliminate the
01:35:15.360 first three characters then we will
01:35:17.440 display our name enter your name
01:35:22.800 okay and that's what's left of my name i
01:35:24.800 deleted the first three characters
01:35:26.880 the first number is the beginning index
01:35:29.280 the second is the ending index it's not
01:35:31.679 inclusive though so yeah those are a few
01:35:34.080 helpful string methods if you would like
01:35:36.239 to know more head to the string class on
01:35:38.719 the cplusplus.com website and there's a
01:35:41.840 fairly extensive list hey if you're
01:35:43.760 enjoying the series let me know by
01:35:45.440 smashing that like button leave a random
01:35:47.199 comment down below and subscribe if
01:35:48.880 you'd like to become a fellow bro
01:35:53.280 hey everybody in this video i'm going to
01:35:55.119 explain while loops a while loop is much
01:35:57.520 like an if statement except we can
01:36:00.080 repeat some code potentially an infinite
01:36:02.639 amount of times here's an example of
01:36:04.480 where a while loop would be useful let's
01:36:06.639 say that we'll have a user enter in
01:36:08.239 their name
01:36:09.440 standard
01:36:10.639 string
01:36:11.679 name
01:36:12.880 at first i'll use an if statement
01:36:15.520 if
01:36:16.480 name
01:36:17.280 i'll check to see if the name is empty
01:36:19.360 did the user actually type in something
01:36:22.880 if name is empty we'll create a prompt
01:36:26.480 standard output
01:36:30.080 enter your name
01:36:34.400 standard
01:36:36.000 getline
01:36:38.400 standard
01:36:39.840 input
01:36:42.239 name
01:36:43.600 once we exit the if statement
01:36:46.000 we'll display a message involving the
01:36:47.920 user's name
01:36:49.280 standard output
01:36:51.600 hello
01:36:54.080 name
01:36:56.159 and to your name i'm just going to hit
01:36:57.920 enter and not enter in anything
01:37:00.159 hello
01:37:01.119 and i don't have a name
01:37:02.960 what if we need to force the user to do
01:37:05.119 something in order to continue with the
01:37:06.719 rest of the program well we could change
01:37:08.960 this if statement to a while loop
01:37:14.000 if this condition remains true we will
01:37:17.040 execute this code a potentially infinite
01:37:20.320 amount of times once we reach the end of
01:37:22.719 this code block we check the condition
01:37:24.880 again if it's still true we repeat the
01:37:27.760 code again
01:37:28.960 enter your name i'm going to hit enter
01:37:31.280 enter your name no enter your name no
01:37:33.679 enter your name no so i can't actually
01:37:36.080 continue with the rest of my program
01:37:37.920 until i type in something i'll type in
01:37:40.080 my full name
01:37:41.360 hit enter
01:37:42.719 hello whatever your name is basically
01:37:45.280 speaking a while loop is kind of like an
01:37:47.440 if statement
01:37:48.560 except it can repeat some code
01:37:50.480 infinitely as long as this condition
01:37:52.560 remains true we check this condition
01:37:54.480 once when we enter the while loop then
01:37:56.639 any time we finish the while loop we
01:37:58.400 check the condition again if the
01:38:00.080 condition is false we exit then continue
01:38:02.719 on with the rest of the program you do
01:38:04.560 want some way to exit the while loop
01:38:06.480 let's write a condition that we won't be
01:38:08.159 able to change at all
01:38:09.760 while one is equal to one there's no way
01:38:12.719 we can escape this while loop so this is
01:38:14.960 what's known as an infinite loop i'll
01:38:16.800 display a message
01:38:19.040 help
01:38:20.880 i'm stuck
01:38:22.560 in an
01:38:23.760 infinite loop
01:38:27.119 then when i run this
01:38:28.719 yeah we're stuck in an infinite loop and
01:38:30.239 we can't actually move on or do anything
01:38:32.639 so yeah that's basically a while loop
01:38:34.400 everybody while some condition that you
01:38:37.119 set remains true
01:38:39.199 you will continue to execute some code a
01:38:41.840 great use of a while loop is that you
01:38:43.520 can force a user to do something in
01:38:45.840 order to continue with the rest of the
01:38:47.360 code your assignment is to use a while
01:38:49.760 loop then post it in the comments
01:38:51.520 section down below and well yeah those
01:38:53.920 are while loops in c plus plus
01:38:58.719 all right everybody do while loops a do
01:39:02.000 while loop it does some block of code
01:39:04.400 first and then you repeat that block of
01:39:07.040 code if a condition is true here's an
01:39:10.080 example let's write a program that will
01:39:12.000 ask a user to enter in a positive number
01:39:14.560 first we'll use a while loop that i'll
01:39:16.400 demonstrate how a do-while loop would
01:39:18.719 actually be better for the situation we
01:39:20.719 have an integer number int
01:39:22.960 number
01:39:24.080 i'll write a while loop while
01:39:26.960 number
01:39:28.080 is less than zero
01:39:30.159 we will prompt the user to enter in a
01:39:32.719 positive number
01:39:35.199 enter a
01:39:36.800 positive number
01:39:40.000 okay
01:39:40.800 standard
01:39:42.000 input
01:39:43.600 number
01:39:44.880 outside of the while loop at the end of
01:39:46.639 our program let's display the number
01:39:49.600 standard
01:39:50.880 output
01:39:53.040 the number
01:39:54.800 is
01:39:57.040 number
01:39:58.000 so this isn't going to work normally
01:39:59.840 here's why let's run this
01:40:02.320 the number is zero so this is what's
01:40:04.080 going on we've declared our number but
01:40:06.239 have not assigned a value quite yet when
01:40:08.239 we reach the while loop we check the
01:40:10.480 condition if the condition is true we
01:40:13.280 execute this block of code since we've
01:40:15.440 declared an integer variable but have
01:40:17.360 not assigned it a value it's defaulting
01:40:19.520 to just zero zero is not less than 0 so
01:40:23.280 this condition is false that means we
01:40:25.600 skip the while loop and continue on
01:40:27.679 another way in which we could write this
01:40:29.520 but it's not the best solution is that
01:40:31.440 we could copy what's within this block
01:40:33.280 of code
01:40:34.800 then run it once if number is still less
01:40:37.679 than zero we would then execute this
01:40:39.920 block of code repeatedly let's try this
01:40:42.080 again
01:40:43.520 okay enter a positive number one two
01:40:45.679 three the number is one two three let's
01:40:48.239 type in a negative number negative one
01:40:50.880 enter a positive number negative one
01:40:52.960 enter a positive number negative one
01:40:55.760 so i can't actually continue until i
01:40:57.840 enter in a positive number you know this
01:41:00.159 does work but there's a much better way
01:41:02.239 of writing this because you know we're
01:41:03.920 repeating at least two lines of code
01:41:05.920 when we really don't need to we need to
01:41:08.000 run this block of code once and then
01:41:10.480 repeat it if this condition is true well
01:41:12.639 you know what would be great for that a
01:41:14.239 do while loop let's eliminate these two
01:41:16.560 lines of code to create a do while loop
01:41:18.719 we will move this condition to the end
01:41:21.760 while then our condition preceding the
01:41:24.880 left curly brace write do
01:41:27.360 do this code once and then check the
01:41:29.840 condition
01:41:30.800 make sure you have a semicolon at the
01:41:32.400 end
01:41:33.199 let's try it again
01:41:35.280 enter a positive number i'm just going
01:41:36.719 to type in a negative number negative
01:41:38.560 one nope negative one nope how about a
01:41:41.520 positive number one two three the number
01:41:43.920 is one two three so that's a do while
01:41:46.080 loop you do some block of code first
01:41:48.480 then you repeat it again if the
01:41:49.920 condition is true it's an optional way
01:41:52.080 to repeat some code one good use of a do
01:41:54.080 while loop that comes to mind maybe
01:41:55.679 we're playing a game we would like to
01:41:57.199 run the game once at the end of the game
01:41:59.520 a user can choose if they would like to
01:42:01.280 play again based on the user's input if
01:42:03.199 they would like to play again we can run
01:42:04.880 the game one more time repeatedly so
01:42:07.040 that's a do while loop everybody i'll
01:42:08.719 post this code in the comments section
01:42:10.400 down below and well yeah that's a do
01:42:12.560 while loop in c plus
01:42:17.119 alright guys in this video i'm going to
01:42:18.800 explain for loops a for loop is a loop
01:42:21.679 that will execute a block of code a
01:42:24.159 specified amount of times to create a
01:42:26.560 for loop we type four parentheses curly
01:42:29.920 braces within the for loop there are up
01:42:32.400 to three statements that we can add the
01:42:34.239 first is that we can create an index a
01:42:36.480 sort of counter
01:42:38.639 int
01:42:39.920 index i'll set the sequel to be
01:42:42.880 we'll start at one then finish the
01:42:44.960 statement with a semicolon now what a
01:42:47.199 lot of people do instead of saying index
01:42:49.760 they'll just shorten this to i
01:42:51.679 the second statement is a stopping
01:42:53.600 condition let's count up to three i'll
01:42:56.320 continue this as long as i
01:42:58.800 is less than or equal to three then
01:43:01.920 semicolon to finish that statement the
01:43:04.159 third statement is that we can increment
01:43:06.159 or decrement our counter our index i'll
01:43:09.040 increment my index by one by saying i
01:43:12.159 plus plus okay let's repeat something
01:43:14.400 three times
01:43:15.920 standard
01:43:17.520 output
01:43:19.520 how about happy new year
01:43:21.280 happy new
01:43:22.880 year
01:43:25.760 this code should be repeated three times
01:43:31.040 happy new year happy new year happy new
01:43:33.199 year i should probably add a new line
01:43:36.239 now let's try this five times
01:43:38.400 we'll begin i at one
01:43:40.960 we'll continue this as long as i is less
01:43:43.360 than or equal to five
01:43:45.679 okay
01:43:46.960 one two three four
01:43:49.840 five that's it this time let's count up
01:43:52.880 to 10
01:43:53.920 then display happy new year once we exit
01:43:56.159 out of the for loop
01:43:57.760 i'll move this line to outside of the
01:43:59.760 for loop
01:44:01.600 i'll set i to be 1. we'll continue this
01:44:04.239 as long as i is less than or equal to
01:44:06.719 10.
01:44:07.920 during each iteration of the for loop i
01:44:10.400 will display whatever i is
01:44:12.880 standard output i
01:44:15.520 then i'll add a new line
01:44:19.600 okay
01:44:22.560 here we go
01:44:25.199 we're starting at one
01:44:27.360 then we're counting up to ten
01:44:29.280 then we escape the for loop once we
01:44:31.360 escape the for loop then we print happy
01:44:33.840 new year when you increment or decrement
01:44:35.920 your counter you can skip iterations
01:44:38.239 let's increase i by 2 after each
01:44:40.400 iteration
01:44:41.520 i plus equals 2.
01:44:44.000 now we're counting up by twos
01:44:47.520 one three five seven nine happy new year
01:44:50.080 we can even set our index to be a
01:44:51.520 different number let's begin at zero
01:44:53.520 we're still counting up by twos
01:44:55.760 zero two four six eight happy new year
01:44:58.880 we could even increment i by three
01:45:02.719 zero three six nine happy new year or we
01:45:05.199 could decrement and go backwards
01:45:07.600 i minus minus
01:45:09.440 this time we will begin at ten then
01:45:11.760 continue as long as i is less than or
01:45:14.800 equal to zero
01:45:16.480 so this would be a countdown ten nine
01:45:18.880 eight seven six five four
01:45:21.119 three two one zero happy new year okay
01:45:24.159 let's decrement i by two after each
01:45:26.159 iteration i minus equals two
01:45:30.560 ten eight six four two zero happy new
01:45:33.119 year so yeah everybody that's a for loop
01:45:35.679 there's a lot of overlap where you could
01:45:37.360 use either a while loop or a for loop
01:45:39.840 for loops tend to be better in
01:45:41.119 situations where you only need to repeat
01:45:43.280 code a certain amount of times your
01:45:45.199 assignment is to post a use of the for
01:45:47.440 loop in the comment section down below
01:45:49.199 and well yeah those are for loops in c
01:45:51.760 plus plus
01:45:55.360 hey everybody so in this video i'm going
01:45:57.280 to explain the break and the continue
01:45:59.119 keywords the break keyword will break
01:46:01.600 out of a loop another place where you
01:46:03.199 see this is a switch within a switch
01:46:05.199 statement continue we'll skip the
01:46:07.199 current iteration here's an example
01:46:09.040 let's create a for loop that will count
01:46:10.560 up to the number 20. i'll set i equal to
01:46:13.679 b1
01:46:14.639 i will continue this as long as i is
01:46:16.960 less than or equal to 20 then increment
01:46:20.080 i by 1
01:46:21.920 standard output i'll display whatever i
01:46:24.719 is then i'll add a new line
01:46:27.679 new line
01:46:29.679 then let's take a look so we have the
01:46:31.920 numbers 1 through 20. i would like to
01:46:34.880 skip the number 13 because 13 is
01:46:37.040 considered an unlucky number i know it's
01:46:38.960 a weird example what i'll do is use an
01:46:41.119 if statement within my for loop
01:46:43.760 if
01:46:44.639 i
01:46:45.440 is equal to 13
01:46:47.520 first we'll break then see what happens
01:46:50.320 if we break where i equals 13
01:46:54.880 then we have the numbers one through
01:46:56.960 twelve once we hit 13 we break out of
01:47:00.080 the loop we do not finish the rest of
01:47:02.159 the iterations if we replace break with
01:47:04.960 continue
01:47:07.280 this is instead what happens
01:47:10.719 we have the numbers 1
01:47:12.960 through 20 but the number 13 isn't there
01:47:16.320 so using the continue keyword we skip
01:47:19.040 the current iteration
01:47:20.960 so yeah that's the break and the
01:47:22.480 continue keywords these keywords are
01:47:24.719 available if you need them but where
01:47:26.480 you'll use them it really depends but
01:47:28.480 just so you know they exist and that is
01:47:30.639 the break and the continue keywords in c
01:47:33.520 plus
01:47:36.639 all right guys we are on nested loops a
01:47:39.520 nested loop is just a loop that's inside
01:47:42.159 of another loop it doesn't matter what
01:47:44.239 kind of loop you're working with it can
01:47:45.679 be a while loop or a forward loop or
01:47:47.840 whatever here's an example we'll create
01:47:50.159 a loop to count the numbers 1 through
01:47:52.239 10. we'll count to 10 three times
01:47:55.119 so let's create a basic loop for now
01:47:58.400 and i i'll set this equal to b
01:48:01.119 1
01:48:02.080 the condition will be i is less than or
01:48:04.800 equal to 10
01:48:06.239 then i will increment i by one
01:48:09.440 during each iteration
01:48:11.280 i will display
01:48:12.800 whatever i is
01:48:14.560 then i'll add a space
01:48:19.280 there
01:48:22.159 this loop will count up to 10
01:48:25.280 just like that so now i would like to
01:48:27.360 count up to 10 three times well i can
01:48:29.920 stick this loop in another loop
01:48:32.719 so let's create the outer loop
01:48:36.320 4
01:48:37.520 and i i'll set this equal to b1
01:48:40.560 i'll continue this as long as i is less
01:48:43.199 than or equal to 3
01:48:45.040 then increment i by one
01:48:47.760 so i'm going to take this loop
01:48:50.000 and stick it within the curly braces of
01:48:52.719 the outer for loop
01:48:54.400 however you don't want these loops to
01:48:56.400 have the same index
01:48:58.080 a common naming convention for the inner
01:49:00.159 loop is to use j as the counting index
01:49:04.159 j j
01:49:05.679 j
01:49:06.639 j
01:49:07.360 okay let's take a look
01:49:10.880 okay now we count up to 10 three times
01:49:15.119 but what i think i'm gonna do is that
01:49:16.800 every time we exit the for loop the
01:49:19.119 inner for loop i'll just print a new
01:49:20.880 line character
01:49:23.440 standard output
01:49:26.400 new line
01:49:29.199 yeah that's much better
01:49:31.040 so yeah a nested loop is just a loop
01:49:32.960 inside of another loop
01:49:34.560 just as a practice project let's create
01:49:36.639 a program that will print a rectangle
01:49:38.480 made out of symbols we'll let a user
01:49:40.719 specify how many rows and columns we'll
01:49:43.679 use our nested loop that we created
01:49:45.360 previously
01:49:46.719 so we have int rows
01:49:49.440 int
01:49:50.239 columns
01:49:51.599 then char
01:49:53.199 symbol
01:49:55.360 we're gonna ask for some user input
01:49:56.960 we'll need some prompts
01:49:58.719 standard output
01:50:00.960 how many rows
01:50:06.239 standard
01:50:07.440 input
01:50:09.599 rows
01:50:11.520 let's copy this paste it
01:50:14.080 change rows to columns
01:50:19.679 then
01:50:22.560 enter a symbol to use
01:50:28.239 standard input
01:50:30.800 symbol
01:50:32.560 we'll continue printing rows as long as
01:50:34.880 i is less than or equal to rows whatever
01:50:38.320 we typed in we don't want any more rows
01:50:40.239 than what the user wants the inner loop
01:50:42.719 is going to be in charge of the columns
01:50:44.880 j is less than or equal to columns
01:50:50.239 in place of printing j
01:50:52.480 let's print our symbol whatever the user
01:50:54.480 picked
01:50:55.360 and we do not need to separate these
01:50:57.040 with any spaces all right let's try this
01:51:01.679 how many rows what about three rows
01:51:05.440 then
01:51:06.400 six columns
01:51:07.679 enter a symbol to use what about the at
01:51:10.320 sign
01:51:11.679 and there's our rectangle there's three
01:51:14.239 rows
01:51:16.000 and six columns
01:51:18.880 let's try it one last time
01:51:21.760 how about four rows and five columns
01:51:24.560 i'll use a dollar sign
01:51:26.719 okay we have four rows one two three
01:51:29.440 four five columns one two three four
01:51:32.560 five
01:51:33.440 so yeah everybody that's a nested loop
01:51:35.760 it's a loop that's inside of another
01:51:37.599 loop when you'll use these it really
01:51:39.520 depends on the situation i thought this
01:51:41.520 would be a fun practice project if you
01:51:43.599 would like a copy of this code i'll post
01:51:45.280 this in the comments section down below
01:51:47.040 and well yeah those are nested loops in
01:51:49.440 c plus
01:51:53.280 hey this is bro from the future before
01:51:55.360 you begin this topic to work with random
01:51:57.440 numbers you may need to include this
01:51:59.520 header file c time hey everybody in this
01:52:02.639 video i'm going to show you how we can
01:52:04.080 generate some random numbers just so you
01:52:06.480 know these are pseudo-random numbers
01:52:09.119 they're not truly random but they're
01:52:11.280 close maybe if you need to roll a
01:52:13.280 six-sided dice for a game well then this
01:52:15.440 would work perfect to generate some
01:52:17.280 random numbers we'll need to initialize
01:52:19.440 the random number generator by typing s
01:52:22.560 rand add a set of parentheses semicolon
01:52:26.080 within the s rand function we'll need a
01:52:28.800 seed what programmers typically do is
01:52:31.199 that they'll use the current calendar
01:52:33.199 time as a seed
01:52:34.719 within the parentheses type time
01:52:37.040 parentheses again then pass in null
01:52:40.719 i'll store the first random number
01:52:42.320 within a variable
01:52:43.840 int num
01:52:45.599 equals to generate a random number we
01:52:48.239 invoke the rand function then i'll
01:52:50.400 display this
01:52:51.599 let's take a look to see what we have
01:52:53.440 standard output num
01:52:57.440 okay the random number that we have is
01:52:59.599 3231.
01:53:02.000 using the rand function this will
01:53:04.239 generate a random number between 0 and
01:53:07.119 32 767
01:53:09.760 but we don't necessarily need a number
01:53:11.360 that large i just need to roll a six
01:53:13.360 sided dice well what we're going to do
01:53:15.280 is follow this with modulus then the
01:53:18.400 range of numbers we would like if i'm
01:53:20.400 rolling a six sided dice i'll type
01:53:22.880 modulus 6. modulus gives you the
01:53:25.520 remainder of any division so take
01:53:27.520 whatever number we roll divide it by 6
01:53:30.639 take the remainder and that's our number
01:53:33.119 but there's one issue with this
01:53:35.360 we have 5
01:53:37.040 2
01:53:37.840 and 0.
01:53:38.960 technically the range of numbers is
01:53:40.880 currently zero through five if we need
01:53:43.360 one through six
01:53:44.639 what we can do is add one
01:53:48.400 plus one
01:53:49.840 this should give us a random number
01:53:51.280 between one and six
01:53:55.599 there it is six so i tend to play a lot
01:53:58.239 of dungeons and dragons there's
01:54:00.239 polyhedral dice one die that we commonly
01:54:02.960 roll is a 20-sided dice so if i would
01:54:05.599 need a random number between 1 and 20 i
01:54:08.400 would say rand function modulus 20.
01:54:11.599 my random number
01:54:13.199 is 1. wow that's surprisingly low
01:54:16.639 then i have a 14. maybe you need a
01:54:18.800 random number between 1 and 100 rand
01:54:21.360 function modulus 100
01:54:24.719 my random number between 1 and 100 is
01:54:27.280 67. now i need to roll three six-sided
01:54:30.320 dice
01:54:31.599 i'm going to create three variables
01:54:34.480 let's name this num1
01:54:37.040 rand function modulus 6 plus 1.
01:54:40.880 then let's copy this paste it twice we
01:54:43.520 have num1 num2 num3
01:54:47.119 let's display num1 i'll add a new line
01:54:52.960 then do this two more times for num two
01:54:56.159 and num three
01:54:57.599 so our three dice that we're rolling are
01:55:01.280 five two two
01:55:03.520 then again 3 1 4.
01:55:06.719 yeah everybody that's how to generate
01:55:08.639 some pseudo random numbers they're not
01:55:11.040 truly random but they're close if you
01:55:13.440 have a simple game you're working on
01:55:15.040 this would work perfect if you would
01:55:16.880 like a copy of this code i'll post this
01:55:18.719 in the comments section down below and
01:55:20.560 well yeah that's how to generate some
01:55:22.320 random numbers in c plus plus
01:55:26.880 hey everybody in this topic we're going
01:55:28.639 to create a random event generator using
01:55:31.599 random numbers and a switch this might
01:55:33.760 be useful maybe if you're writing a game
01:55:36.000 you need some random event to occur like
01:55:38.239 random monster show up or the weather
01:55:40.400 changes anything like that we'll be
01:55:42.560 working with random numbers you may need
01:55:44.719 to include this header file
01:55:46.719 include
01:55:47.840 c time
01:55:49.199 because we need access to the time
01:55:50.800 function to work with random numbers
01:55:52.800 we'll need to generate a seed
01:55:55.360 srand function pass in time
01:55:58.239 pass in zero
01:56:00.639 this function will use the current time
01:56:02.480 as a seed to generate random numbers
01:56:05.520 we'll create a local variable to store
01:56:07.679 our random number int
01:56:10.000 rand num
01:56:11.840 equals
01:56:13.520 use the rand function
01:56:15.920 modulus
01:56:17.520 then what's the range of numbers you
01:56:19.040 would like i would like the numbers one
01:56:21.280 through five
01:56:22.880 but this will give us zero through four
01:56:24.639 so i'm going to add one to the end
01:56:28.480 my integer randomnum will be a random
01:56:30.639 number between 1 and 5.
01:56:33.360 i'm going to create a switch to examine
01:56:35.520 this random number against many matching
01:56:37.840 cases
01:56:39.360 so we have case
01:56:40.840 1 through five
01:56:46.320 if the random number is one what would
01:56:48.639 you like to do exactly
01:56:50.480 so in this program i think we're going
01:56:52.320 to give away prizes like it's a random
01:56:54.400 prize generator depending on the random
01:56:56.560 number we'll give a participant a random
01:56:58.880 prize
01:57:00.480 standard output
01:57:02.639 you win
01:57:04.480 how about a bumper sticker a bumper
01:57:07.520 sticker
01:57:09.440 that will be the lowest tier prize
01:57:12.800 then we should probably add a break to
01:57:14.480 break out of the switch
01:57:17.280 okay let's think of some others
01:57:24.480 i should probably break after these
01:57:34.159 prize 2 will be a t-shirt
01:57:39.760 prize three how about a free lunch
01:57:44.400 prize for
01:57:46.320 maybe a gift card
01:57:49.599 case five
01:57:51.520 concert tickets that sounds good
01:57:54.480 so when i run this program we'll
01:57:56.159 generate a random number between one and
01:57:58.400 five depending on what that number is
01:58:00.960 we'll execute the code found within one
01:58:02.639 of these cases
01:58:06.639 let's see what i won i want a free lunch
01:58:09.920 if i try this again there's a good
01:58:11.679 chance it'll be a different prize
01:58:13.679 this time i want a bumper sticker
01:58:17.679 i want a bumper sticker again come on i
01:58:19.520 want those concert tickets
01:58:21.440 i'll take a gift card that's not bad
01:58:24.000 now if you don't add these break
01:58:25.119 statements
01:58:26.639 you'll just fall through the switch
01:58:33.440 you want a gift card you want concert
01:58:35.119 tickets
01:58:36.800 so if you only want somebody to win one
01:58:38.560 prize you'll want to exit out of the
01:58:40.159 switch by including this break statement
01:58:42.320 so yeah everybody i thought that might
01:58:43.760 be an interesting program you can
01:58:45.679 generate some random event maybe it's
01:58:47.920 for a game or something i thought maybe
01:58:49.760 a random prize giveaway would kind of be
01:58:51.440 interesting this program is more or less
01:58:53.280 for practice your assignment is to write
01:58:55.199 a switch with some random events then
01:58:57.679 post it in the comment section down
01:58:59.119 below and well yeah that's a random
01:59:01.679 event generator using c plus plus
01:59:06.960 all right welcome back everybody in this
01:59:09.360 video we're going to create a simple
01:59:11.440 number guessing game let's declare our
01:59:13.199 variables int num our number will be
01:59:16.400 randomly generated
01:59:18.239 and guess
01:59:19.760 this variable will hold the current
01:59:21.599 player guess
01:59:23.440 and tries how many tries is it going to
01:59:26.159 take for the user to guess the correct
01:59:28.239 number we'll be using the s rand
01:59:30.000 function to generate some random numbers
01:59:33.199 pass in time
01:59:34.800 pass and null
01:59:36.400 we will assign our variable num
01:59:39.040 a random number between 1 and 100
01:59:41.840 rand
01:59:42.840 function modulus 100
01:59:47.760 then add 1.
01:59:50.080 this function will give us a random
01:59:51.360 number between 1 and 100 start with the
01:59:53.520 num
01:59:54.480 just for some decorations i'm going to
01:59:56.560 create a title for this game
02:00:01.199 number guessing game
02:00:06.480 then add a new line
02:00:09.280 i'll place all of this code within a do
02:00:11.280 while loop
02:00:12.960 do
02:00:14.639 while
02:00:16.560 our guess does not equal num we will
02:00:20.320 have the user type in another guess
02:00:22.880 we'll create a prompt
02:00:24.840 standard output
02:00:27.920 enter a guess
02:00:30.320 between
02:00:33.199 1
02:00:34.080 through 100
02:00:40.320 standard input
02:00:43.119 guess
02:00:44.400 once the user types in a guess we will
02:00:46.560 increment our tries variable by one to
02:00:49.360 keep track of the score
02:00:52.800 now we'll have to examine the guess
02:00:54.560 versus the number
02:00:58.239 if
02:01:00.719 guess
02:01:01.679 is greater than num
02:01:04.800 let's display
02:01:09.199 too
02:01:09.920 high
02:01:11.440 i'll add a new line
02:01:15.119 else if
02:01:19.280 guess is
02:01:20.800 less than num
02:01:23.599 then we'll display
02:01:27.840 too
02:01:28.880 low
02:01:30.880 else
02:01:32.719 if the guess is not above the number and
02:01:34.880 the guess is not below the number the
02:01:36.960 guess must be equal to the number
02:01:40.560 standard
02:01:41.760 output
02:01:45.280 correct
02:01:47.520 we'll display the number of tries
02:01:49.520 number of tries
02:01:53.440 we'll display our tries variable
02:01:57.199 i'll add a new line
02:02:02.080 and i'll just add a line of text for
02:02:04.000 decoration at the bottom once we exit
02:02:06.000 the game
02:02:10.719 that should be everything let's run this
02:02:13.760 number guessing game i'll guess
02:02:15.360 something right in the middle 50. too
02:02:18.320 low
02:02:19.199 okay so the number is between 50 and
02:02:20.880 100.
02:02:22.239 i'll guess right in the middle of that
02:02:23.599 range 75
02:02:25.760 too high
02:02:26.960 something between 50 and 75
02:02:29.440 perhaps
02:02:30.840 62. that's still too high
02:02:33.679 56
02:02:35.440 too high
02:02:36.719 53
02:02:38.080 too low
02:02:40.000 54.
02:02:42.080 55.
02:02:43.599 all right the correct guess was 55 it
02:02:46.320 took me seven tries
02:02:48.080 i don't really think that's too good but
02:02:50.080 it works
02:02:51.040 okay everybody that is a simple number
02:02:53.679 guessing game involving the use of do
02:02:55.920 while loops and generating random
02:02:57.679 numbers
02:02:58.639 if you would like a copy of this code
02:03:00.159 i'll post this in the comments section
02:03:01.679 down below if you're enjoying this
02:03:03.440 series please let me know by smashing
02:03:05.280 that like button leave a random comment
02:03:06.960 down below and subscribe if you'd like
02:03:08.719 to become a fellow bro
02:03:12.560 well well well everybody we have a
02:03:15.040 pretty important lesson today today
02:03:16.880 we're going to talk about functions a
02:03:18.639 function is a block of reusable code if
02:03:21.920 you ever think that you're going to use
02:03:23.360 some section of code more than once you
02:03:25.199 might as well stick it within a function
02:03:26.800 here's an example i'll create a function
02:03:28.719 to sing happy birthday currently our
02:03:30.719 program is within the main function to
02:03:33.199 begin the program we call the main
02:03:35.119 function before the main function we can
02:03:37.440 create a new function for the time being
02:03:39.679 we're going to type
02:03:41.199 void
02:03:42.719 then a unique function name the function
02:03:45.040 name should be descriptive of what it
02:03:46.639 does if i'm going to sing happy birthday
02:03:49.040 let's name this function
02:03:50.639 the happy birthday function
02:03:53.520 then add a set of parentheses then a set
02:03:55.360 of curly braces
02:03:56.560 you can see that this is almost
02:03:58.079 identical to our main function except
02:04:00.159 with the main function we have a return
02:04:01.760 type and return zero what would we like
02:04:04.159 to do when we invoke this function let's
02:04:06.159 sing some of the lyrics to happy
02:04:08.840 birthday standard output
02:04:12.239 happy
02:04:14.239 birthday to you
02:04:16.960 i'll add a new line
02:04:18.960 i'll repeat this a couple times
02:04:22.719 happy birthday dear you
02:04:25.520 happy birthday to you
02:04:27.440 to invoke this function all we have to
02:04:29.040 do is within the main function type the
02:04:31.679 function name followed by a set of
02:04:33.920 parentheses
02:04:35.280 this will call or otherwise known as
02:04:38.079 invoke the function i like to think of
02:04:39.920 the parentheses as a pair of telephones
02:04:41.760 that are talking to each other to use a
02:04:43.920 function you have to call the function
02:04:45.840 call it up on the phone so when i run
02:04:47.599 this code
02:04:48.960 we have the lyrics to happy birthday
02:04:51.679 this function is reusable i can call
02:04:53.920 this function as many times as i want
02:04:56.079 i'll call this function two additional
02:04:57.679 times just to separate these lyrics i'm
02:05:00.000 going to add an additional new line
02:05:01.599 character
02:05:03.679 okay we now should have three verses of
02:05:06.400 happy birthday one
02:05:08.800 two
02:05:09.840 three that's because i called the
02:05:11.520 function well three times
02:05:14.239 a function is just a block of reusable
02:05:16.560 code now what a lot of people do is that
02:05:18.880 they'll declare and define their
02:05:20.719 functions after the main function
02:05:22.639 because it's more readable to many
02:05:24.159 people but there's one issue with this
02:05:27.360 happy birthday was not declared in this
02:05:29.280 scope
02:05:31.040 our programs are read from the top down
02:05:33.440 since we're invoking the happy birthday
02:05:35.199 function before we even know what it is
02:05:37.199 while the compiler doesn't recognize it
02:05:39.199 a solution to this is that before the
02:05:41.360 main function
02:05:42.560 you can declare functions but define
02:05:44.560 them later let's declare happy birthday
02:05:47.119 before the main function
02:05:50.480 then make sure you add a void or a
02:05:52.639 return type
02:05:54.560 so void happy birthday
02:05:56.880 we can now use this function even though
02:05:58.719 it's after the main function
02:06:02.159 a lot of people like to define their
02:06:03.679 functions after the main function it's
02:06:05.760 another way in which you can write it
02:06:07.360 just be sure to at least declare them
02:06:09.119 before the main function now check this
02:06:10.960 out what if we have a variable
02:06:13.760 standard
02:06:15.280 string name
02:06:17.199 assign this whatever your name is
02:06:20.400 i'm going to use this name that's
02:06:22.719 declared in the main function
02:06:24.560 and use it within the happy birthday
02:06:26.000 function
02:06:28.000 let's replace u with the user's name
02:06:31.520 happy birthday to name
02:06:34.239 i'll add a new line
02:06:38.159 then i'll copy this
02:06:40.800 paste it
02:06:43.520 and let's change this line as well
02:06:54.079 all right now when i run this
02:06:56.880 here's the issue
02:07:00.239 name was not declared in the scope
02:07:02.800 think of each function as a house the
02:07:05.280 main function is your house functions
02:07:07.520 outside of the main function would be
02:07:09.360 your neighbors their house functions
02:07:11.679 can't see what's going on inside of
02:07:13.440 other functions you can't see what's
02:07:15.280 going on inside of your neighbor's house
02:07:17.119 you're only familiar with what's going
02:07:18.880 on inside of your own house in order for
02:07:21.040 the happy birthday function to use the
02:07:22.880 main function's name variable it needs
02:07:25.119 to be made aware of it to do that when
02:07:27.360 you invoke a neighboring function you
02:07:29.599 can pass that variable or some other
02:07:31.679 value as an argument so within the
02:07:33.920 parentheses when you invoke that
02:07:35.440 function
02:07:36.480 place your values or variables i would
02:07:38.880 like to make my happy birthday function
02:07:40.880 aware of this name variable within the
02:07:43.040 main function
02:07:44.320 when you send some data over to a
02:07:46.000 function that data is also known as an
02:07:48.560 argument however the receiving function
02:07:51.280 needs a matching set of what are called
02:07:53.280 parameters if this function is going to
02:07:55.599 receive this data this name you need a
02:07:58.639 matching parameter to set up a parameter
02:08:01.119 you first list the data type we will
02:08:03.599 receive a standard
02:08:06.159 string
02:08:07.440 then we can list a parameter name
02:08:09.840 let's say name now this happy birthday
02:08:12.400 function can use this name variable
02:08:14.400 within the main function if you have a
02:08:16.480 function declaration at the top of your
02:08:18.159 program you'll have to add that
02:08:19.599 parameter there as well
02:08:21.440 so happy birthday standard string
02:08:25.040 and we can run this happy birthday to
02:08:27.840 whatever your name is functions aren't
02:08:30.079 aware of what's going on inside of other
02:08:31.840 functions but you can make them aware of
02:08:34.079 any local variables or values by passing
02:08:36.800 them as an argument but you'll need a
02:08:38.960 matching set of parameters the name or
02:08:41.599 otherwise unique identifier of your
02:08:43.679 parameter doesn't necessarily need to
02:08:45.760 have the same name so to say you can
02:08:48.560 name it something else instead of naming
02:08:50.400 our parameter name let's say
02:08:53.159 birthday boy or birthday girl
02:08:57.840 happy birthday to birthday boy
02:09:01.840 and that should work the same so you can
02:09:04.079 rename parameters but let's revert that
02:09:06.400 back
02:09:07.280 now let's pass an age int age
02:09:10.639 equals make up some age i would like to
02:09:13.440 send my age over to the happy birthday
02:09:15.679 function so i will pass that as an
02:09:18.079 additional argument separate each
02:09:20.079 argument with a comma
02:09:21.760 we'll send our name as well as age now
02:09:24.079 we need a matching set of parameters
02:09:26.000 right now the happy birthday function is
02:09:28.000 only equipped to receive a name so
02:09:31.440 we list the data type and age
02:09:34.400 and if you have a function declaration
02:09:36.400 change that there as well
02:09:39.280 then i'll add one more line
02:09:45.679 you
02:09:46.719 are
02:09:48.159 age
02:09:51.840 years old
02:09:54.480 then this should work
02:09:55.920 okay happy birthday to whatever your
02:09:58.480 name is you are whatever your age is
02:10:01.520 years old so that's a function everybody
02:10:04.079 it's a block of reusable code if you
02:10:06.400 think you're going to perform some code
02:10:07.920 more than once you can stick it within a
02:10:09.840 function whenever you need it you just
02:10:11.520 simply call it if you need to make your
02:10:13.440 function aware of any variables you can
02:10:15.679 send them as arguments to that function
02:10:17.760 but you'll need a matching set of
02:10:19.119 parameters in the function definition
02:10:21.520 and the declaration so yeah those are
02:10:23.840 functions everybody your assignment is
02:10:25.920 to create a unique function and post it
02:10:28.320 in the comments section and well yeah
02:10:30.480 those are functions in c plus plus
02:10:35.840 all right everybody we are on the return
02:10:38.320 keyword the return keyword will return a
02:10:40.960 value back to the spot where you called
02:10:43.520 to the encompassing function the return
02:10:45.599 keyword is commonly found at the end of
02:10:47.840 a function much like the main function
02:10:50.000 when we invoke a function we can return
02:10:52.000 some value back
02:10:53.440 here's an example
02:10:55.280 i'll create a function that will
02:10:56.800 calculate the area of a square but we'll
02:10:59.199 need to pass in a length the length of
02:11:00.960 one side
02:11:02.239 this will be a double
02:11:04.000 length assign some value 5.0 is good
02:11:07.920 then we'll need to declare and define a
02:11:09.599 function
02:11:10.639 at the top of my program i'll add a
02:11:12.880 function declaration
02:11:14.639 for the time being we'll write void but
02:11:16.800 that will change soon void i'll name
02:11:19.360 this function square we will square a
02:11:21.760 length list any parameters we will
02:11:23.920 accept a double value
02:11:26.400 which we will name length
02:11:29.040 then i'll need a function definition
02:11:31.280 i'll add that after the main function
02:11:33.760 void square
02:11:36.400 i'm going to create a temporary variable
02:11:38.960 named result it will be of the double
02:11:41.599 data type we will take
02:11:43.840 length times length
02:11:45.840 to calculate the area
02:11:48.560 then i will use that return keyword
02:11:50.560 return what are we returning we're
02:11:52.960 returning our result if we're returning
02:11:55.360 a value we need to change this keyword
02:11:57.679 void to match the data type of what
02:12:00.000 we're returning we're returning a double
02:12:02.880 so i will change void to double and then
02:12:05.679 make sure you change that within the
02:12:07.360 function declaration as well
02:12:09.440 double square you could do this in one
02:12:11.920 line of code you don't necessarily need
02:12:13.920 to we could simply just return
02:12:16.880 length times length that is also valid
02:12:19.760 that's probably how i would write it we
02:12:21.599 now have this function that will
02:12:23.280 calculate the area of a square once we
02:12:25.679 pass in a length i'm going to create a
02:12:27.920 new variable called
02:12:29.599 area
02:12:30.639 it will be of the double data type and i
02:12:32.719 will set the sequel to
02:12:34.560 then let's invoke the square function
02:12:37.440 pass in our length variable as an
02:12:39.679 argument
02:12:41.119 at this point of the program area should
02:12:42.960 be assigned a value let's display it
02:12:45.840 standard
02:12:46.840 output
02:12:48.560 area
02:12:50.000 i'll add my area variable
02:12:52.880 then add centimeters squared then new
02:12:55.840 line
02:12:56.800 the area of our square is 25 centimeters
02:13:00.079 squared
02:13:01.199 and i could change this to a different
02:13:02.480 number like six
02:13:04.800 the area is now 36 centimeters squared
02:13:07.760 let's create another function this
02:13:09.520 function will find the volume of a cube
02:13:11.760 if we know the length of a side we'll
02:13:13.840 return a value of the double data type
02:13:16.159 but i will name this cube
02:13:18.000 we will still accept the length of the
02:13:20.079 double data type
02:13:23.440 let's copy this paste it
02:13:25.920 change square to cube
02:13:28.840 return length times length times length
02:13:35.679 double
02:13:36.800 volume
02:13:37.920 equals we'll invoke our cube function
02:13:41.119 pass in our
02:13:42.840 length then i will display whatever the
02:13:45.760 volume is
02:13:49.599 volume
02:13:51.920 my volume variable centimeters cubed
02:13:57.520 if the side of a square is 6 centimeters
02:14:00.239 the area would be 36
02:14:02.560 if it was a cube the volume would be 216
02:14:05.920 centimeters
02:14:07.119 if you need to return a value back to
02:14:09.199 the spot in which you invoked a function
02:14:11.599 be sure to list the data type of what
02:14:13.840 you're returning
02:14:15.360 let's try another example involving
02:14:17.119 strings
02:14:18.320 i'll create a function that will add a
02:14:20.400 user's first name their last name and
02:14:23.119 create a new string called full name
02:14:25.679 let's declare our variables
02:14:27.599 standard string
02:14:29.920 first
02:14:31.520 name
02:14:32.480 equals add your first name
02:14:35.520 standard string
02:14:37.840 last name
02:14:39.119 equals
02:14:40.719 add your last name then i'll create a
02:14:43.040 function to concatenate two strings
02:14:45.119 together we're returning a string i will
02:14:48.079 list the data type as standard string
02:14:51.520 i'll name this function
02:14:53.679 concat
02:14:54.960 strings
02:14:58.000 we will have two arguments two standard
02:15:00.560 strings
02:15:01.840 standard string
02:15:03.679 i'll name the first string
02:15:05.360 string one
02:15:07.760 standard string
02:15:09.920 string
02:15:10.960 a misspelt string string two so we have
02:15:13.920 our function declaration now we just
02:15:16.400 need to define it
02:15:18.159 i'm going to return
02:15:20.800 string one
02:15:22.400 plus i'll add a space between the first
02:15:24.400 name and the last name
02:15:26.800 plus string two
02:15:29.520 i'll create a third variable
02:15:31.679 standard string
02:15:33.840 full name
02:15:35.119 equals
02:15:36.400 i will invoke my concat strings function
02:15:40.159 then i need to pass in two strings as
02:15:42.480 arguments
02:15:43.840 i'll pass in my first name
02:15:46.560 and my last name
02:15:48.320 then let's display the full name
02:15:50.560 standard output
02:15:54.719 hello
02:15:57.760 the user's full name
02:16:02.079 hello bro code or whatever your first
02:16:04.560 and last name is so yeah everybody that
02:16:07.280 is the return keyword wherever you
02:16:09.440 invoke a function you can return a value
02:16:12.400 back to that spot in which you invoked
02:16:14.320 that function if you're returning a
02:16:16.239 value just be sure that you change the
02:16:18.880 return type of that function to match
02:16:21.440 the data type of the value being
02:16:23.040 returned
02:16:24.079 in this example i returned a string a
02:16:26.320 standard string so the return type of
02:16:28.800 this function would be a standard string
02:16:31.440 so that's the return keyword everybody
02:16:33.280 your assignment is in the comment
02:16:34.879 section to post a function that returns
02:16:37.840 some value so yeah that is the return
02:16:40.080 keyword in c plus plus
02:16:44.478 hey guys in this topic i'm going to
02:16:46.558 explain overloaded functions in c plus
02:16:49.439 plus and actually with many other
02:16:51.040 programming languages you can have
02:16:53.040 different versions of the same function
02:16:55.200 here's what i mean i have a function to
02:16:57.599 bake a pizza because well i like pizza
02:17:00.478 bake
02:17:01.519 pizza
02:17:02.799 this function will have no parameters
02:17:05.679 all i'm gonna do within this function is
02:17:07.840 display the words here is your pizza
02:17:13.280 then i'll add a new line
02:17:15.760 uh then i should probably add a
02:17:16.959 declaration at the top
02:17:20.160 void baked pizza then to invoke this
02:17:22.558 function i would type the function name
02:17:26.879 here is your pizza
02:17:28.879 this time i would like to bake a pizza
02:17:30.799 that has toppings
02:17:32.879 right now we just have a plain pizza
02:17:35.040 with no toppings and that's kind of lame
02:17:37.280 i'm going to create an additional
02:17:38.879 version of this baked pizza method but
02:17:41.040 it's going to have different parameters
02:17:44.160 void
02:17:45.120 bake
02:17:46.240 pizza
02:17:48.160 we will accept a string
02:17:50.398 standard
02:17:51.840 string i'll name this string
02:17:54.558 topping one we'll accept one topping as
02:17:57.280 an argument
02:17:59.920 standard output here is your
02:18:02.959 i'll add my topping here
02:18:05.280 topping one
02:18:08.080 pizza
02:18:09.280 then be sure to add your function
02:18:10.879 declaration to
02:18:13.200 bake pizza
02:18:14.879 then this time we are accepting a string
02:18:17.040 it is valid for functions to share the
02:18:19.280 same name but you need a different set
02:18:21.439 of parameters a function's name plus its
02:18:24.558 parameters is known as a function
02:18:27.439 signature i can bake a pizza that has no
02:18:30.160 toppings here is your pizza or i could
02:18:33.120 pass in a topping like
02:18:35.679 pepperoni
02:18:38.318 here is your pepperoni pizza let's
02:18:40.718 create an additional function that
02:18:42.478 accepts two toppings
02:18:45.920 so we have topping one topping two
02:18:48.718 here is your
02:18:50.478 topping one
02:18:53.040 and
02:18:55.920 topping two
02:18:59.120 pizza
02:19:00.879 then add your function declaration
02:19:04.879 topping one topping two
02:19:07.200 now i can bake a pizza that has two
02:19:09.280 toppings
02:19:10.478 i would like pepperoni and mushrooms
02:19:16.959 here is your pepperoni and mushroom
02:19:19.359 pizza so yeah everybody those are
02:19:21.679 overloaded functions functions can share
02:19:24.240 the same name but you need a different
02:19:26.638 set of parameters a function's name plus
02:19:29.920 its parameters is known as a function's
02:19:33.040 signature and each function signature
02:19:35.359 needs to be unique kind of like an id so
02:19:38.080 yeah those are overloaded functions if
02:19:40.318 you would like a copy of this code i'll
02:19:42.000 post this in the comments section down
02:19:43.519 below and well yeah those are overloaded
02:19:46.160 functions in c plus plus
02:19:51.120 okay everybody we gotta discuss variable
02:19:53.439 scope i'll explain local variables and
02:19:56.319 global variables local variables are
02:19:58.640 declared inside of a function or block
02:20:00.880 of curly braces such as within the main
02:20:03.359 function or inside of another function
02:20:05.520 global variables are declared outside of
02:20:07.920 all functions you tend to see them at
02:20:09.680 the top of your program there's some
02:20:11.200 major differences between the two let's
02:20:13.120 begin with local variables suppose i
02:20:15.760 have some number int my num my num
02:20:18.880 equals one
02:20:20.080 if i need to display my num i can use
02:20:22.319 standard output
02:20:24.080 my num
02:20:25.439 and of course this will display my num
02:20:28.080 which is one now what if i have a
02:20:29.600 function to display my num
02:20:31.840 void
02:20:32.720 print
02:20:33.680 num
02:20:35.760 let's move this line of code to our
02:20:37.520 print num function
02:20:41.280 i'll need to add a function declaration
02:20:43.120 to the top of my program
02:20:46.960 then we will invoke this function print
02:20:49.280 num
02:20:51.120 okay this isn't going to work and here's
02:20:52.800 why
02:20:54.240 mynum was not declared in this scope
02:20:56.880 functions can't see inside of other
02:20:58.720 functions my function printnum has no
02:21:01.920 idea what this mynum variable is
02:21:04.399 mynum is a local variable to the main
02:21:06.720 function that's why we pass arguments to
02:21:08.880 functions
02:21:10.560 we'll make the function aware of this
02:21:12.160 value but you'll need a matching set of
02:21:14.000 parameters
02:21:15.359 int
02:21:16.240 my num
02:21:18.319 then add that to the function
02:21:19.359 declaration int my num
02:21:22.800 and this would work that displays the
02:21:24.479 number one but let's get rid of these
02:21:26.080 parameters
02:21:28.960 it is legal to reuse the same variable
02:21:31.280 name as long as it's within a different
02:21:33.040 scope within the print num function i'll
02:21:35.680 also have a mynum variable that has the
02:21:37.840 same name but i'll give this a different
02:21:39.760 value
02:21:42.399 when printing my num it prints two we
02:21:45.439 have two versions of the same variable
02:21:47.439 and this is fine because they're within
02:21:49.280 different scopes
02:21:50.640 now a global variable is declared
02:21:52.800 outside of all functions you see these
02:21:55.040 at the top of your program i will
02:21:56.880 declare int
02:21:58.479 my num
02:22:00.160 equals three
02:22:02.160 i'm going to delete these two local
02:22:03.760 variables
02:22:05.359 if i was to invoke the print num
02:22:07.120 function and print my num
02:22:09.359 well then that number is 3.
02:22:12.479 this global variable is also available
02:22:14.560 within the main function
02:22:16.080 so i will print my num here as well
02:22:17.840 within the main function
02:22:21.120 so we have three and three it's best to
02:22:24.000 avoid global variables if you can
02:22:25.840 because it pollutes the global namespace
02:22:28.319 also variables declared within a
02:22:30.000 function are much more secure because
02:22:32.240 like i said functions can't see inside
02:22:34.080 of other functions if we had both local
02:22:36.800 and global variables
02:22:40.319 mynum within the main function will be 1
02:22:43.200 within the printnum function it will be
02:22:44.960 2.
02:22:46.080 if i was to display my num for both of
02:22:48.160 these i'm going to add a new line to
02:22:50.160 each of these
02:22:53.280 new line
02:22:55.600 and new line
02:22:59.359 a function will use any local variables
02:23:01.680 first before resorting to any global
02:23:03.920 variables that's why our print num
02:23:06.080 function prints two and the main
02:23:07.840 function prints one if you'd rather use
02:23:10.160 the global version you can use the scope
02:23:12.720 resolution operator so precede your
02:23:15.359 variable name with two colons that is
02:23:18.399 the scope resolution operator
02:23:20.800 i'll do that here as well
02:23:22.640 in place of using the local version of
02:23:24.720 mynum we will use the global version
02:23:29.200 and we will print three we're using the
02:23:31.680 global version of my num instead of the
02:23:33.920 local version
02:23:35.280 so yeah that's variable scope local
02:23:37.520 variables are declared inside of a
02:23:39.200 function or anytime you see a set of
02:23:41.200 curly braces a variable declared inside
02:23:43.840 a set of curly braces is hidden to the
02:23:46.080 outside world a global variable is
02:23:48.479 declared outside of all functions and is
02:23:51.200 accessible to all functions within the
02:23:53.120 program like i said you should try and
02:23:55.040 avoid using global variables if you can
02:23:57.120 because it pollutes the global namespace
02:23:59.200 and these variables are less secure so
02:24:01.359 yeah that's variable scope hey if you're
02:24:03.439 enjoying this series let me know by
02:24:05.280 smashing that like button leave a random
02:24:07.200 comment down below and subscribe if
02:24:08.960 you'd like to become a fellow bro
02:24:13.200 hey guys in this topic we're going to
02:24:14.960 create a banking program for practice
02:24:17.680 we'll be able to deposit money withdraw
02:24:19.680 money and show a balance this is more or
02:24:22.000 less just for practice let's begin by
02:24:24.000 creating our functions
02:24:26.240 void
02:24:27.600 show
02:24:28.640 balance
02:24:30.399 there will be one parameter double
02:24:33.200 balance whatever our bank account
02:24:35.359 balance is we'll show it
02:24:38.640 the return type is double
02:24:40.960 deposit
02:24:42.800 no parameters
02:24:45.359 double
02:24:46.800 withdraw
02:24:48.080 and there will be one parameter double
02:24:50.880 balance
02:24:53.200 let's fill in a few things within the
02:24:54.560 main function
02:24:56.399 double
02:24:57.439 balance and i will go ahead and set this
02:24:59.359 to zero
02:25:00.960 as well as int
02:25:02.640 choice i will set that to zero as well
02:25:05.280 we'll use a switch to determine if the
02:25:07.280 user wants to show their balance make a
02:25:10.319 deposit a withdrawal or exit
02:25:13.600 let's display some output some prompts
02:25:16.880 standard output
02:25:18.880 enter your
02:25:22.840 choice and i'm just gonna add some text
02:25:25.280 decorations because i think that'll be
02:25:27.200 cool
02:25:28.479 maybe a bunch of asterisks
02:25:31.520 and one more
02:25:35.280 okay
02:25:36.240 we have option one one
02:25:39.840 show
02:25:40.880 balance
02:25:45.840 two
02:25:46.640 will be deposit money
02:25:53.120 three is withdrawal money
02:26:00.880 four will be exit
02:26:08.399 then we'll accept some user input
02:26:10.319 standard
02:26:11.600 input
02:26:12.960 choice
02:26:15.920 now we're going to create a switch
02:26:18.240 we're examining the user's choice
02:26:21.920 switch
02:26:24.479 we're examining our choice against many
02:26:26.960 matching cases
02:26:28.640 we have case one
02:26:30.960 case two
02:26:33.280 three
02:26:35.520 four
02:26:37.040 then a default case
02:26:40.640 okay case one the user wants to show
02:26:43.120 their balance we'll invoke the show
02:26:45.840 balance function
02:26:47.280 but we need to pass in our balance
02:26:52.640 balance
02:26:54.479 and then we are going to break
02:26:58.080 case 2 the user wants to deposit money
02:27:01.359 so we're going to take our balance
02:27:04.720 equals
02:27:05.840 balance
02:27:07.520 plus our deposit function
02:27:10.240 so deposit will return a double
02:27:13.200 right here
02:27:14.880 so we're going to add that to our
02:27:16.160 balance once we verify it actually we
02:27:18.560 can shorten this to balance plus equals
02:27:21.760 whatever value is returned with the
02:27:23.520 deposit function
02:27:25.520 then we are going to break
02:27:28.800 case three withdraw money
02:27:31.680 balance
02:27:32.880 minus equals
02:27:35.520 the withdraw function pass in our
02:27:37.920 balance
02:27:39.920 we're withdrawing money from our balance
02:27:41.840 once we verify it
02:27:44.640 then we're going to break
02:27:47.120 we'll exit with case 4 i'll display some
02:27:49.760 output standard output
02:27:53.280 thanks for visiting
02:27:58.800 then i'm going to break
02:28:01.280 okay default case
02:28:03.439 standard
02:28:04.800 output
02:28:07.359 invalid
02:28:09.120 choice
02:28:11.680 okay now we're going to place all of
02:28:13.439 this code within a do while loop
02:28:19.760 do all of this
02:28:21.920 while some condition is true
02:28:24.160 so let's take all this code cut it
02:28:27.920 put it within that do while loop
02:28:30.560 let me just format this a little bit
02:28:35.280 the condition will be while choice does
02:28:38.399 not equal four four is what we used to
02:28:41.359 exit
02:28:42.720 we'll need to add some function
02:28:44.080 definitions
02:28:46.479 but i'm going to fill these in later
02:28:50.960 we'll need to return something
02:28:53.040 so let's return zero for the time being
02:28:56.000 for two of these functions at least
02:28:57.920 return zero
02:28:59.600 okay let's run and compile this just to
02:29:01.359 test our do while loop
02:29:05.200 okay enter your choice
02:29:07.120 uh one show balance that doesn't show
02:29:09.600 our balance yet but it will deposit
02:29:11.840 money withdraw now we should be able to
02:29:14.160 exit by pressing four
02:29:16.640 thanks for visiting okay so we know that
02:29:18.800 the do while loop is working let's fill
02:29:21.040 in our functions let's begin with show
02:29:22.800 balance
02:29:24.399 now with the show balance function we're
02:29:26.319 receiving our balance as an argument
02:29:29.600 so i'm going to display standard output
02:29:34.560 your
02:29:37.120 balance
02:29:38.319 is
02:29:39.760 dollar sign or some other currency if
02:29:41.439 you choose
02:29:43.680 i'll display our balance
02:29:45.760 then add a new line
02:29:51.760 so let's say we have 123 dollars in our
02:29:55.680 account
02:29:58.640 i'm going to show my balance
02:30:01.600 123 dollars even but i would like to
02:30:04.240 display cents i'll need two decimal
02:30:06.560 places after the decimal
02:30:09.040 so there's one thing we can include
02:30:11.200 we'll include this header file
02:30:13.280 include
02:30:15.359 i o man ip there's a function in here to
02:30:19.040 set some precision for floating point
02:30:20.800 numbers
02:30:22.720 i'm going to make this change after the
02:30:24.800 dollar sign
02:30:27.840 standard
02:30:29.359 set
02:30:30.240 precision
02:30:32.160 pass in two for two decimal places
02:30:36.640 then add
02:30:38.640 standard
02:30:40.080 fixed
02:30:41.760 this will display our balance up to two
02:30:43.840 decimal places after the decimal point
02:30:47.040 so let's try that again
02:30:49.760 okay show balance 123 dollars and zero
02:30:53.439 cents
02:30:55.120 if i were to change this to 123.01
02:30:59.439 we should display two decimal places
02:31:03.359 yep 123 dollars and one cent
02:31:06.800 okay that is the show balance function
02:31:09.439 let's work on the deposit function
02:31:12.800 okay now we're within the deposit
02:31:14.560 function i'm going to create a local
02:31:16.640 variable named amount
02:31:18.960 set this equal to zero
02:31:21.439 we'll ask the user how much they would
02:31:22.960 like to deposit standard output
02:31:26.560 enter amount
02:31:28.399 to be
02:31:30.000 deposited
02:31:34.720 standard
02:31:36.080 input
02:31:37.760 r amount
02:31:40.080 so i'm going to set balance back to zero
02:31:43.200 then let's test it
02:31:45.680 show balance
02:31:47.040 one your balance is zero dollars and
02:31:49.280 zero cents i would like to make a
02:31:50.479 deposit
02:31:51.760 uh 420
02:31:54.080 69 cents
02:31:57.280 okay now i would like to show my balance
02:31:59.200 after we make a deposit
02:32:03.520 so within case two after making a
02:32:05.840 deposit let's show our balance pass in
02:32:08.560 the balance variable
02:32:10.560 now let's do so after withdrawal two
02:32:14.399 okay let's try that again
02:32:18.399 show balance zero dollars zero cents
02:32:20.800 make a deposit
02:32:22.560 420.6
02:32:25.920 your balance is zero dollars and zero
02:32:27.920 cents
02:32:29.280 so what we're going to do is return our
02:32:31.520 amount at the end of this function
02:32:33.280 return amount
02:32:36.840 420 dollars 69 cents
02:32:39.840 all right we have our balance
02:32:43.040 the user is able to enter in negative
02:32:44.960 money enter amount to be deposited
02:32:47.280 negative one thousand your balance is
02:32:49.680 now negative one thousand dollars we
02:32:52.319 need to prevent somebody from making a
02:32:54.240 negative deposit
02:32:56.399 so before we return our amount let's use
02:32:58.640 an if statement
02:33:02.080 if
02:33:03.280 amount
02:33:04.800 is greater than zero
02:33:07.200 then we will return the amount
02:33:14.160 else
02:33:16.080 standard output
02:33:19.200 that's not a valid amount
02:33:25.439 then let's return zero
02:33:28.000 okay let's try that again
02:33:31.040 deposit money negative one thousand
02:33:33.200 dollars
02:33:35.520 that's not a valid amount your balance
02:33:37.439 is zero dollars
02:33:39.359 i'm just going to add a new line
02:33:41.520 like right here
02:33:43.280 then let's make a legitimate deposit
02:33:45.200 deposit money i will deposit one
02:33:47.840 thousand dollars in one cent your
02:33:49.920 balance is one thousand dollars and one
02:33:52.080 cent
02:33:52.880 okay that is the deposit function that
02:33:55.040 is complete
02:33:57.040 then we have the withdraw function
02:33:59.280 we'll create a local variable named
02:34:01.359 amount of the double data type
02:34:03.920 we'll create a prompt standard output
02:34:07.680 enter amount to be withdrawn
02:34:14.399 standard input
02:34:16.960 amount
02:34:19.600 at the end of this program we will
02:34:21.120 return amount
02:34:23.600 okay let's test it
02:34:25.200 okay i need to deposit some money first
02:34:27.280 i will deposit one thousand dollars and
02:34:29.920 one cent
02:34:31.760 then let's withdraw money
02:34:33.760 i will withdraw
02:34:35.280 one hundred dollars and one cent
02:34:37.920 my new balance is nine hundred dollars
02:34:40.080 but we can overdraw our account still so
02:34:42.399 i'm going to withdraw a million dollars
02:34:45.520 and one cent
02:34:47.600 our balance shouldn't be negative so
02:34:49.280 let's prevent our user from overdrafting
02:34:51.600 their account
02:34:52.720 within our withdrawal function let's add
02:34:54.640 an if statement
02:34:56.399 if amount is greater than our balance
02:35:01.280 will display
02:35:04.479 insufficient
02:35:07.520 funds
02:35:12.800 then we will return zero
02:35:17.680 okay i'm going to withdraw
02:35:20.000 one million dollars
02:35:21.920 and one cent
02:35:24.319 insufficient funds your balance is zero
02:35:27.439 okay
02:35:28.240 now what if the user would like to
02:35:29.600 deposit negative money
02:35:31.439 withdraw money
02:35:33.200 negative one thousand
02:35:35.359 your balance is one thousand dollars
02:35:38.240 we'll need to make sure that the amount
02:35:39.680 is a legitimate amount i'll add an else
02:35:41.840 if statement
02:35:43.280 if amount
02:35:45.760 is less than zero
02:35:49.280 standard output
02:35:52.560 that's not a valid amount
02:35:59.680 now else
02:36:01.439 we will return the amount to be
02:36:03.600 withdrawn
02:36:07.680 then within the elsif statement we'll
02:36:09.120 need to return zero
02:36:11.680 there
02:36:13.920 okay let's withdraw money
02:36:15.760 enter amount to be withdrawn negative
02:36:17.600 one thousand dollars
02:36:19.439 that's not a valid amount that's good
02:36:21.520 let's withdraw again
02:36:24.000 i would like to withdraw 100
02:36:26.800 insufficient funds my balance is zero
02:36:29.439 let's deposit some money
02:36:31.359 99.99
02:36:33.439 our balance is
02:36:34.840 99.99 let's withdraw again
02:36:38.000 let's try and withdraw 100
02:36:39.920 nope we can't
02:36:41.920 let's withdraw again 99.99
02:36:45.280 your balance is zero that's good then
02:36:47.200 let's exit
02:36:50.319 press 4 to exit thanks for visiting okay
02:36:53.120 so these functions are done
02:36:56.160 there's just one more thing we should
02:36:57.600 add
02:37:00.160 if i type in some characters like the
02:37:02.000 word pizza well this will break our
02:37:04.240 program
02:37:05.439 we'll want to clear the input buffer so
02:37:08.080 after our choice let's add these two
02:37:10.000 lines
02:37:11.840 standard
02:37:13.840 input dot clear function
02:37:18.000 so i haven't talked about this function
02:37:19.520 this function will reset any error flags
02:37:21.840 when the standard input fails to
02:37:23.600 interpret the input then follow this
02:37:25.920 with
02:37:27.040 f
02:37:27.920 flush
02:37:30.080 this is a function pass in standard
02:37:32.640 input this will clear the input buffer
02:37:35.280 basically speaking once we hit enter we
02:37:36.960 have a new line character within our
02:37:38.640 input buffer so we just need to flush
02:37:40.640 that and get rid of it that should
02:37:42.240 prevent our program from going crazy so
02:37:44.560 let's type in some characters
02:37:47.439 invalid choice
02:37:48.880 cool then i would like to exit
02:37:51.439 all right everybody that is a banking
02:37:53.439 program for some practice
02:37:55.439 if you would like a copy of this code
02:37:56.880 i'll post this in the comment section
02:37:58.319 down below and well yeah that's a
02:38:00.319 banking practice program in c plus
02:38:06.160 all right everybody in this video we're
02:38:08.399 going to create a game of rock paper
02:38:10.240 scissors let's create our function
02:38:12.319 declarations first
02:38:14.560 char
02:38:15.600 get
02:38:16.399 user
02:38:17.520 choice
02:38:19.280 char in this case would be the return
02:38:21.040 type will be returning a character
02:38:24.399 char
02:38:25.600 get
02:38:26.640 computer
02:38:28.160 choice
02:38:31.680 void there is no return type
02:38:34.800 show
02:38:36.000 choice
02:38:37.600 there will be one parameter
02:38:39.920 char
02:38:41.359 choice
02:38:43.040 then the last function is
02:38:45.359 void
02:38:46.800 choose
02:38:48.080 winner
02:38:49.280 there will be two parameters
02:38:51.600 char
02:38:52.640 player that's us
02:38:55.200 char computer
02:38:57.439 the computer's choice will be determined
02:38:59.200 randomly using a random number generator
02:39:02.080 let's define these functions let's copy
02:39:04.160 all of these after the main function i
02:39:06.319 will paste them then add a set of curly
02:39:08.800 braces after each
02:39:16.399 currently if i were to run this program
02:39:18.319 we do have some warnings because with
02:39:20.479 these two functions get user choice and
02:39:22.720 get computer choice we're not returning
02:39:24.560 anything even though we stated that
02:39:26.160 we're returning a character just for the
02:39:28.000 time being i'm going to return 0 just so
02:39:30.640 that those warnings go away but we'll
02:39:32.800 correct these momentarily so we
02:39:34.640 shouldn't have those warnings within the
02:39:36.560 main function we will declare two
02:39:38.720 characters one for player
02:39:41.280 char player that's us
02:39:43.920 char
02:39:44.720 computer that's the opponent we will
02:39:47.120 take our player
02:39:49.359 then assign this a value of whatever is
02:39:52.160 returned from the get user choice
02:39:54.399 function then we need to fill in this
02:39:56.240 function
02:39:58.240 within the get user choice function i
02:40:00.399 will create a local variable of player
02:40:03.280 as well i'll create a message to begin
02:40:05.520 our game
02:40:06.640 standard output
02:40:09.840 rock
02:40:11.120 paper
02:40:12.720 scissors
02:40:14.399 game
02:40:15.359 i'll add a new line
02:40:17.680 uh this part isn't necessary but i'm
02:40:19.920 just going to add a bunch of asterisks
02:40:22.000 afterward
02:40:27.600 just because i think it would look cool
02:40:29.120 underneath our title
02:40:31.120 let's list our choices standard output
02:40:35.680 the character r
02:40:38.479 for
02:40:39.439 rock
02:40:42.160 new line
02:40:45.920 let's copy this
02:40:52.960 p
02:40:53.680 for paper
02:40:56.399 s for
02:40:58.720 scissors
02:41:02.640 standard input
02:41:05.040 player
02:41:07.359 i'm just going to test that this works
02:41:11.040 standard output
02:41:14.399 player
02:41:18.399 rock paper scissors game
02:41:20.399 r for rock p for paper s for scissors
02:41:22.720 i'll pick r
02:41:24.640 that would give us the character r
02:41:30.240 okay so we know that that works
02:41:32.880 i'm going to place some of this code
02:41:34.240 within a do while loop
02:41:36.479 because the user might not type in rp or
02:41:39.359 s
02:41:43.120 so do
02:41:46.479 while
02:41:49.520 i'm going to stick my code within the do
02:41:51.760 while loop
02:41:57.600 i'm just going to add one more line of
02:41:59.279 output
02:42:06.000 choose one of the following
02:42:09.920 all right we'll continue this while loop
02:42:12.240 as long as our player
02:42:14.640 does not equal
02:42:16.640 the character r
02:42:19.200 and
02:42:20.640 player
02:42:22.640 does not equal
02:42:24.800 the character p
02:42:27.520 and
02:42:28.880 player does not equal the character s
02:42:33.279 then at the end of this function we will
02:42:35.040 return player
02:42:37.359 we can't escape this while loop until we
02:42:39.359 pick either
02:42:40.560 r
02:42:41.279 p
02:42:42.080 or s
02:42:43.359 that's how this condition works
02:42:45.680 let's test it
02:42:48.319 rock paper scissors game choose one of
02:42:50.160 the following r for rock p for paper s
02:42:52.800 for scissors uh i will pick
02:42:56.240 w for wombo
02:42:59.040 choose one of the following r p or s
02:43:01.680 uh i like the letter x nope can't pick
02:43:04.560 that uh let's go with s for scissors
02:43:07.920 okay s is a valid choice okay that is
02:43:11.120 the get user choice function that is
02:43:13.520 complete
02:43:14.479 so i'm going to close out of this
02:43:16.080 function
02:43:19.920 after we assign our player variable
02:43:21.920 let's display the user's choice
02:43:24.240 standard output
02:43:27.600 your choice colon space
02:43:32.160 then we will invoke the show choice
02:43:34.319 function
02:43:35.680 show choice
02:43:37.439 then there is one parameter we have to
02:43:39.200 pass in a choice as an argument
02:43:42.319 we will pass in our player that's a
02:43:44.720 character
02:43:45.920 within the show choice function i'm
02:43:47.840 going to create a switch
02:43:50.560 switch
02:43:51.680 we're examining some value against
02:43:53.680 matching cases we'll examine our choice
02:43:57.520 our choice argument that we receive
02:44:00.000 if our choice
02:44:02.160 matches the case r
02:44:04.720 what would we like to do
02:44:06.640 i'm going to display some output
02:44:09.120 standard output
02:44:11.760 just rock
02:44:13.120 then i'll add a new line
02:44:15.920 make sure to break
02:44:20.319 then case
02:44:22.479 p for paper
02:44:25.200 standard
02:44:27.120 output
02:44:30.160 paper i'll add a new line
02:44:34.080 then break
02:44:39.279 case
02:44:40.800 s for scissors
02:44:43.200 standard
02:44:44.399 output
02:44:47.040 scissors
02:44:48.160 new line
02:44:51.600 then break
02:44:54.080 let's close out of this function then
02:44:56.000 test it
02:45:00.479 okay i'll type r for rock your choice
02:45:03.840 rock
02:45:07.760 p for paper your choice paper
02:45:14.640 s for scissors your choice scissors
02:45:18.319 okay the show choice function is done
02:45:20.800 now we need to get the computer choice
02:45:25.359 computer
02:45:26.840 equals get
02:45:29.600 computer choice
02:45:34.399 then we'll need to fill in this function
02:45:38.160 get computer choice right here
02:45:41.200 we'll need to generate a random seed
02:45:43.439 s
02:45:44.160 rand
02:45:46.160 pass in the time function
02:45:48.479 then type zero or null
02:45:51.120 you may need to include this header file
02:45:52.880 at the top of your program just in case
02:45:54.960 this doesn't work
02:45:56.640 include
02:45:58.160 c
02:45:58.880 time
02:46:00.399 we'll generate a random number between
02:46:02.240 one and three
02:46:03.600 and num
02:46:05.040 equals brand function
02:46:08.160 modulus
02:46:09.439 three plus one
02:46:11.600 we'll examine this number against
02:46:13.120 matching cases
02:46:15.520 switch
02:46:16.800 we're examining our num
02:46:19.600 the first case will be the number one
02:46:22.640 if our random number is 1
02:46:24.960 let's return
02:46:26.720 the character r
02:46:29.520 since we're returning a value we don't
02:46:31.439 necessarily need to add that break
02:46:33.439 statement we're already breaking when we
02:46:35.520 return
02:46:36.560 so we can omit this
02:46:39.520 case 2
02:46:41.439 return the character
02:46:45.120 p for paper
02:46:47.600 case 3
02:46:49.359 return
02:46:51.120 s for scissors
02:46:52.880 okay we can close out of the get
02:46:54.720 computer choice function that's all done
02:46:57.680 back within the main function
02:46:59.840 let's display the computer's choice
02:47:03.840 standard output
02:47:06.680 computer's choice
02:47:10.000 will invoke the show choice function
02:47:14.479 but pass in our computer
02:47:17.840 let's run it to test it
02:47:20.479 i'll pick r for rock
02:47:22.479 your choice rock the computer's choice
02:47:24.800 is paper
02:47:26.080 let's try it like two more times
02:47:29.279 okay we chose paper the computer chose
02:47:31.439 rock
02:47:35.120 let's pick s for scissors
02:47:37.120 your choice scissors the computer's
02:47:39.120 choice is also scissors
02:47:41.120 okay so the computer is picking a random
02:47:43.200 choice that's good now we'll have to
02:47:44.960 decide who won at the end of our program
02:47:47.359 we will invoke the choose winner
02:47:49.040 function
02:47:50.240 pass in our player
02:47:52.319 as well as the computer
02:47:56.800 then within the choose winner function
02:47:59.040 let's create another switch
02:48:01.520 we will examine our player against
02:48:03.760 matching cases
02:48:05.680 if our player
02:48:07.520 chooses rock the character r
02:48:10.800 i think the best way to do this would be
02:48:12.479 to use if statements within each case
02:48:18.319 if the player chooses rock and if the
02:48:21.120 computer
02:48:23.359 chooses
02:48:24.880 r for rock
02:48:26.399 that means there's a tie
02:48:29.680 i'll display that standard output
02:48:33.680 it's a tie
02:48:36.319 then i'll add a new line
02:48:40.319 else if
02:48:43.439 the computer
02:48:45.359 chooses
02:48:46.720 paper
02:48:48.160 that means we lose
02:48:50.080 standard output
02:48:52.960 you lose
02:48:58.560 else
02:48:59.920 well there's only one option left
02:49:01.600 scissors because if the computer didn't
02:49:04.160 choose rock or paper that means they
02:49:06.800 pick scissors
02:49:08.000 rock beats scissors
02:49:10.000 so let's display that the user one
02:49:14.080 you win
02:49:17.680 oh then be sure to add a break at the
02:49:19.840 end
02:49:20.560 to break out of the switch
02:49:22.880 this is the case if the player chooses
02:49:24.960 rock let's copy all of this code
02:49:28.960 paste it
02:49:30.640 and let's move this over now if the user
02:49:33.439 chooses paper we have some different
02:49:35.520 results paper be its rock will change
02:49:39.120 this line of output to be
02:49:43.120 you win
02:49:44.640 if the user chooses paper and the
02:49:46.479 computer chooses paper
02:49:48.160 that means it's a tie
02:49:50.800 it's a tie
02:49:53.120 if we choose paper and the computer
02:49:55.279 chooses scissors that means we lose
02:49:58.160 you lose
02:50:00.800 one more case
02:50:05.200 if the player picks scissors
02:50:07.760 and the computer picks rock
02:50:10.000 you lose
02:50:12.560 scissors beats paper
02:50:16.000 you win
02:50:18.160 else scissors ties with scissors
02:50:22.960 it's a tie
02:50:25.040 and that is everything
02:50:27.840 so let's close this function
02:50:30.399 and run this program
02:50:35.040 okay i'll pick r for rock
02:50:37.520 we picked rock the computer picked
02:50:39.279 scissors you win
02:50:42.800 p for paper
02:50:45.439 the computer also picked paper it's a
02:50:47.600 tie
02:50:50.720 i'll pick scissors
02:50:53.359 i picked scissors the computer picked
02:50:55.200 rock you lose
02:50:57.200 well all right then everybody that is a
02:50:59.359 game of rock paper scissors
02:51:01.439 if you would like a copy of this code
02:51:03.279 i'll post this in the comment section
02:51:04.880 down below and well yeah that's a game
02:51:07.439 of rock paper scissors in c plus
02:51:13.120 we have a big topic today i need to
02:51:15.760 discuss arrays an array is a data
02:51:18.720 structure that can hold multiple values
02:51:21.840 values are accessed by an index number
02:51:24.640 think of an array as kind of like a
02:51:26.720 variable that holds multiple values it's
02:51:29.520 a little more complicated than that but
02:51:31.279 that's a good way of thinking about them
02:51:33.200 perhaps we have the name of a car
02:51:35.760 this will be a standard string i will
02:51:38.240 name this car
02:51:39.840 assign this a value of whatever card
02:51:42.080 that you like one card that i like is a
02:51:44.479 corvette
02:51:46.399 then i will display whatever our car is
02:51:49.040 standard output
02:51:51.439 car
02:51:55.439 so of course this car is a corvette we
02:51:58.080 can transform this variable into an
02:52:00.319 array by making the following changes
02:52:02.880 after the variable name add a set of
02:52:05.279 square brackets
02:52:07.200 then enclose your values with a set of
02:52:09.040 curly braces
02:52:11.200 there we now have an array my variable
02:52:13.279 car is now an array now this variable
02:52:15.760 can hold multiple values multiple cars
02:52:18.880 kind of like it's a parking garage
02:52:21.040 separate each value with a comma
02:52:23.600 this time i'll add a mustang
02:52:27.359 then a camry
02:52:29.040 now take a look at this i will display
02:52:31.040 car
02:52:33.520 now what the heck is this so this is a
02:52:35.680 memory address of where our array is
02:52:37.680 located like one two three fake street
02:52:40.240 if i need one of these elements one of
02:52:42.399 these values that's found within the
02:52:44.399 array in order to access it i have to do
02:52:46.960 so by an index number after the array
02:52:49.840 name i will add a set of square brackets
02:52:53.279 then an index number
02:52:54.960 the first element in an array has an
02:52:57.200 index of zero because computers always
02:52:59.200 start with zero
02:53:00.960 and we have our corvette it's kind of
02:53:02.960 like a parking spot number that's why i
02:53:05.120 went with this example of cars if i need
02:53:07.439 the next element within my array i would
02:53:09.600 access element number one then i should
02:53:11.920 probably add a new line just to separate
02:53:13.920 these
02:53:15.120 new line
02:53:19.600 we have our corvette and our mustang
02:53:22.720 then we have our third element which
02:53:24.399 would have an index of two so we have
02:53:26.720 our three elements our corvette our
02:53:28.640 mustang and our camry you can reassign
02:53:31.200 values too i'm going to change the first
02:53:33.439 element within this array take the array
02:53:35.680 name
02:53:36.479 select an index number i'll set the
02:53:38.640 sequel to
02:53:40.319 a camaro a chevy camaro
02:53:43.040 now at parking spot number zero we have
02:53:46.720 our camaro then our mustang then our
02:53:49.279 camry i'm going to rename car as cars
02:53:52.479 just so people know that it's plural
02:53:54.880 although it's not necessary one thing
02:53:56.800 with arrays is that they can only
02:53:58.880 contain values of the same data type
02:54:01.359 like i'll try and stick a number within
02:54:02.960 here number one
02:54:07.840 so our compiler doesn't like it that
02:54:09.520 there's a number in here with all these
02:54:11.040 strings
02:54:12.319 so arrays should all be of the same data
02:54:14.479 type
02:54:15.359 now if you don't know what you want to
02:54:16.880 place within an array you can simply
02:54:19.200 declare an array then assign values
02:54:21.120 later
02:54:22.319 i'm going to declare an array of cars
02:54:25.200 and then later assign some values
02:54:28.479 cars at index 1
02:54:30.720 will have our mustang
02:54:34.160 cars at index 2
02:54:38.399 will be our camry
02:54:41.680 see we still have an error though
02:54:43.680 array size missing and cars
02:54:46.640 you can declare an array
02:54:48.399 then assign values later we need to set
02:54:51.120 a size to this array it's a static data
02:54:53.520 structure if i'm only going to place
02:54:55.600 three cars within this array
02:54:57.680 i'll set the size to be three so within
02:55:00.000 the square brackets you can set an array
02:55:02.080 size and this would work the same
02:55:04.479 you can declare an array be sure to set
02:55:06.640 the size and then assign values later
02:55:10.080 let's try one last example i'm going to
02:55:12.240 create an array of prices
02:55:14.319 these will be of the double data type
02:55:17.200 prices add a set of square brackets
02:55:20.319 i'll go ahead and assign these values
02:55:21.920 right away so i don't need to declare a
02:55:23.760 size explicitly
02:55:25.520 make up some prices
02:55:27.600 five dollars seven dollars and fifty
02:55:30.319 cents
02:55:32.319 nine dollars and ninety nine cents
02:55:34.800 then fifteen dollars
02:55:37.359 i'll display these prices standard
02:55:39.279 output
02:55:40.240 prices i'll list an index number of what
02:55:42.800 element i'm trying to access
02:55:44.880 the first would be zero
02:55:47.040 then i'll add a new line
02:55:49.439 let's copy this line of code
02:55:51.680 and paste it a couple more times
02:55:54.000 we have prices at index zero that is the
02:55:56.560 first element
02:55:57.840 then one
02:55:58.960 two and three
02:56:02.479 and here are the prices so yeah that's
02:56:04.960 an array think of it as a variable that
02:56:07.520 can hold multiple values it's a little
02:56:10.080 more complicated than that it's a type
02:56:12.160 of data structure but that's a good way
02:56:14.080 of thinking about them to change a
02:56:15.840 variable into an array after the
02:56:17.920 variable name add a set of square
02:56:19.840 brackets place your values within a set
02:56:22.160 of curly braces that's if you're
02:56:23.840 assigning values right away or otherwise
02:56:25.920 you can set a size and then assign
02:56:28.080 values later that's another option so
02:56:30.960 yeah those are arrays your assignment is
02:56:33.520 to post an array in the comments section
02:56:35.279 down below and well yeah those are
02:56:37.359 arrays in z plus plus
02:56:41.840 you guys ready all right let's talk
02:56:43.439 about the size of operator the size of
02:56:45.840 operator determines the size in bytes of
02:56:48.880 a variable data type class objects etc
02:56:53.279 whatever you would like to find the size
02:56:54.960 of you stick within the parentheses of
02:56:57.040 the size of operator here's an example
02:56:58.960 let's create a double
02:57:01.520 double gpa
02:57:03.760 our gpa will be
02:57:05.840 a solid 2.5 to determine the size in
02:57:09.279 bytes of my variable or a data type i
02:57:12.000 will just place within the set of
02:57:13.520 parentheses
02:57:14.800 i'll display this
02:57:16.240 standard
02:57:17.439 output
02:57:19.279 size of operator i would like to return
02:57:21.760 the size of my gpa variable
02:57:24.640 then i'll just add a string
02:57:27.359 bytes
02:57:28.399 new line
02:57:30.319 let's take a look the size of my gpa
02:57:33.200 variable is 8 bytes that's the maximum
02:57:36.560 size allocated to my double variable if
02:57:39.279 i was to replace gpa with a data type
02:57:42.000 such as double well this would be the
02:57:44.160 same eight bytes this will be helpful in
02:57:46.319 the future when we begin working with
02:57:47.920 arrays so let's try a couple other
02:57:49.680 variables i'll create a string standard
02:57:53.120 string name
02:57:54.640 assign some name
02:57:56.960 then i will find the size of the string
02:57:59.920 size of name
02:58:02.880 the size of a string is 32 bytes because
02:58:05.920 a string really just holds an address to
02:58:08.240 where some text is located the address
02:58:10.640 of where the string of text is located
02:58:13.200 is 32 bytes even if i were to change the
02:58:15.760 size of the string bro code is awesome
02:58:19.520 well this size is still going to be the
02:58:21.200 same 32 bytes because a string is a
02:58:24.399 reference data type let's try a couple
02:58:26.319 other examples how about a character
02:58:29.359 char grade
02:58:32.399 my grade will be an f
02:58:34.960 i will find the size of this character
02:58:37.359 grade
02:58:38.880 the size of a character is one byte
02:58:43.120 let's try a boolean boolean student
02:58:46.479 is somebody a student true or false
02:58:49.600 i'll play student within the size of
02:58:51.600 operator
02:58:53.040 a boolean variable also takes one byte
02:58:55.439 of memory this time let's find the size
02:58:57.760 of an array in bytes i'll create an
02:59:00.000 array of characters
02:59:02.560 char
02:59:03.600 grades this will be an array
02:59:06.240 i'll set this equal to some grades
02:59:09.200 a
02:59:10.560 b
02:59:12.800 c
02:59:14.560 d
02:59:15.920 then f
02:59:17.680 i'll place my array within the size of
02:59:19.760 operator
02:59:21.359 the size of this array grades is five
02:59:24.560 bytes remember that characters take up
02:59:27.040 one byte of memory an array of five
02:59:29.200 characters would be well five bytes
02:59:31.920 we can use the size of operator to
02:59:33.840 calculate how many elements are within
02:59:35.760 an array if we have the total size of
02:59:38.319 our array we could divide this by the
02:59:40.240 size of one element
02:59:43.120 size
02:59:44.160 of
02:59:45.120 grades
02:59:46.240 at index of zero or otherwise we can
02:59:49.120 find the data type
02:59:51.920 we'll divide the size of my array grades
02:59:54.800 divided by the size of a character
02:59:58.800 so i should have these many elements
03:00:01.760 five elements within my array of grades
03:00:04.240 if i were to add one more grade like an
03:00:06.560 e even though that's not a typical grade
03:00:09.840 well then the total elements within that
03:00:11.760 array would be six elements that's a
03:00:14.080 useful trick to calculate the size of an
03:00:16.319 array how many elements are within that
03:00:17.920 array one more this will be a bonus
03:00:20.080 question
03:00:21.200 i'll create an array of strings
03:00:24.080 i'll name the students
03:00:27.520 we'll enter in some student names
03:00:30.479 such as spongebob
03:00:35.200 patrick
03:00:37.120 then squidward
03:00:39.920 to calculate how many strings are within
03:00:42.000 this array how many students we have we
03:00:44.319 can find the size of my array students
03:00:47.439 divided by the size of a string
03:00:55.040 i have three elements within this array
03:00:57.040 of students then i could add one more
03:01:00.240 and this equation should calculate that
03:01:02.960 i'll add
03:01:04.840 sandy size of students divided by the
03:01:07.840 size of a string
03:01:09.520 would give me
03:01:11.040 four elements so yeah that's the size of
03:01:13.920 operator everybody it will return the
03:01:16.479 size and bytes of a variable data type
03:01:19.840 class objects all sorts of things it
03:01:22.640 will be really helpful when working with
03:01:24.560 arrays because we can determine the size
03:01:26.560 of an array but we'll get some practice
03:01:28.240 with that in the future and well yeah
03:01:30.160 that's the size of operator in c plus
03:01:36.000 alright guys in this video i'm going to
03:01:37.920 show you how we can iterate over the
03:01:39.760 elements of an array suppose we have an
03:01:41.920 array of students these will be strings
03:01:44.479 standard
03:01:45.600 string
03:01:47.200 i'll name this array students
03:01:50.319 set the sequel to some student names
03:01:52.880 pick a few
03:01:55.279 spongebob
03:01:58.240 patrick
03:02:00.160 then squidward
03:02:04.640 suppose i would like to display all
03:02:06.160 these students normally to do that i
03:02:08.080 would type standard output
03:02:10.880 my array followed by an index number so
03:02:13.120 the first student would be spongebob
03:02:15.120 which has an index of zero
03:02:17.200 and my first student is spongebob
03:02:19.600 if i need to display all of the elements
03:02:21.439 of this array i would have to one by one
03:02:24.479 access each element
03:02:26.800 then i'll just add a new line
03:02:30.640 we have spongebob patrick and squidward
03:02:33.600 if i need to display all of the elements
03:02:35.680 of an array a better approach would be
03:02:38.080 to use a for loop
03:02:40.560 i'm going to type four parentheses curly
03:02:42.880 braces we'll need an index and i
03:02:46.800 i'll set the sql to zero because the
03:02:49.040 first element in our array has an index
03:02:51.279 of zero
03:02:52.720 i'll continue this as long as i is less
03:02:55.520 than the length of our array currently
03:02:57.840 it's three
03:02:59.600 then increment i by one
03:03:02.640 during each iteration i would like to
03:03:04.479 display each element standard
03:03:07.439 output
03:03:09.279 students
03:03:10.560 now instead of an index number like 0 1
03:03:13.680 2 or whatever i'm going to use my
03:03:15.760 counter variable i students at index of
03:03:18.640 i during the first iteration i will be 0
03:03:22.000 then 1 then 2
03:03:23.920 once we reach 3 we'll stop
03:03:26.560 i'll add a new line
03:03:29.920 this for loop will print the elements of
03:03:31.920 my array
03:03:34.240 spongebob patrick squidward
03:03:36.640 there's one issue with this though what
03:03:38.080 if we add another student such as
03:03:41.680 sandy
03:03:45.200 well this for loop will stop once i
03:03:47.439 reaches 3. if we make any adjustments to
03:03:50.000 this array we would have to go into our
03:03:52.080 code and make some changes such as
03:03:54.160 setting this for loop so that we
03:03:55.680 discontinue when i reaches 4.
03:03:59.200 this would work but it's not the best
03:04:00.800 solution for our stopping condition in
03:04:02.960 place of just setting i to be less than
03:04:04.960 some number let's calculate how many
03:04:06.880 elements are within this array to do
03:04:08.640 that we can use the size of operator
03:04:12.080 i'll type size of
03:04:14.080 my array
03:04:15.760 this will give me the total size in
03:04:17.760 bytes of my array to calculate the
03:04:19.840 number of elements i can divide size of
03:04:22.479 students
03:04:23.520 by the size of
03:04:25.200 the data type
03:04:27.279 string
03:04:28.560 or even an element
03:04:30.479 this will loop through all of the
03:04:31.840 elements of this array spongebob patrick
03:04:34.160 squidward sandy if we change the number
03:04:36.479 of elements well then there's no need to
03:04:38.560 touch this for loop
03:04:40.240 it will calculate the size automatically
03:04:42.560 see now we just have spongebob and
03:04:44.319 patrick let's create one last example
03:04:46.640 i'll create an array of grades
03:04:50.000 char
03:04:51.200 grades
03:04:54.880 we have an a
03:04:57.359 b
03:04:58.960 c
03:05:00.640 d
03:05:01.920 then f
03:05:04.080 if i need to iterate over this array of
03:05:06.160 characters i would find the size of my
03:05:09.040 array grades divided by the size of a
03:05:12.720 character the character data type
03:05:15.760 during each iteration i will display
03:05:18.160 grades at index of i our counter
03:05:23.040 and this will display all of the
03:05:24.640 elements of this array so yeah that's
03:05:26.720 how to iterate over an array using a for
03:05:29.279 loop in the next topic i will explain
03:05:31.600 the for each loop which has different
03:05:33.680 syntax and well yeah that's how to
03:05:36.080 iterate over an array using a for loop
03:05:38.479 in c plus plus
03:05:42.560 alright guys the for each loop the for
03:05:45.600 each loop is a loop that eases the
03:05:48.399 traversal over an iterable data set an
03:05:51.279 array is an example of an iterable data
03:05:53.279 set suppose we're using a standard for
03:05:55.600 loop and i have this array of strings
03:05:57.600 named students we have spongebob patrick
03:06:00.080 and squidward using a standard for loop
03:06:02.880 i would need three statements an index a
03:06:05.920 condition
03:06:06.960 then we could increment or decrement our
03:06:08.960 index
03:06:10.479 this does work but there is another way
03:06:12.319 of writing this using a for each loop
03:06:14.800 there's less syntax than a typical for
03:06:17.120 loop but it's less flexible using a for
03:06:19.840 loop we can go forwards backwards or
03:06:22.880 even skip iterations of something we're
03:06:24.880 iterating over using a for each loop we
03:06:27.840 start at the beginning and go to the end
03:06:30.000 there's less flexibility so let's change
03:06:32.399 this to a for each loop
03:06:35.760 first we'll add the data type of what
03:06:37.840 we're iterating over we're iterating
03:06:39.920 over strings
03:06:41.840 then we'll need a name for the current
03:06:44.160 element that we're on we have an array
03:06:46.080 of students let's name the current
03:06:47.840 element student
03:06:49.840 colon
03:06:51.200 then our iterable data set which would
03:06:53.600 be our
03:06:54.840 array string student colon students
03:06:58.800 during each iteration let's display
03:07:01.680 whatever the current element is which i
03:07:03.840 named student
03:07:06.240 then i'll add a new line
03:07:11.359 and there we go we have our three
03:07:12.800 students
03:07:13.920 then you could change the amount of
03:07:15.200 students if you would like let's add
03:07:17.359 sandy
03:07:19.200 now we have spongebob patrick squidward
03:07:21.439 sandy let's try a different example
03:07:23.439 let's work with grades this time these
03:07:25.760 will be of the int data type int
03:07:28.800 grades
03:07:29.920 equals make up some grades
03:07:33.200 65
03:07:35.040 72
03:07:36.840 81 93 good enough the data type of what
03:07:41.120 we're iterating over is not a string
03:07:43.279 this time it is an int integers
03:07:46.640 let's name each element
03:07:49.120 simply grade
03:07:50.720 colon
03:07:51.760 the name of my iterable data set
03:07:54.319 which would be my array grades for every
03:07:58.000 grade in grades let's display each grade
03:08:05.120 and here are the grades 65 72 81 93
03:08:09.439 so that's a for each loop it's a loop
03:08:12.640 that eases the traversal over an
03:08:14.720 iterable data set there's less syntax
03:08:17.279 involved in a for each loop but it's
03:08:19.200 less flexible
03:08:20.399 if you just need to display the elements
03:08:22.080 of an array a for each loop would work
03:08:24.479 perfect so yeah that's a for each loop
03:08:27.040 everybody your assignment is to post a
03:08:29.840 for each loop in the comment section
03:08:31.520 down below and well yeah that's the for
03:08:34.000 each loop in c plus plus
03:08:38.720 all right everybody so in this video i'm
03:08:41.040 going to show you how we can pass an
03:08:42.640 array to a function suppose we have an
03:08:45.040 array of prices
03:08:46.560 these will be of the double data type
03:08:48.880 double
03:08:49.920 prices
03:08:51.040 straight brackets equals just make up
03:08:53.840 some prices 49.99
03:08:58.200 15.5 cents
03:09:00.640 75 dollars
03:09:03.279 nine dollars ninety-nine cents good
03:09:05.600 enough we'll create a function to find
03:09:07.520 the sum of these prices and print a
03:09:09.680 total let's say double
03:09:12.479 total
03:09:13.840 equals
03:09:15.040 then i'll invoke a get total function
03:09:17.840 which we still need to declare and
03:09:19.279 define so let's do that now we'll return
03:09:22.319 a double double get
03:09:25.120 total
03:09:28.000 let's list the parameters we need to
03:09:30.239 accept an array of doubles
03:09:32.640 double
03:09:34.479 prices
03:09:35.760 then add a set of square brackets for
03:09:38.000 the parameter now when we pass an array
03:09:40.720 to a function you only need to pass the
03:09:43.200 arraign name you don't need a set of
03:09:45.120 square brackets
03:09:46.560 then we'll need a function declaration
03:09:48.640 let's do that before the main function
03:09:52.080 then at the end of my program i will
03:09:53.600 display the total
03:09:55.600 standard
03:09:56.840 output pick a currency uh let's pick a
03:10:00.080 dollar sign
03:10:02.720 then i will display the total within the
03:10:05.600 get total function i'm going to declare
03:10:08.239 a separate local instance of a total
03:10:10.800 variable
03:10:13.680 remember that variables can have the
03:10:15.200 same name as long as they're within a
03:10:16.960 different function so we have double
03:10:18.880 total i'm going to iterate over my array
03:10:21.200 using a for loop
03:10:23.439 normally what we would do is say int i
03:10:26.160 equals zero
03:10:27.760 i would continue this as long as i is
03:10:30.160 less than then at this point we would
03:10:32.080 calculate the size of the array but
03:10:34.560 technically this isn't going to work and
03:10:36.319 i'll demonstrate why we have the size of
03:10:38.560 our array prices
03:10:40.640 divided by the size of either the data
03:10:43.359 type or one of the elements
03:10:46.000 typically i like to use one of the
03:10:47.279 elements
03:10:48.560 prices at index zero then i will
03:10:51.120 increment our counter by one during each
03:10:53.200 iteration within our for loop let's
03:10:55.760 assign total equal to total
03:10:58.800 plus prices at index of i
03:11:01.359 or we could shorten this to
03:11:03.520 total plus equals prices at index of i
03:11:07.600 at the end of our program we will return
03:11:09.520 whatever the total is now this isn't
03:11:11.760 going to work the way it's written now
03:11:13.920 here's why when we pass an array to a
03:11:16.319 function it decays into what's known as
03:11:18.399 a pointer which we haven't discussed yet
03:11:20.399 but we will in future topics within this
03:11:22.560 function we're not working with an array
03:11:24.160 anymore we're working with a pointer
03:11:25.840 that points to the address of where the
03:11:28.239 array begins this function has no idea
03:11:31.040 how big this array is anymore we can't
03:11:33.520 calculate how many elements are within
03:11:35.120 this array what we could do is that when
03:11:37.279 we invoke this function we can pass in
03:11:39.600 the array as well as the size of the
03:11:41.920 array since this function no longer
03:11:44.000 knows how big the array is we can
03:11:46.000 explicitly let the function know what
03:11:47.840 the size is so let's calculate what the
03:11:50.000 size is
03:11:51.120 into size equals
03:11:53.600 we can just copy all this code
03:11:57.840 paste it
03:11:59.840 now when we invoke this function i'm
03:12:01.600 going to pass the size as a second
03:12:03.840 argument
03:12:05.840 then we'll need a matching set of
03:12:07.120 parameters
03:12:08.880 and size
03:12:11.600 be sure to add that with your function
03:12:13.200 declaration too if you have one
03:12:16.560 i would like to continue this for loop
03:12:18.399 as long as i is less than size
03:12:21.680 now this should work
03:12:23.359 let's verify that
03:12:25.439 yep and our total is 150 dollars and
03:12:28.960 three cents in conclusion when you pass
03:12:31.359 an array to a function you only have to
03:12:33.600 pass the array name you don't need a set
03:12:36.080 of square brackets when you do so
03:12:38.000 however when a function receives an
03:12:39.680 array it decays into a pointer and the
03:12:42.800 function no longer knows what the size
03:12:44.560 of the array is so we could pass that as
03:12:47.279 an additional argument to let the
03:12:48.720 function know what the size is which we
03:12:50.560 could then use to you know iterate over
03:12:52.399 the array so that's how to pass an array
03:12:54.560 to a function your assignment is to post
03:12:57.120 a function that accepts an array as an
03:12:59.279 argument in the comments section down
03:13:01.040 below and well yeah that's how to pass
03:13:03.200 an array to a function in c plus plus
03:13:08.880 hey welcome back so in this video i'm
03:13:11.439 going to show you how we can search an
03:13:13.120 array for an element let's create an
03:13:15.200 array of numbers something simple int
03:13:18.399 numbers this will be an array
03:13:20.800 then assign some numbers i'll just
03:13:22.880 assign the numbers 1 through 10 because
03:13:24.800 i'm basic like that
03:13:28.239 there one through ten we'll probably
03:13:30.239 need this later i'm going to calculate
03:13:32.319 the size of the array
03:13:34.560 and size equals
03:13:37.120 size of
03:13:38.479 my array numbers divided by the size of
03:13:42.880 one of the elements
03:13:44.479 i'll just pick the first element
03:13:48.080 we'll need to keep track of an index
03:13:49.680 like what index did we find something
03:13:51.840 that we're searching for
03:13:53.920 int index
03:13:55.600 i'll declare this variable but we don't
03:13:57.359 need to assign it
03:13:59.200 as well as int
03:14:01.279 mynum mynum will be the number that
03:14:03.520 we're looking for
03:14:05.840 let's accept some user input we'll
03:14:07.520 create a prompt
03:14:08.800 standard output
03:14:11.840 enter
03:14:13.200 element to
03:14:15.120 search
03:14:16.319 for
03:14:18.560 i'll add a new line because i can
03:14:22.880 standard
03:14:24.479 input
03:14:26.319 my num
03:14:29.279 i'm going to create a function that will
03:14:31.040 search an array for us let's define that
03:14:33.600 function outside of the main function
03:14:35.840 this function will return an integer
03:14:38.239 that will be our index
03:14:40.000 the return type isn't
03:14:41.920 i'll name this function
03:14:43.680 search array
03:14:46.080 there's a couple parameters
03:14:48.080 we'll have three parameters
03:14:50.080 an array of integers
03:14:52.239 integer
03:14:53.279 array
03:14:55.200 the size of the array and size
03:14:58.239 then some element that we're searching
03:14:59.840 for
03:15:01.680 int element
03:15:03.600 then we should probably add a function
03:15:05.600 declaration at the top
03:15:08.560 that's good
03:15:09.680 this function will return an integer the
03:15:12.160 index of the element that we're
03:15:13.439 searching for
03:15:14.720 we will take our index variable
03:15:17.200 set the sql to then i'm going to invoke
03:15:20.000 the search array function that we just
03:15:21.600 declared
03:15:22.720 but we need three matching arguments for
03:15:24.960 the three parameters that we have set up
03:15:27.279 an array a size and an element
03:15:30.399 we'll pass in our array
03:15:32.840 numbers the size of the array that we
03:15:35.279 already calculated
03:15:37.120 and the element that we're searching for
03:15:38.960 we're searching for mynum
03:15:42.479 within the search array function we will
03:15:44.560 iterate from the beginning of the array
03:15:46.399 to the end and see if there's any
03:15:47.920 matches we can do that with a for loop
03:15:52.880 we'll begin at 0
03:15:54.640 into i equals 0 that's our index
03:15:58.479 i will continue this as long as i is
03:16:00.880 less than the size of the array that
03:16:03.200 we're passing in as an argument
03:16:05.359 then increment our index by one
03:16:08.479 this would be technically a linear
03:16:10.239 search
03:16:11.359 we'll start at the beginning
03:16:13.200 and check every value until we reach the
03:16:15.520 end
03:16:17.040 so let's check using an if statement
03:16:19.040 within the for loop
03:16:20.640 if
03:16:21.680 our array we did name this array numbers
03:16:24.000 but remember that you can rename
03:16:25.600 parameters
03:16:26.800 numbers is technically our array
03:16:29.439 if our array that we receive
03:16:32.640 at index of i
03:16:34.560 that's our counter
03:16:36.080 is equal to the element that we're
03:16:38.080 searching for
03:16:40.239 we will return whatever the index is i
03:16:44.080 if we search through this entire array
03:16:46.160 and don't find that element that we're
03:16:47.600 searching for
03:16:49.200 we'll return negative one in programming
03:16:52.080 negative one serves as a sentinel value
03:16:55.279 if you see negative one that typically
03:16:57.120 means that something wasn't found we'll
03:16:59.120 return either i or negative 1
03:17:01.920 then assign it to this index variable
03:17:04.000 within the main function
03:17:05.760 using an if statement we'll check to see
03:17:07.680 what that value is
03:17:10.560 if
03:17:11.760 our index does not equal negative one
03:17:16.000 that means the element that we're
03:17:17.200 searching for is somewhere within our
03:17:18.960 array
03:17:20.800 let's display the index standard
03:17:23.520 output
03:17:25.120 my num
03:17:28.720 is at
03:17:30.640 index
03:17:33.680 whatever the index variable is
03:17:38.640 else
03:17:41.680 standard output
03:17:44.640 my num
03:17:48.000 is not in the
03:17:50.399 array
03:17:53.359 okay let's see if this actually works
03:17:56.000 enter element to search for let's search
03:17:58.479 for one
03:18:00.399 one is that index zero remember that
03:18:02.800 computers always start with zero
03:18:05.040 enter an element to search for
03:18:07.200 let's search for 10
03:18:09.439 10 is at index 9
03:18:11.520 enter an element to search for 4 20 69
03:18:15.279 420 69 is not in the array
03:18:19.200 for additional practice let's search
03:18:21.359 through an array of strings such as food
03:18:24.960 we'll create an array of strings
03:18:28.000 i'll rename numbers as foods
03:18:31.040 then think of some food that you like
03:18:34.960 pizza
03:18:36.880 hamburger
03:18:39.439 hot dog
03:18:42.880 int size equals the size of foods
03:18:46.560 divided by
03:18:48.000 one of the elements of foods let's
03:18:50.239 rename my num as my food that's the food
03:18:53.439 that we're searching for
03:18:55.680 and that will be of the string data type
03:18:59.120 in place of cn when working with strings
03:19:01.840 let's use getline because the user input
03:19:04.160 may contain spaces
03:19:06.000 standard
03:19:07.680 getline
03:19:10.880 standard
03:19:12.399 input
03:19:14.479 my food
03:19:16.960 within the search array function that we
03:19:18.800 created we will pass our array foods
03:19:22.239 the size can stay the same
03:19:24.080 then pass in my food that's what we're
03:19:26.080 searching for
03:19:27.760 within the if else statements replace my
03:19:30.239 num with my food
03:19:34.640 then we'll need to change the data types
03:19:36.479 of this function
03:19:37.760 we're accepting an array of strings
03:19:40.640 replace int with string
03:19:42.560 do that with your element as well
03:19:45.359 then we need to change the function
03:19:46.960 declaration at the top of our program
03:19:50.239 okay we can now search through an array
03:19:52.160 of strings
03:19:54.080 enter element to search for let's search
03:19:56.000 for pizza pizza is at index
03:19:58.840 zero hamburger hamburger is that index
03:20:01.920 one
03:20:04.319 hot dog
03:20:06.560 hot dog is that index two
03:20:09.040 then let's search for something that's
03:20:10.560 not within this array
03:20:14.479 what about sushi
03:20:16.800 sushi is not in the array
03:20:18.800 yeah everybody that is how to search
03:20:20.880 through an array this would technically
03:20:23.120 be a linear search
03:20:24.960 you begin at the first element of an
03:20:26.560 array check to see if the values are
03:20:28.319 equal if they're not equal you move to
03:20:30.399 the next element until you reach the end
03:20:32.640 and that's basically it if you would
03:20:34.479 like a copy of this code i'll post this
03:20:36.479 in the comment section down below and
03:20:38.399 well yeah that's how to search through
03:20:40.239 an array in c plus plus
03:20:44.880 hey everybody in this topic i'm going to
03:20:46.560 show you how we can sort an array first
03:20:48.720 i'll explain the logic behind it then
03:20:50.319 we'll write a c plus plus program to
03:20:51.920 actually handle it we'll use a standard
03:20:53.760 bubble sort it's an easy sorting
03:20:55.520 algorithm to write although there are
03:20:57.359 more efficient sorting algorithms we're
03:20:59.439 still learning so let's stick with a
03:21:01.040 bubble sort so with the bubble sort we
03:21:03.120 begin at index 0 the beginning of our
03:21:05.120 array we'll examine the element directly
03:21:07.520 to the right if the element on the left
03:21:09.760 is larger than the element on the right
03:21:11.840 we need to swap these two elements i
03:21:13.920 will take this element move it within
03:21:16.080 some temporary storage like a temporary
03:21:18.319 variable take the element on the right
03:21:21.359 move it to the left
03:21:23.439 take whatever's within temp
03:21:25.680 place it within that opening again we
03:21:27.600 take our value examine the element to
03:21:29.600 the right if it's larger we swap them
03:21:34.720 then we would just repeat this until we
03:21:36.560 reach the end
03:21:56.000 so that would be one element we would
03:21:57.840 repeat this process with the rest of the
03:21:59.600 elements now for the next iteration 1 is
03:22:02.160 not greater than 9 so we leave it alone
03:22:04.399 then we check the next element nine is
03:22:06.160 greater than two we would swap these two
03:22:08.000 values
03:22:10.880 i'll speed up the footage
03:22:58.000 that is a quick demonstration of a
03:23:00.239 bubble sort so let's actually write this
03:23:02.239 in code now
03:23:04.000 okay let's create an array
03:23:06.479 this will be an array of integers
03:23:09.520 make up some numbers make sure they're
03:23:11.120 not in order
03:23:16.239 let's calculate the size of the array
03:23:18.479 and size equals
03:23:21.120 size of
03:23:22.720 our array
03:23:24.239 divided by the size of one of the
03:23:26.800 elements
03:23:30.479 at the end of our program we will
03:23:32.080 iterate over our array i'll use a for
03:23:34.479 each loop
03:23:36.000 int
03:23:36.880 element in array
03:23:39.840 i will display using standard output
03:23:43.120 every element then i think i'll separate
03:23:45.439 each with a space
03:23:47.120 okay and here's our array obviously
03:23:49.279 unsorted so let's change that i'll
03:23:51.359 create a sort function
03:23:54.000 void sort
03:23:56.239 there will be two parameters an integer
03:23:59.439 array
03:24:01.600 int
03:24:02.479 size
03:24:03.680 let's add a function declaration at the
03:24:05.600 top of our program
03:24:08.399 before we print our array let's invoke
03:24:10.560 the sort function that we just created
03:24:13.120 pass in our array
03:24:15.040 as well as the size there we go okay so
03:24:17.840 let's head to our sort function what
03:24:19.600 we'll need to do is iterate over our
03:24:21.840 array once for every element that's
03:24:23.920 within the array we'll need the help of
03:24:25.680 a temporary variable to swap some values
03:24:28.479 then we'll need nested loops
03:24:31.120 4
03:24:32.160 and i equals 0
03:24:34.880 we'll continue this as long as i is less
03:24:37.760 than the size of our array
03:24:40.399 minus one the reason that the condition
03:24:43.120 is size minus one is because we don't
03:24:45.359 need to compare the last element to
03:24:46.800 anything the larger values will
03:24:48.560 naturally gravitate towards the end of
03:24:50.319 the array increment i by one
03:24:53.040 then we'll need a nested for loop
03:24:58.560 let's use index j because i is already
03:25:00.880 taken
03:25:03.359 now our condition is going to be size
03:25:05.760 minus i minus one once we place the
03:25:08.880 larger elements all the way to the right
03:25:10.479 they should already be in order we don't
03:25:12.080 need to sort any elements that are
03:25:13.520 already sorted then what we have to do
03:25:15.439 is use an if statement to check to see
03:25:17.520 if the current element that we're on
03:25:20.160 array
03:25:21.279 at index
03:25:22.479 of j
03:25:24.080 is greater than the element on the right
03:25:26.960 array at index of j
03:25:31.040 plus one if the element on the left is
03:25:33.680 larger than the element on the right we
03:25:35.520 just have to swap those two values
03:25:37.680 we'll take temp
03:25:39.200 which we declared up here
03:25:41.279 equals array
03:25:43.359 at index of j
03:25:46.000 array at index of j
03:25:48.800 equals array
03:25:50.479 at index of j
03:25:52.399 plus one
03:25:53.760 then lastly
03:25:55.040 array
03:25:56.160 at index of j
03:25:58.239 plus one equals whatever's within temp
03:26:01.359 and that should be it let's run this
03:26:05.680 yeah and our array is now sorted in
03:26:07.680 ascending order so if you need
03:26:09.359 descending order within this if
03:26:11.279 statement use
03:26:12.800 less than
03:26:15.120 and now this array is in descending
03:26:16.880 order well okay then everybody that's
03:26:18.960 one way in which you can sort an array
03:26:21.040 we used what's known as a bubble sort
03:26:23.279 it's easy to write but it's not as
03:26:25.040 efficient as some other algorithms that
03:26:26.880 are out there this is a good one for
03:26:28.319 beginners if you would like a copy of
03:26:30.000 this code i'll post this in the comment
03:26:31.760 section down below and well yeah that's
03:26:33.760 how to sort an array using c plus
03:26:39.279 hey everybody in this topic i'm going to
03:26:41.200 explain the fill function the fill
03:26:43.439 function fills a range of elements with
03:26:46.239 a specified value there's three
03:26:48.319 arguments a beginning address of a data
03:26:50.640 structure an ending address then some
03:26:53.200 value suppose we have an array of
03:26:55.200 strings
03:26:56.800 standard string i'll name this array
03:26:59.200 foods
03:27:00.960 i'll give this a maximum size of 10
03:27:03.600 elements
03:27:04.880 then i'll go ahead and fill this array
03:27:06.319 with the same food
03:27:07.760 i'll fill all 10 elements with the word
03:27:09.840 pizza
03:27:12.000 so that's one two three four five six
03:27:16.239 seven eight nine ten so these all have
03:27:18.319 the same value now this really isn't
03:27:20.239 practical although it does work just to
03:27:22.399 demonstrate i'll display the elements
03:27:24.160 with the for each loop
03:27:25.760 we're displaying strings for every food
03:27:29.520 element in my array foods
03:27:32.319 i would like to display
03:27:35.680 each food element
03:27:37.680 then i'll add a new line
03:27:39.520 so we have 10 elements all filled with
03:27:42.000 pizza you know this does work but it's
03:27:44.319 not practical to initialize all of these
03:27:46.560 elements manually what if we had an
03:27:48.560 array of 100 elements i would have to
03:27:50.800 type the word pizza 100 times there's a
03:27:53.600 few solutions one of which would be the
03:27:55.840 fill function which would make this
03:27:57.359 process a lot easier
03:27:59.279 i'm going to declare this array but not
03:28:01.279 fill it in quite yet
03:28:03.040 we have an array of 100 elements to
03:28:05.120 store strings i'm going to fill all 100
03:28:08.000 elements with pizza so we type
03:28:11.120 fill parentheses
03:28:12.960 now we need the beginning address of a
03:28:14.800 data structure
03:28:16.239 well that's simply the array name then
03:28:18.640 an ending address so that would be the
03:28:20.880 second argument we would type the array
03:28:23.439 name
03:28:24.479 plus the size of the array so plus 100
03:28:27.359 in this case
03:28:28.880 then some value i'll fill this array
03:28:30.720 with the word pizza 100 times
03:28:35.120 there we go
03:28:37.279 all 100 elements have been filled with
03:28:39.760 pizza now if you do change the size of
03:28:42.319 this array let's say we have 150
03:28:44.800 elements you would have to go and change
03:28:46.560 that within the fill method too what i
03:28:48.560 would do in place of adding some number
03:28:50.239 to my array i will add a size variable
03:28:53.279 foods will be index of size and then we
03:28:56.479 can set some size actually better yet
03:28:58.560 let's make this a constant
03:29:00.239 constant and
03:29:01.920 size
03:29:03.040 then i'll set this to be
03:29:04.840 100
03:29:06.479 foods plus size
03:29:09.120 so again all 100 elements are filled
03:29:11.359 with pizza now here's a few exercises if
03:29:14.399 i'm filling the first half of this array
03:29:16.080 with pizza we have our beginning address
03:29:18.720 then i need to find the halfway point
03:29:21.200 foods plus size divided by two i'll just
03:29:24.640 go ahead and put that within some
03:29:25.760 parentheses for clarity then if i were
03:29:27.840 to run this the first half of this array
03:29:30.000 contains pizza
03:29:32.160 and the second half contains nothing
03:29:34.160 it's empty
03:29:35.680 to fill the second half of this array
03:29:37.520 with hamburgers i would invoke the fill
03:29:39.920 function again
03:29:42.160 we will begin where we left off
03:29:45.600 foods plus size divided by two
03:29:48.800 the ending address would be
03:29:50.880 foods
03:29:51.920 plus
03:29:53.279 size
03:29:54.560 we will fill the second half of this
03:29:56.399 array with
03:29:57.760 hamburgers
03:30:02.000 there we are the first half is all pizza
03:30:04.479 the second half is all hamburgers
03:30:06.960 here's a challenge round we'll fill the
03:30:09.359 first third of our array with pizza the
03:30:12.000 second third will be hamburgers and the
03:30:14.399 last third will be hot dogs
03:30:16.560 but 100 doesn't divide by three evenly
03:30:18.800 just to make this simple i'll set our
03:30:20.319 array to be 99 elements we're filling
03:30:22.880 the first third of our array with pizza
03:30:25.040 size divided by three hamburgers will
03:30:27.359 begin at foods plus size divided by
03:30:30.640 three
03:30:31.680 and end at size
03:30:33.840 divided by three
03:30:36.080 times two
03:30:37.439 then we'll invoke the fill function one
03:30:39.200 more time
03:30:40.319 we'll continue where we left off
03:30:44.880 and we will end at foods plus size
03:30:48.080 and fill this with hot dogs
03:30:53.279 here we go
03:30:56.239 so we have pizza hamburgers
03:30:59.359 then hot dogs
03:31:00.880 so yeah that is the fill function we can
03:31:03.040 fill a range of elements with a
03:31:04.880 specified value it's great if you have a
03:31:07.040 lot of elements to work with and you
03:31:08.560 don't manually want to type all the
03:31:10.000 values if you would like a copy of this
03:31:12.000 code i'll post this in the comment
03:31:13.600 section down below and well yeah that's
03:31:15.760 the fill function in c plus
03:31:21.439 hey welcome back everybody in this video
03:31:23.760 i'm going to explain one of a few ways
03:31:25.760 in which we can accept user input and
03:31:27.920 place it within an array there's no
03:31:29.600 one-size-fits-all way to do it i'll show
03:31:31.680 you one way that's good for beginners
03:31:33.600 let's begin by creating an array i'll
03:31:35.439 create an array of strings named
03:31:38.840 foods we're not going to be assigning
03:31:41.120 values to this array quite yet that's
03:31:43.120 where the user input will come in if
03:31:45.120 we're not assigning values right away
03:31:46.800 when we initialize this array we'll have
03:31:48.720 to specify a size for the time being
03:31:51.439 let's say 5 something small now arrays
03:31:54.560 they're static data structures while our
03:31:57.200 program is running we can't change the
03:31:59.040 size of this array the max size is stuck
03:32:01.520 at 5 and that might be a problem if we
03:32:03.680 would like to enter in more than 5 items
03:32:05.760 we'll discuss dynamic memory in a future
03:32:07.600 video then i'm going to calculate the
03:32:10.000 size of this array and size equals size
03:32:13.359 of
03:32:14.160 my array foods divided by the size of
03:32:17.760 one of the elements foods at index of
03:32:20.319 zero
03:32:22.160 let's create a for loop to iterate over
03:32:24.239 the elements of this array
03:32:28.239 four
03:32:29.279 and i equals zero we'll continue this as
03:32:32.560 long as i is less than the size of our
03:32:35.680 array
03:32:36.640 then increment i by one
03:32:39.040 let's create a prompt
03:32:41.040 standard output
03:32:43.920 enter a
03:32:45.520 food you like
03:32:48.239 then i'll display the number
03:32:50.479 to show the user what number we're on
03:32:53.840 i
03:32:55.279 then i'm just going to add a colon at
03:32:57.439 the end
03:33:00.720 if we're working with strings we should
03:33:02.399 probably use the getline function
03:33:04.800 just because what the user enters may
03:33:06.479 contain spaces
03:33:08.160 get
03:33:09.040 line
03:33:10.319 standard input
03:33:13.200 we'll place our input within our array
03:33:16.000 foods
03:33:17.359 at the index of i whatever we're
03:33:19.680 currently on our counter at the end of
03:33:22.239 our program let's display a message
03:33:26.399 you like the following
03:33:29.840 food
03:33:33.439 i'll use a for each loop to iterate over
03:33:35.760 the elements of this array
03:33:37.760 we list the data type
03:33:40.080 a name for the current element
03:33:42.800 food in foods
03:33:46.239 let's display standard output
03:33:49.760 whatever the food is i'll add a new line
03:33:53.279 and that should be good
03:33:55.359 now take a look at this enter a food you
03:33:57.200 like we're on number zero i'm going to
03:33:59.600 add plus one to i when we display our
03:34:02.399 prompt the user is not going to be sure
03:34:04.080 why there's a number zero but we know
03:34:06.239 that's the beginning index of an array
03:34:08.080 so i'm just going to change that here
03:34:09.760 enter a food you like we're on number
03:34:11.520 one
03:34:12.399 pizza
03:34:14.560 hamburger
03:34:16.399 hot dog
03:34:18.319 ramen
03:34:19.920 sushi
03:34:21.279 and these are the five elements you like
03:34:23.439 the following food pizza hamburger hot
03:34:26.000 dog ramen sushi okay that's pretty good
03:34:28.479 so far suppose the user only wants to
03:34:30.960 enter in three elements not all five we
03:34:33.600 should add some way to escape out of
03:34:35.359 this for loop based on some user input
03:34:37.840 i'm going to add this line enter a food
03:34:40.319 you like or
03:34:43.279 q
03:34:44.800 to quit
03:34:46.560 now check this out
03:34:48.080 if the user types in q
03:34:50.399 we would like to exit
03:34:53.920 if
03:34:55.600 foods at index of i
03:34:59.120 is equal to
03:35:01.120 the string q
03:35:03.040 then i would like to break out of this
03:35:04.640 for loop the user is done entering an
03:35:06.800 input
03:35:07.680 but there's a problem with this
03:35:12.319 enter a food you like or q to quit
03:35:15.279 number one
03:35:16.720 pizza
03:35:17.920 hamburger
03:35:19.520 hot dog now i'm going to press q to quit
03:35:23.120 we don't have any more prompts to enter
03:35:24.880 in food we went to the results you like
03:35:27.680 the following food pizza hamburger hot
03:35:30.800 dog q i'd rather not put the letter q in
03:35:33.840 my foods array i'm going to create a
03:35:35.920 temporary variable just to hold some
03:35:38.080 user input
03:35:39.760 this will be of the string data type
03:35:41.680 standard string i'll name this temp
03:35:44.160 meaning temporary it's a temporary
03:35:46.000 variable in place of directly putting my
03:35:48.479 user input into my foods array i'll
03:35:51.040 place it temporarily within my variable
03:35:53.680 temp i'm going to check
03:35:55.840 if temp
03:35:57.279 is equal to q
03:35:59.520 else
03:36:00.479 will take foods
03:36:02.560 at index of i
03:36:04.160 set the sequel to temp that way we're
03:36:06.880 not directly assigning our user input to
03:36:09.600 our array until we check what it is if
03:36:12.000 the user types in queue to quit we don't
03:36:14.080 want to put that within our foods array
03:36:15.840 so let's try this again it should be
03:36:17.520 better
03:36:18.560 enter a food you like or q to quit
03:36:22.239 pizza
03:36:23.600 hamburger
03:36:25.040 hot dog q to quit
03:36:28.160 okay pizza hamburger hot dog
03:36:31.359 well the letter q isn't here
03:36:33.600 but when we display what's within the
03:36:35.200 array we have these empty spaces we did
03:36:37.680 not assign a value to these if one of
03:36:39.840 our elements is empty i don't want to
03:36:41.439 display it
03:36:42.640 so we can make this following change
03:36:44.960 in place of a for each loop let's use a
03:36:47.359 standard for loop
03:36:49.040 int i equals zero
03:36:52.080 now here's the condition we're used to
03:36:53.680 saying i is less than size right i'd
03:36:56.960 like to propose a change we'll write a
03:36:58.960 different condition i will check if the
03:37:01.359 current element is empty
03:37:03.920 foods at index of i
03:37:07.040 dot
03:37:08.479 empty function
03:37:10.239 then we'll add the not logical operator
03:37:13.120 we'll continue our for loop as long as
03:37:15.120 the current element is not empty then
03:37:17.840 we'll add the statement increment i by
03:37:20.239 one we'll display our array foods at
03:37:23.680 index of i
03:37:25.600 this for loop shouldn't display any
03:37:27.359 elements that are empty
03:37:29.840 pizza
03:37:31.439 hamburger
03:37:33.439 hot dog q to quit
03:37:35.840 yeah and we only have three elements
03:37:37.439 pizza hamburger hot dog one disadvantage
03:37:40.720 of arrays is that they have a limited
03:37:42.720 size they're static once we declare a
03:37:44.960 size we can't change it we're limited to
03:37:47.520 only storing five foods you could
03:37:49.680 declare a larger size but you may be
03:37:51.840 wasting memory if a user doesn't want to
03:37:53.600 type in all 10. so in future topics
03:37:56.000 we'll need to discuss both dynamic
03:37:57.680 memory and vectors which should be
03:38:00.160 coming up sometime in the future so yeah
03:38:02.720 that is one way out of many ways to
03:38:05.120 enter in user input into an array if you
03:38:07.520 would like a copy of this code i'll post
03:38:09.359 this in the comment section down below
03:38:11.279 and well yeah that's how to enter user
03:38:13.520 input into an array using c plus plus
03:38:19.279 hey everybody in this topic i'm going to
03:38:21.040 explain multi-dimensional arrays more
03:38:23.760 specifically 2d arrays it's an array
03:38:26.640 made up of separate arrays they're
03:38:28.720 useful because they can represent a grid
03:38:31.199 or matrix of data with rows and columns
03:38:33.840 here's an example i'll create a
03:38:35.600 two-dimensional array of cars car names
03:38:38.960 the data type will be string
03:38:41.279 i will name this array cars
03:38:43.439 with the rays they have one set of
03:38:45.279 square brackets but if you're creating a
03:38:47.520 two-dimensional array you need two sets
03:38:49.840 of square brackets the first set of
03:38:51.920 square brackets is for the number of
03:38:53.840 rows
03:38:54.800 let's say three in this example
03:38:56.880 the second set of square brackets
03:38:58.399 corresponds to the number of columns if
03:39:00.960 we have three rows and four columns
03:39:03.439 three times four is twelve so that would
03:39:05.600 give us twelve elements
03:39:07.680 if you're initializing your 2d array
03:39:09.920 right away you don't necessarily need to
03:39:12.000 set a row size but you do need a column
03:39:14.720 size i'll just set the amount of columns
03:39:17.279 to be 3 to something small
03:39:19.199 okay so let's fill in the first array
03:39:22.080 this first row will be cars manufactured
03:39:24.800 by ford
03:39:26.080 i'll add a mustang
03:39:29.840 then a ford escape
03:39:35.199 then maybe
03:39:36.399 a ford f150
03:39:39.199 okay this is our first array
03:39:41.760 i'm going to create a second array after
03:39:44.080 the first array i'll add a comma
03:39:46.399 what i like to do i like to organize my
03:39:48.960 2d array kind of like it's a grid
03:39:51.920 so now we have a second array this next
03:39:54.720 array will be cars manufactured by
03:39:57.359 chevrolet
03:39:59.279 i'll pick a corvette
03:40:02.080 then an equinox
03:40:05.439 and a silverado
03:40:08.720 let's add one last array
03:40:12.319 these will be cars manufactured by dodge
03:40:16.840 challenger
03:40:18.720 durango
03:40:22.160 ram 1500
03:40:24.399 all right now to finish this
03:40:25.760 two-dimensional array we will enclose
03:40:28.399 all of these inner arrays with another
03:40:30.720 set of curly braces
03:40:32.560 then add a semicolon to the end that is
03:40:34.960 our two-dimensional array
03:40:36.960 you can see that there's rows and
03:40:38.640 columns
03:40:40.239 in this example each row corresponds to
03:40:42.800 a manufacturer
03:40:44.479 so it's kind of like a grid a matrix
03:40:47.520 then if you were to access one of these
03:40:48.960 elements you need two indices just to
03:40:51.600 demonstrate let's display all of them
03:40:53.840 standard output cars
03:40:59.120 i need to select the row number then the
03:41:01.520 column number row zero
03:41:04.080 column zero let's see what car that is
03:41:07.760 i'm just gonna add a space between these
03:41:09.439 elements
03:41:12.160 okay row zero column zero that's my
03:41:14.479 mustang row zero column zero that's
03:41:17.600 mustang
03:41:19.279 let's print the next element that would
03:41:21.199 be row zero column one
03:41:25.199 that is my ford escape
03:41:27.600 row zero
03:41:28.880 column one i'm just going to zoom out
03:41:31.840 there then we have row zero column two
03:41:37.120 that's the ford f-150 i'm going to
03:41:39.840 display a new line character now we are
03:41:42.000 on row one
03:41:44.160 so let's copy these
03:41:46.399 paste them
03:41:49.520 row one
03:41:51.040 column zero row one column one row one
03:41:54.960 column two
03:41:56.880 so this next row is our car is
03:41:58.960 manufactured by chevrolet we have our
03:42:01.600 corvette
03:42:02.640 our equinox then our silverado
03:42:07.439 then we will display row two
03:42:11.199 row two column zero row two column one
03:42:15.040 row two column two
03:42:18.000 and these are the cars manufactured by
03:42:20.080 dodge we have our challenger durango ram
03:42:23.040 1500
03:42:24.319 so yeah you can see that a
03:42:25.760 two-dimensional array is kind of like a
03:42:27.279 grid made up of rows and columns
03:42:29.760 now if we need to iterate over a
03:42:31.680 two-dimensional array and display the
03:42:33.680 elements here's one way in which we can
03:42:35.520 do that we can use nested loops
03:42:38.399 but just to make it easy i'm going to
03:42:40.000 calculate the amount of rows and columns
03:42:42.160 that we have
03:42:43.199 let's begin with the rows
03:42:44.880 int rows
03:42:46.319 equals
03:42:47.760 size of
03:42:49.359 my array cars
03:42:51.600 divided by the size of one of the
03:42:54.800 elements
03:42:55.760 cars at index 0 is good
03:42:59.680 then to calculate the amount of columns
03:43:01.359 that we have we can do something like
03:43:03.120 this
03:43:04.399 and columns equals the size of
03:43:08.560 cars
03:43:09.920 at index of zero
03:43:12.239 divided by the size of
03:43:14.880 one of the elements so remember there's
03:43:17.199 two indices this time
03:43:19.439 zero zero is good
03:43:22.000 in this example we should have three
03:43:23.520 rows as well as three columns
03:43:26.080 now let's create a for loop to iterate
03:43:28.239 over the rows
03:43:30.080 and i equals zero i will continue this
03:43:33.279 as long as i is less than the number of
03:43:36.080 rows that we have
03:43:37.760 then increment i by one
03:43:40.319 i'm going to display
03:43:43.040 cars at index of i just for the time
03:43:45.920 being
03:43:47.040 then for now i'm just going to add a new
03:43:48.800 line between each
03:43:51.199 so if i was to display cars at index i
03:43:55.120 that should give us three memory
03:43:56.960 addresses
03:43:58.319 one address for every inner array
03:44:01.840 this memory address is for the first
03:44:03.680 array
03:44:04.880 then the second array
03:44:07.520 then the third array
03:44:10.479 what i need to do now to get the
03:44:12.080 elements within each array is to create
03:44:14.239 an inner loop
03:44:16.960 let's use an inner for loop to iterate
03:44:19.199 over each element within each array
03:44:22.640 int j because i is already taken set
03:44:25.520 this equal to zero
03:44:27.600 we will continue this for loop as long
03:44:29.600 as j is less than the number of columns
03:44:32.479 that we have
03:44:33.920 increment j by one
03:44:36.720 now i'm going to display
03:44:40.800 cars and there's two indices
03:44:44.160 i
03:44:45.680 then j
03:44:48.960 i'm going to display a space between
03:44:51.199 each of these
03:44:55.040 okay now we have one long line of text
03:44:58.080 so once we escape the inner for loop i
03:45:00.479 would just like to print a new line
03:45:02.880 i'll add standard output
03:45:06.000 new line character
03:45:10.479 okay and here's our two-dimensional
03:45:12.080 array the first row are for cars
03:45:14.640 manufactured by ford
03:45:16.720 then chevrolet
03:45:18.800 then dodge
03:45:20.160 that's how to iterate over a
03:45:21.600 two-dimensional array you have the outer
03:45:23.920 loop that's in charge of the rows the
03:45:26.080 inner loop which is in charge of the
03:45:27.520 columns so that's a two-dimensional
03:45:29.760 array everybody it's just an array where
03:45:32.479 each element is its own separate array
03:45:35.040 you have two indices the first for the
03:45:37.359 rows the second for the columns
03:45:39.680 to access one of the elements you have
03:45:41.600 to specify the row then the column that
03:45:44.479 element is found
03:45:45.920 so those are two-dimensional arrays your
03:45:48.160 assignment is to post a two-dimensional
03:45:50.239 array in the comments section down below
03:45:52.399 and well yeah those are two dimensional
03:45:54.640 arrays in c plus plus
03:45:59.279 hey everybody in this video we're going
03:46:01.120 to create a quiz game using c plus plus
03:46:03.760 let's begin by creating an array of
03:46:05.439 questions these will be of the string
03:46:07.520 data type i will name this array
03:46:10.319 questions
03:46:12.720 and then let's think of some questions
03:46:14.720 really add any questions that you want
03:46:16.399 here's a few that come into mind for me
03:46:20.160 what year was c plus plus
03:46:25.120 created
03:46:28.000 okay that is the first question i'll add
03:46:30.080 an additional string
03:46:34.160 question two who
03:46:36.960 invented
03:46:38.239 c plus plus
03:46:41.120 third question
03:46:44.239 what is the
03:46:47.199 predecessor
03:46:51.520 of c plus plus
03:46:55.520 and i couldn't think of a fourth
03:46:56.800 question so i'm gonna ask
03:46:59.600 is the earth flat
03:47:02.399 good enough with each question there
03:47:04.399 will be four corresponding options i
03:47:07.359 think a two-dimensional array would be
03:47:08.960 perfect for this
03:47:10.399 this will be a two-dimensional array
03:47:13.439 of strings
03:47:14.800 named options
03:47:17.600 we'll need to set the number of columns
03:47:19.840 four columns is good
03:47:22.399 this first array will be for the options
03:47:24.960 for the first question
03:47:28.479 a will be
03:47:30.080 1969.
03:47:33.199 b
03:47:34.800 1975
03:47:38.080 c
03:47:39.520 1985 1985 is the correct answer
03:47:43.760 d
03:47:45.279 1989
03:47:46.960 now we have our next array who invented
03:47:49.279 c plus plus
03:47:53.840 guido
03:47:55.279 van
03:47:56.319 rossum
03:47:58.160 he's the creator of python so that's not
03:48:00.239 the correct answer
03:48:04.160 yarn
03:48:08.399 stro
03:48:10.479 strip i'm sorry if i mispronounce your
03:48:12.560 name dude hopefully you're not watching
03:48:14.080 right now uh b is the correct answer in
03:48:15.920 this case
03:48:17.920 c
03:48:19.199 john
03:48:21.199 carmack
03:48:23.920 d
03:48:25.840 mark zuckerberg
03:48:31.760 we're on question three
03:48:35.680 what is the predecessor of c plus plus
03:48:39.279 the correct answer is c that would be
03:48:41.520 option a
03:48:47.120 c plus
03:48:51.840 c minus minus
03:48:57.760 or b plus plus
03:49:00.880 okay last question
03:49:03.279 is the earth flat
03:49:06.720 yes
03:49:10.960 no
03:49:15.120 sometimes
03:49:19.439 what's earth
03:49:23.760 all right then i just need to surround
03:49:25.680 all of these arrays with another set of
03:49:27.359 curly braces
03:49:29.760 and there is our two-dimensional array
03:49:31.760 named options to hold all of the options
03:49:34.479 for our questions we'll need to create
03:49:36.640 an answer key next this will be an array
03:49:38.720 of characters
03:49:40.160 answer
03:49:41.920 key
03:49:43.120 array
03:49:44.560 equals
03:49:46.160 here are the correct answers
03:49:48.800 c
03:49:51.199 b
03:49:54.880 a
03:49:57.199 then b
03:49:59.520 1985
03:50:02.000 bjorn strosstrup
03:50:04.239 c
03:50:04.960 the language see that is
03:50:06.720 and no the earth is not flat i looked it
03:50:09.199 up on wikipedia just now let's calculate
03:50:11.600 the size of our questions how many
03:50:13.199 questions do we have
03:50:15.279 and
03:50:16.080 size
03:50:17.120 equals
03:50:18.399 the size of our array questions
03:50:22.080 divided by the size of
03:50:24.640 one of the elements
03:50:26.479 questions at index
03:50:28.720 zero
03:50:30.640 we'll create a character to hold our
03:50:32.479 guess
03:50:34.880 and score to hold the score
03:50:38.800 now we'll need to iterate over our
03:50:40.319 questions
03:50:42.960 for
03:50:44.000 let me move down here
03:50:47.120 and i equals zero we'll continue this as
03:50:50.479 long as i is less than the size of our
03:50:53.439 array the size of questions this would
03:50:56.239 effectively be the amount of questions
03:50:58.000 that we have
03:50:59.680 then i'm going to increment i by one we
03:51:02.399 will iterate once through all of the
03:51:04.319 questions we have
03:51:07.920 standard output
03:51:11.680 let's access the string that's within
03:51:14.399 questions at index i
03:51:17.520 i'll add a new line
03:51:21.840 just for some text decoration i'm going
03:51:24.000 to add a bunch of asterisks before and
03:51:26.000 after the question
03:51:28.479 so let's get rid of this
03:51:31.760 i think that'll look pretty cool
03:51:38.160 there we go then we'll need to iterate
03:51:40.080 over our 2d array
03:51:45.600 we'll use an inner for loop for that
03:51:48.640 we'll need a different index i is
03:51:50.479 already taken let's pick j
03:51:53.120 inch j equals zero we'll continue this
03:51:56.160 as long as j is less than
03:51:59.680 now we'll need to calculate how many
03:52:01.279 elements are within each array
03:52:04.080 so we can do that with
03:52:06.080 size of
03:52:09.120 our options array
03:52:10.960 at index of i
03:52:14.560 divided by the size of
03:52:18.080 options and there's two indices here
03:52:22.160 i
03:52:23.199 then zero
03:52:24.960 then we will increment j
03:52:27.520 by one
03:52:29.359 we will display our options standard
03:52:31.600 output
03:52:32.880 options there's two indices
03:52:35.520 i
03:52:36.960 then j
03:52:38.479 i'll add a new line
03:52:42.640 so if i were to run this this should
03:52:44.399 display all of the questions and all of
03:52:46.720 the options
03:52:50.479 yeah here we are
03:52:52.000 what year was c plus created who
03:52:54.399 invented c plus plus
03:52:56.720 what is the predecessor of c plus plus
03:52:59.359 is the earth flat
03:53:00.880 after all of the options are laid out we
03:53:03.359 will accept some user input standard
03:53:05.920 input
03:53:07.600 we will place the user's input within
03:53:09.680 guess
03:53:11.040 then just in case the user types in
03:53:13.040 something that's lowercase
03:53:14.800 like a lowercase c we're looking for
03:53:16.720 capital c
03:53:18.239 so let's take the user's guess then make
03:53:20.239 it uppercase guess
03:53:22.399 equals
03:53:23.520 to
03:53:24.560 upper
03:53:25.439 pass in guess
03:53:27.760 so that will capitalize the character
03:53:30.239 the user enters in
03:53:32.960 then let's check to see if the user's
03:53:35.359 guess is equal to the answer
03:53:38.160 we'll need to access the answer key
03:53:41.680 at index of i that's the current
03:53:43.840 numbered question
03:53:45.279 if those two values are the same
03:53:48.000 we will display
03:53:49.600 correct
03:53:50.800 i'll add a new line
03:53:53.120 then increment the user score
03:53:55.359 score plus plus
03:53:57.520 else the user's guess is not correct
03:54:01.359 standard output
03:54:03.760 wrong
03:54:06.160 then we will display the correct answer
03:54:08.399 standard output
03:54:11.760 answer colon space
03:54:15.840 we'll access the answer key at index of
03:54:19.439 i
03:54:23.520 then i'll add a new line
03:54:27.840 okay let's try this so far
03:54:30.000 what year was c plus plus created
03:54:33.439 c
03:54:34.239 who invented c plus plus that would be b
03:54:38.160 what is the predecessor of c plus plus
03:54:41.199 that is c the language c but it's option
03:54:43.920 a
03:54:46.640 is the earth flat
03:54:48.239 what's earth d
03:54:50.640 okay wrong answer b
03:54:52.960 okay so we know that we can cycle
03:54:54.640 through the questions
03:54:56.560 outside of the for loop we will
03:54:58.000 calculate the player score so right here
03:55:01.760 i'll display the word results
03:55:04.160 standard output
03:55:08.560 results
03:55:11.199 i'll add a new line
03:55:13.199 actually now that i think of it i'm
03:55:14.399 gonna steal some of these text
03:55:15.840 decorations
03:55:17.840 let's make it look pretty
03:55:25.040 something like this would look cool but
03:55:26.720 not necessary
03:55:29.040 standard
03:55:30.239 output
03:55:33.520 correct
03:55:35.040 guesses
03:55:37.279 then we will display the current score
03:55:40.960 add a new line
03:55:45.120 standard output
03:55:49.120 number of
03:55:50.960 questions
03:55:53.760 that is simply the size of our array
03:55:58.000 add a new line
03:56:00.640 then we will calculate a percentage what
03:56:03.040 percent of the questions did they get
03:56:04.800 right
03:56:08.000 score
03:56:11.439 score divided by
03:56:13.600 size
03:56:18.399 times 100 then we'll add percent
03:56:24.640 so at first this isn't gonna work
03:56:26.399 because we're using integer division but
03:56:28.399 i'll explain that momentarily about
03:56:30.080 typecasting uh so let's run this once
03:56:34.160 let's say a
03:56:35.600 b
03:56:36.399 c
03:56:37.120 d correct guesses one number of
03:56:39.920 questions four uh our score was zero
03:56:42.399 percent even though we got one right
03:56:44.640 we'll need to add a cast to the divisor
03:56:46.960 let's cast size as a double to hold that
03:56:49.920 decimal portion
03:56:52.080 then this should work
03:56:55.600 a b
03:56:57.120 c d
03:56:58.800 correct guesses one number of questions
03:57:01.199 four our score was twenty five percent
03:57:03.520 now let's go for a hundred
03:57:05.760 remember that the correct answers are c
03:57:08.479 b
03:57:09.199 a b
03:57:11.199 1985 bjorn strostrop
03:57:14.399 the language c but that's option a
03:57:17.840 is the earth flat
03:57:19.600 no
03:57:20.479 b
03:57:21.359 correct guesses four number of questions
03:57:23.439 four score one hundred percent well yeah
03:57:25.920 everybody that is a quiz game you can
03:57:28.000 make in c plus plus you can impress your
03:57:30.560 friends or have your friends take the
03:57:32.239 quiz you know you can change your
03:57:33.760 questions around if you want if you
03:57:35.279 would like a copy of this code i'll post
03:57:37.120 this in the comments section down below
03:57:38.960 and that is a quiz game written using c
03:57:41.600 plus
03:57:44.720 hey everybody welcome to the exciting
03:57:46.479 world of memory addresses a memory
03:57:48.720 address is a location in memory where
03:57:51.199 data is stored in c plus a memory
03:57:53.920 address can be accessed with an
03:57:55.680 ampersand known as the address of
03:57:58.160 operator suppose we have some variables
03:58:00.560 i'll create a string
03:58:02.880 the variable name will be well named
03:58:06.239 assign this a string of text
03:58:08.720 i'll create int age set sql to some
03:58:11.520 value
03:58:13.359 then a boolean boolean student i'll set
03:58:17.040 that to be true
03:58:18.640 a variable is a container for some data
03:58:21.600 but these variables need to exist
03:58:23.439 somewhere well they exist in your
03:58:25.199 computer's memory at a given address
03:58:27.920 we can find that address with the
03:58:29.760 address of operator i'll display that
03:58:33.040 standard output
03:58:35.120 i would like to display the address of
03:58:37.760 name
03:58:38.960 then i'll just add a new line
03:58:43.439 here's the address of my name variable
03:58:45.600 in my computer's memory it's a bunch of
03:58:47.760 weird letters and numbers well this is a
03:58:50.239 hexadecimal address every time we run
03:58:52.720 this program
03:58:54.080 that number is likely to change
03:58:56.960 let's display the addresses of agent
03:58:59.199 student
03:59:02.800 address of age address of student
03:59:08.560 here are the memory addresses again all
03:59:10.960 in hexadecimal so these are kind of like
03:59:13.439 street addresses hey for fun let's
03:59:15.520 decode these to decimal you can easily
03:59:17.760 find tools online to convert hexadecimal
03:59:19.840 to decimal
03:59:21.840 let's see what these numbers are
03:59:28.319 here are the hexadecimal memory
03:59:30.000 addresses but converted to decimal
03:59:32.080 they're like house numbers different
03:59:34.160 data types take up more or less room
03:59:36.479 than other data types if we look at the
03:59:38.720 distance between my name variable and
03:59:41.359 age well that has a gap of four memory
03:59:43.920 addresses but the gap between my age and
03:59:46.720 student variables
03:59:48.160 is only one because well booleans only
03:59:50.960 take up one byte of memory that's one of
03:59:53.120 the reasons we use data types we need to
03:59:55.279 know how much memory we need to allocate
03:59:57.359 to fit a certain value if we're working
03:59:59.760 with a boolean variable well we only
04:00:02.160 need one byte of memory that's why the
04:00:04.640 distance between the memory address of
04:00:06.640 age and student is only one forty minus
04:00:09.520 thirty nine is one integers take up four
04:00:12.319 bytes of memory 44 minus forty is four
04:00:15.920 four bytes so that's an introduction to
04:00:18.479 memory addresses it's going to be
04:00:20.319 helpful in the next topic when we
04:00:21.920 discuss pointers if you would like a
04:00:23.840 copy of this code i'll post this in the
04:00:25.680 comments section down below and that is
04:00:27.520 an introduction to memory addresses in c
04:00:30.399 plus
04:00:33.120 all right everybody so i'm gonna explain
04:00:35.199 the differences between pass by value
04:00:37.439 and pass by reference in this example
04:00:39.840 we'll swap two variables suppose we have
04:00:42.560 two imaginary cups
04:00:45.040 i'll name the first cup x x will contain
04:00:48.640 kool-aid
04:00:51.680 then we have
04:00:53.040 cup y
04:00:54.399 which contains water
04:00:56.399 i need to swap these two values
04:00:58.880 will need the help of a temporary
04:01:00.560 variable
04:01:04.319 at temp
04:01:05.279 to swap two variables we would assign a
04:01:07.600 temp equal to x
04:01:10.319 x equals y
04:01:12.960 y equals temp let's display these
04:01:15.359 variables standard output
04:01:19.760 x
04:01:22.319 the variable x
04:01:24.479 i'll add a new line
04:01:26.800 let's copy this paste it
04:01:32.319 y
04:01:33.120 the variable y this should work
04:01:36.800 x now contains water y contains kool-aid
04:01:39.600 now check this out what if we create a
04:01:41.199 function to swap two variables for us
04:01:44.640 the return type will be void
04:01:46.800 i'll name this function swap
04:01:49.120 there will be two parameters
04:01:52.399 string x
04:01:55.680 string y
04:01:57.520 let's copy this section of code delete
04:02:00.640 it
04:02:02.000 then paste it within the swap function
04:02:04.239 then you'll need a function declaration
04:02:06.319 at the top of your program then we will
04:02:08.640 invoke this function
04:02:10.720 swap
04:02:11.680 pass our arguments
04:02:13.439 x and y
04:02:15.760 let's see what happens
04:02:19.600 okay what the heck x still contains
04:02:22.000 kool-aid y still contains water these
04:02:24.800 values weren't switched within my
04:02:26.479 variables x and y even though we invoked
04:02:28.960 this function so why didn't it work well
04:02:30.960 that's because normally when we pass a
04:02:33.040 variable to a function we're passing by
04:02:35.760 value when we invoke this function we're
04:02:38.160 creating copies of the original values
04:02:40.800 what we have now are two copies of the
04:02:43.199 variable x and y and all we're doing is
04:02:46.000 switching the two copies and not the
04:02:48.479 original values so that's passed by
04:02:50.720 value we're creating copies of the
04:02:52.960 arguments if i need to change the
04:02:54.960 original values of these variables i
04:02:57.199 could instead pass by reference a
04:02:59.520 reference as in a memory address an
04:03:02.000 address in your computer's memory where
04:03:03.840 a value is located i will prefix the
04:03:06.800 address of operator which is an
04:03:08.720 ampersand to these parameter names
04:03:11.359 then add that to your function
04:03:12.560 declaration as well now let's see what
04:03:14.800 happens
04:03:16.640 yeah those two variables were switched x
04:03:19.040 contains water y contains kool-aid when
04:03:21.439 we passed by value we created copies of
04:03:24.080 x and y with the parameters when we use
04:03:26.560 the addressof operator we're passing
04:03:28.720 memory addresses to where the original x
04:03:31.279 and y variables are located and then
04:03:33.279 swapping the values just to reinforce
04:03:35.520 this idea let's revert to passing by
04:03:38.080 value i'm going to display the address
04:03:41.120 of x and y
04:03:42.880 then within our swap function
04:03:44.880 let's get rid of this code
04:03:46.800 then i will also display the addresses
04:03:48.880 of x and y
04:03:51.359 see we have four different addresses our
04:03:53.760 original x variable has a different
04:03:56.319 memory address than the one that's
04:03:58.080 within the function
04:03:59.520 same thing goes with y these two
04:04:01.359 addresses are different we have two x
04:04:04.000 variables and two y variables
04:04:06.399 originally within that swap function we
04:04:08.319 were switching the values of the x and y
04:04:11.040 copies if we instead pass by reference
04:04:14.399 let's use that address of operator again
04:04:18.479 well now x and y are referring to the
04:04:20.560 same place they have the same memory
04:04:22.399 addresses that's why the swap function
04:04:24.560 worked when we passed by reference in
04:04:26.479 place of pass by value so that's the
04:04:28.239 main difference between pass by value
04:04:30.080 and pass by reference you should use
04:04:32.000 pass by reference as often as possible
04:04:34.239 unless you have a reason to pass by
04:04:35.840 value if you would like a copy of this
04:04:37.600 code i'll post this in the comment
04:04:39.199 section down below and well yeah that's
04:04:41.199 the main difference between pass by
04:04:42.880 value and pass by reference in c plus
04:04:48.960 hey everyone in this topic i'm going to
04:04:50.720 explain const parameters a const
04:04:53.520 parameter is a parameter that is
04:04:55.680 modified with a const keyword that makes
04:04:57.840 it effectively read-only there's a
04:04:59.920 couple reasons why you might want to
04:05:01.279 declare a const parameter your code is
04:05:03.840 more secure within a function and it
04:05:06.239 conveys the intent to other programmers
04:05:08.560 it's especially useful for references
04:05:10.720 and pointers here's an example of const
04:05:13.199 parameters in action
04:05:14.880 i have standard string name assign your
04:05:18.319 first name
04:05:20.800 then int
04:05:22.399 age whatever your age is
04:05:25.040 then suppose i have a function to print
04:05:27.199 my info
04:05:28.720 void print
04:05:30.479 info
04:05:31.840 and there will be two parameters
04:05:34.399 standard string name
04:05:36.960 int age
04:05:38.720 be sure to add a function declaration if
04:05:40.560 you're missing it
04:05:42.479 then if i need to call this function i
04:05:44.080 would invoke the function name
04:05:45.920 pass in my arguments
04:05:47.680 name age
04:05:50.239 then we can print our info
04:05:52.239 standard
04:05:53.439 output
04:05:54.880 name
04:05:59.600 standard output
04:06:01.840 age
04:06:05.359 this of course does what you expect
04:06:07.840 it prints our name and our age
04:06:10.239 to make this function more secure we can
04:06:12.640 instead use const parameters that means
04:06:15.199 that we can't change the values that we
04:06:16.800 receive name and age in this case just
04:06:19.279 as a test let's set name equal to an
04:06:21.680 empty space
04:06:23.199 and age equals zero
04:06:25.359 i don't want this to be able to happen
04:06:26.720 at all now when i run this
04:06:29.600 we don't have a name and we don't have
04:06:31.120 an age to make these parameters
04:06:33.279 read-only we can precede the parameters
04:06:35.760 with that const keyword const string
04:06:38.840 name const int age
04:06:42.399 and you would probably want to add that
04:06:43.760 to your function declaration as well
04:06:47.040 just to display intent
04:06:50.399 there we have an error assignment of
04:06:52.399 read-only parameter age and name is
04:06:55.439 somewhere up here but i don't feel like
04:06:56.960 reading all that when we pass our string
04:06:59.120 and our integer as arguments what we're
04:07:01.120 doing is effectively making a copy of
04:07:03.199 name and age technically we're not
04:07:05.199 modifying the original variables in this
04:07:07.760 case using the const keyword when we
04:07:10.000 pass a variable by value isn't really
04:07:12.319 that big of a deal but it at least
04:07:14.319 conveys intent if we were working with
04:07:16.560 reference data types
04:07:19.840 now we'll pass by reference well now
04:07:21.760 it's a bigger deal we don't want anybody
04:07:23.760 modifying the original name and age
04:07:25.840 variables alright everybody those are
04:07:28.160 const parameters they are parameters
04:07:30.560 modified by the const keyword that
04:07:32.479 effectively make them read-only within a
04:07:35.040 function your code is more secure and it
04:07:37.040 conveys intent it tells other
04:07:38.720 programmers hey don't mess with these
04:07:40.640 values they're useful with references so
04:07:43.040 that nobody can change the value found
04:07:45.199 at that reference then in the case of
04:07:46.960 pointers nobody can change the address
04:07:49.199 of where a pointer is pointing to so
04:07:51.279 yeah those are const parameters in c
04:07:53.920 plus
04:07:56.720 hey everybody in this topic we're going
04:07:58.399 to create a program to validate if a
04:08:00.159 credit card number is valid or not to do
04:08:02.399 so we'll need to utilize the loon
04:08:04.479 algorithm which i've broken into these
04:08:06.399 steps if you need some test credit card
04:08:08.319 numbers you can always google them i
04:08:10.000 found a bunch on this website let's just
04:08:12.000 take this one for example
04:08:14.239 and to make this more readable i'll
04:08:15.760 divide this number into groups of four
04:08:22.080 step one we double every second digit
04:08:24.720 from right to left if the double number
04:08:27.359 is two digits split them i'm only
04:08:29.760 concerned with every second digit from
04:08:31.760 right to left so we can eliminate some
04:08:33.920 of these that we won't be using
04:08:39.680 then we're going to double these numbers
04:08:41.920 so two doubled as four
04:08:44.159 nine doubled as 18. since we have the
04:08:46.479 number 18 that's two digits we need to
04:08:49.120 split them we'll split 18 to 1 and 8.
04:08:58.319 then 6 doubled is 12. we'll split that
04:09:01.279 step 2 we need to add all of these
04:09:03.120 numbers together to create a sum
04:09:12.800 the sum is 29. step three add all odd
04:09:16.239 number digits from right to left with
04:09:18.159 the original number
04:09:19.920 so now we're only concerned with the odd
04:09:22.560 numbers
04:09:28.640 then we just add these numbers together
04:09:30.399 no need to double them
04:09:36.399 the sum is 21.
04:09:38.479 step four we sum the results of steps 2
04:09:41.439 and steps 3
04:09:42.960 29 plus 21 that equals 50.
04:09:46.720 step 5 if step 4 is divisible by 10 that
04:09:50.080 number is valid we could say our result
04:09:53.439 modulus 10
04:09:55.120 if that number is divisible by 0
04:09:57.680 that number is valid 50 is divisible by
04:10:00.319 10 so that number is valid
04:10:02.880 we'll create a program that will do all
04:10:04.399 of this for us
04:10:07.040 let's create our functions
04:10:08.800 we'll need three int get
04:10:11.840 digit
04:10:14.319 the parameter will be a constant
04:10:17.120 integer that i will name number
04:10:21.600 int
04:10:22.640 will need to sum the odd digits
04:10:28.080 the parameter is const
04:10:30.640 standard
04:10:31.840 string
04:10:33.120 card
04:10:34.239 number
04:10:35.920 let's copy this paste it
04:10:38.560 sum
04:10:39.760 even digits the parameter is the same
04:10:43.840 let's copy these functions and add some
04:10:45.760 declarations
04:10:49.520 we do need to return something otherwise
04:10:52.479 we'll get a warning for the time being
04:10:54.239 i'm just going to return xero as a
04:10:56.319 placeholder
04:10:58.960 okay let's begin with the main function
04:11:00.800 we'll need a credit card number that
04:11:02.239 will be a string
04:11:04.000 standard string
04:11:05.520 card
04:11:06.880 number
04:11:09.439 then int result and i will set that
04:11:12.159 equal to zero right away
04:11:14.560 we'll prompt the user to enter in their
04:11:16.239 credit card number
04:11:17.920 standard
04:11:18.840 output enter a credit card number
04:11:25.279 standard
04:11:26.640 input
04:11:29.040 card
04:11:30.080 number
04:11:32.840 result equals
04:11:35.199 will invoke the sum even digits function
04:11:39.920 pass in our card number
04:11:44.319 plus
04:11:45.840 some odd digits
04:11:47.600 pass in our card number
04:11:52.479 we'll need to fill in these functions
04:11:54.080 let's begin with some even digits
04:11:58.000 we can get rid of this
04:11:59.920 i'll create a local variable named sum
04:12:02.800 to keep track of the sum
04:12:04.880 what we'll need to do is iterate over
04:12:07.040 our card number in reverse order we can
04:12:09.840 treat a string as an array of characters
04:12:12.560 and we can iterate over that
04:12:14.720 so we'll need a for loop
04:12:16.800 and we will iterate over this card
04:12:18.640 number in reverse order starting from
04:12:20.960 the end
04:12:22.159 we'll need an index into i
04:12:24.560 equals
04:12:25.840 then we'll need to find the size of our
04:12:27.600 card number
04:12:28.880 there's a built-in function for that
04:12:31.120 card number dot size
04:12:33.359 now arrays they always start with zero
04:12:35.520 so we're going to subtract one however
04:12:38.319 if we're summing the even digits
04:12:40.560 beginning from the right we'll need the
04:12:42.800 second to last digit so that would
04:12:44.960 actually be minus two the very last
04:12:47.920 digit would be minus one
04:12:50.000 our index i will begin from the second
04:12:52.399 to last position i would like to
04:12:54.319 continue this for loop as long as i is
04:12:57.120 less than or equal to zero
04:13:00.239 then we will decrement i by two i minus
04:13:03.920 equals two because we need every even
04:13:06.800 digit
04:13:07.840 so we will take sum plus equals
04:13:11.359 then invoke the get digit function
04:13:15.359 get digit
04:13:16.960 within the get digit function as an
04:13:19.120 argument we're going to pass in card
04:13:21.840 number
04:13:23.120 at index of
04:13:24.840 i times two however there's one more
04:13:28.399 thing that we'll need to do
04:13:29.920 with card number at index of i we will
04:13:32.880 subtract
04:13:34.239 the character zero and here's why we're
04:13:37.680 currently working with a string of
04:13:39.279 characters you can also treat a string
04:13:41.439 as an array of characters each character
04:13:43.920 according to the ascii table has an
04:13:46.000 associated integer value a decimal value
04:13:49.520 if i'm passing one of these characters
04:13:51.199 as an argument to my get digit function
04:13:53.520 we'll treat that character as if it was
04:13:55.279 its decimal equivalent according to the
04:13:57.680 ascii table the character 0 has a
04:14:00.560 decimal value of 48 the character 1 is
04:14:03.359 49 2 is 50 then all the way up to 9
04:14:06.880 which has a decimal value of 57 so if
04:14:09.920 i'm passing in the character at index of
04:14:12.800 i what we'll end up working with is the
04:14:15.040 decimal representation of that character
04:14:18.000 if we subtract the character 0 or its
04:14:20.560 equivalent 48 that would give us a range
04:14:23.359 of numbers zero through nine for example
04:14:26.000 the decimal equivalent of the character
04:14:28.080 9 is 57
04:14:29.840 57
04:14:31.040 minus 48 would be 9. you could subtract
04:14:34.720 either 48 or the character zero that
04:14:37.199 would give us numbers zero through nine
04:14:39.359 according to the ascii table
04:14:41.120 then we're multiplying that number by
04:14:42.800 two
04:14:43.680 then at the end we will return whatever
04:14:46.000 the sum is
04:14:47.600 let's fill in this get digit function
04:14:50.080 within the get digit function the digit
04:14:52.080 that we're working with was doubled
04:14:54.479 whatever number we passed in
04:14:56.479 it may take two digits for example like
04:14:58.720 nine times two is eighteen we need to
04:15:01.040 split those two numbers to get one and
04:15:02.960 eight
04:15:03.760 so i'm going to return
04:15:05.840 number
04:15:07.199 modulus 10
04:15:09.359 plus
04:15:11.439 number
04:15:12.960 divided by 10
04:15:14.880 modulus 10. that will split the two
04:15:17.040 numbers for example let's say our number
04:15:19.920 that we're passing in as an argument is
04:15:21.920 eighteen
04:15:23.120 nine
04:15:24.000 times two
04:15:25.199 eighteen modulus ten would give us eight
04:15:29.279 eighteen divided by ten that would give
04:15:32.960 us one since we're using integer
04:15:34.720 division
04:15:35.760 one
04:15:36.560 modulus ten
04:15:38.239 is one
04:15:40.239 eight plus one
04:15:42.000 is nine
04:15:43.600 then we're just returning that number
04:15:45.359 nine okay that is the get digit function
04:15:48.960 then we need to sum the odd digits
04:15:52.080 and really we can just copy all this
04:15:54.640 then paste it
04:15:58.479 but there's a couple changes to make
04:16:00.880 int i equals card number dot size
04:16:03.520 function minus one we need to begin at
04:16:05.920 the end
04:16:06.800 and then sum plus equals
04:16:09.680 card number minus zero
04:16:12.560 when summing the odd digits there's no
04:16:14.720 need to double the odd digits that's
04:16:17.120 only with the even digits
04:16:19.279 and that is all the functions let's
04:16:20.800 close out of these
04:16:24.560 so we'll have a result the sum of the
04:16:26.560 even digits plus the sum of the odd
04:16:28.880 digits
04:16:29.840 if result is divisible by 10 that number
04:16:32.880 is valid
04:16:35.359 if
04:16:36.880 result
04:16:39.760 modulus 10 is equal to zero
04:16:46.560 then that number is valid standard
04:16:48.560 output
04:16:50.399 card number
04:16:53.760 is valid
04:16:58.640 else
04:17:02.000 card number is not valid
04:17:06.479 okay let's try this
04:17:08.000 i'm going to enter in that original
04:17:09.600 number that we worked with that discover
04:17:11.520 card
04:17:15.279 okay enter a credit card number i'm
04:17:17.359 going to paste this hit enter
04:17:20.080 that number is valid let's try that
04:17:22.720 again
04:17:25.359 so i'm going to enter in the same card
04:17:27.199 number except i'll add one to the end
04:17:33.120 that number is not valid hey if you have
04:17:36.000 your own credit cards feel free to try
04:17:37.439 them too and see if it works
04:17:39.040 all right everybody that is a credit
04:17:41.120 card validation program mostly for
04:17:43.040 practice
04:17:44.159 if you would like a copy of this code
04:17:45.680 i'll post this in the comments section
04:17:47.120 down below please be sure that you do
04:17:49.120 not enter in your own credit card into
04:17:50.880 the comment section and well yeah that
04:17:52.960 is a credit card validation program
04:17:55.040 using c plus
04:17:58.720 all right everybody we finally made it
04:18:00.800 to pointers a pointer is just a variable
04:18:04.000 that stores a memory address of another
04:18:06.399 variable that's it the reason that we
04:18:08.560 use pointers is because well sometimes
04:18:11.199 it's just easier to work with an address
04:18:13.359 here's an example i have a stack of
04:18:15.920 maybe 20 pizzas that i'm going to give
04:18:18.319 out for free to my neighborhood instead
04:18:20.080 of going around house to house carrying
04:18:22.000 the free pizza and handing it out it's a
04:18:23.840 lot easier to go door to door and tell
04:18:26.319 people where the pizza is located hey
04:18:28.720 there's free pizza at my house at this
04:18:31.040 address come and get some and that's one
04:18:33.040 of the uses of pointers sometimes it's
04:18:35.199 easier to just work with an address i'll
04:18:37.359 tell people where the free pizza is
04:18:39.279 rather than carry it around with me so
04:18:41.199 when working with pointers we'll need to
04:18:43.040 use the address of operator which is an
04:18:45.359 ampersand as well as the d reference
04:18:47.920 operator which is an asterisk let's
04:18:50.000 begin with the name i'll create a
04:18:51.600 pointer to a name
04:18:53.600 standard
04:18:54.640 string name
04:18:56.479 assign your first name
04:18:59.199 then we'll create a pointer to name
04:19:01.199 where is my name located in my
04:19:03.040 computer's memory to create a pointer it
04:19:04.960 should be of the same data type as the
04:19:06.960 variable it's pointing to
04:19:09.439 i'm creating a pointer to a string
04:19:11.680 this pointer will be of the string data
04:19:13.439 type
04:19:14.479 then type
04:19:15.600 asterisk
04:19:16.800 that dereference operator then a common
04:19:19.199 naming convention for pointers is you
04:19:21.199 type p
04:19:22.560 then the variable name
04:19:24.319 but i'm going to make the first letter
04:19:25.920 uppercase
04:19:27.279 i will set this pointer equal to the
04:19:30.239 address of that name variable
04:19:33.520 and there we go we have a pointer so if
04:19:35.760 i was to display this pointer standard
04:19:38.399 output
04:19:40.720 p
04:19:41.600 name
04:19:43.279 my pointer contains this value it
04:19:46.080 contains a memory address as its value
04:19:49.040 to access the value at this address you
04:19:51.760 would use the dereference operator
04:19:57.439 i'm accessing the value of that address
04:20:00.159 that's stored within this pointer which
04:20:02.319 contains my first name by using this d
04:20:04.640 reference operator i'm accessing the
04:20:06.960 value that's at this given address which
04:20:09.520 contains my first name let's create a
04:20:11.520 couple other pointers
04:20:15.040 let's create
04:20:16.479 a variable age into age equals make up
04:20:20.080 some age
04:20:21.840 i'll create a pointer to age
04:20:24.000 the data type of the pointer should be
04:20:25.600 the same as the variable
04:20:27.520 int dereference operator
04:20:30.399 p
04:20:31.439 age
04:20:32.560 equals the address
04:20:35.120 of age
04:20:38.479 then let's display
04:20:41.040 whatever value is located at the address
04:20:44.800 that's stored within my pointer of ph
04:20:50.880 so we have my first name and then an age
04:20:53.760 i think i'm just going to add a new line
04:20:54.960 real quick
04:20:58.000 going back to that analogy with the free
04:20:59.760 pizzas
04:21:00.800 i'll create an array
04:21:03.199 an array of strings
04:21:05.359 i'll name this array
04:21:06.960 free pizzas
04:21:09.439 i'll give this a size of five
04:21:14.159 we have pizza one
04:21:18.479 pizza two
04:21:20.080 pizza three pizza four
04:21:24.319 then pizza five
04:21:26.800 like i said in my example it's a lot
04:21:29.040 easier instead of carrying around five
04:21:31.279 free pizzas house to house giving away
04:21:33.680 pizza i can just tell people where the
04:21:36.159 pizza is located i'll give them an
04:21:38.000 address i'll create a pointer to this
04:21:40.000 array we'll use the same data type we're
04:21:42.159 storing strings
04:21:45.760 d reference operator
04:21:47.680 p
04:21:48.880 free pizzas
04:21:52.479 now i'm going to attempt to set this to
04:21:54.880 the address
04:21:56.239 of free pizzas
04:21:58.800 now we're going to run into a problem
04:22:02.479 my array is already an address
04:22:05.439 so i don't need to use the address of
04:22:07.279 operator
04:22:08.319 let me demonstrate
04:22:13.040 i will display see out
04:22:16.159 free
04:22:17.439 pizzas
04:22:25.840 when accessing my array free pizzas it's
04:22:28.479 already a memory address if i display
04:22:30.800 the value contained within my pointer to
04:22:33.359 my free pizzas
04:22:35.520 it's going to be a memory address then
04:22:37.439 if i was to use the dereference operator
04:22:42.560 that would give me the first element
04:22:44.000 within that array pizza one so those are
04:22:46.880 pointers it's a variable that stores a
04:22:49.680 memory address of another variable
04:22:52.000 sometimes it's easier to work with an
04:22:53.840 address instead of carrying five free
04:22:56.080 pizzas with me and going house to house
04:22:58.239 giving it away i'll just tell people
04:23:00.239 where the free pizza is so those are
04:23:02.319 pointers your assignment is to post a
04:23:04.880 pointer in the comment section down
04:23:06.479 below and well yeah that's an
04:23:08.399 introduction to pointers in c plus
04:23:14.000 what's up everybody so let's talk about
04:23:15.920 null pointers but first we'll need to
04:23:18.000 know what a null value is a null value
04:23:20.960 is a special value that means that
04:23:22.960 something has no value when a pointer is
04:23:25.600 holding a null value that means that
04:23:27.760 pointer is not pointing to anything
04:23:29.600 that's what we would call a null pointer
04:23:31.840 there is a keyword that represents that
04:23:34.000 null ptr ptr meaning pointer it's a
04:23:37.120 keyword that represents a null pointer
04:23:39.920 literal one of the reasons that we use
04:23:41.840 null pointers is that they're helpful
04:23:43.520 when determining if an address was
04:23:45.520 successfully assigned to a pointer if we
04:23:48.000 create a pointer but don't assign it a
04:23:50.000 value we don't know where it's pointing
04:23:51.840 to it would be good practice that that
04:23:53.760 pointer doesn't point anywhere so let's
04:23:55.840 create a null pointer i'll create a
04:23:57.600 pointer of the int data type we use the
04:24:00.239 dereference operator
04:24:02.080 pointer
04:24:03.199 if i'm not going to assign this pointer
04:24:05.040 and address right away it would be good
04:24:07.040 practice to assign this pointer
04:24:09.680 null
04:24:10.399 ptr
04:24:11.520 null pointer
04:24:12.880 later on in your program if you need to
04:24:14.479 assign an address
04:24:15.920 let's say int x equals one two three
04:24:19.279 i would just take
04:24:20.720 my pointer
04:24:22.000 set the sequel to
04:24:24.399 the address of my variable
04:24:27.520 if you dereference a null pointer it can
04:24:30.080 lead to undefined behavior
04:24:32.159 or if you dereference a pointer that's
04:24:34.560 not assigned a value well that can lead
04:24:36.720 to undefined behavior too
04:24:38.479 what some programmers do is that they'll
04:24:40.399 check to see if their pointer is a null
04:24:42.399 pointer before continuing kind of like a
04:24:44.479 system of checks and balances
04:24:46.319 we assigned our pointer the address of x
04:24:48.960 i would like to check to see if my
04:24:50.399 pointer contains a valid address before
04:24:52.399 dereferencing it
04:24:54.479 so we could say pointer
04:24:57.760 equals
04:24:58.960 null
04:25:00.000 pointer
04:25:01.120 was my pointer assigned an address or is
04:25:03.199 it still a null pointer
04:25:06.720 if my pointer is still a null pointer
04:25:08.960 that means we did not successfully
04:25:10.640 assign an address to my pointer there
04:25:12.720 may be situations such as when working
04:25:15.040 with dynamic memory where you attempt to
04:25:17.040 assign an address to your pointer and it
04:25:18.800 fails this would be a good way to check
04:25:20.800 to see if that failed or not if your
04:25:22.880 pointer still remains a null pointer
04:25:25.359 so let's say address was not assigned
04:25:32.319 else
04:25:34.880 standard output
04:25:38.319 address was assigned
04:25:43.520 so let's run this
04:25:44.880 currently our pointer is pointing to the
04:25:47.120 address of x
04:25:51.760 address was assigned now if for some
04:25:54.080 reason we did not assign an address
04:25:56.560 i'll turn this line into a comment to
04:25:58.080 represent that well our pointer is still
04:26:00.319 going to be a null pointer
04:26:03.760 address was not assigned
04:26:05.840 if your pointer is still a null pointer
04:26:08.399 it's not safe to dereference that
04:26:10.080 pointer
04:26:11.199 if i need access to the value that's at
04:26:13.120 that pointer it would be safe to do so
04:26:15.359 within this else statement
04:26:17.760 standard output
04:26:20.479 dereference operator
04:26:22.720 pointer
04:26:28.880 so my pointer contains the number one
04:26:30.800 two three if i were to dereference this
04:26:33.199 null pointer that would lead to
04:26:34.800 undefined behavior i have no idea what's
04:26:36.880 gonna happen
04:26:38.720 don't try this at home kids
04:26:44.000 null pointer is a keyword that
04:26:45.680 represents a null pointer literal when
04:26:48.399 declaring a pointer it's good practice
04:26:50.399 that our pointer is pointing to a valid
04:26:52.399 address
04:26:53.359 or this null pointer keyword because
04:26:55.680 otherwise we don't know where it's
04:26:56.960 pointing originally they're helpful when
04:26:59.040 determining if an address was
04:27:00.800 successfully assigned to a pointer when
04:27:03.199 using pointers be careful that your code
04:27:05.040 isn't dereferencing a null pointer or
04:27:07.600 pointing to any free memory that we're
04:27:09.279 not using because that can lead to
04:27:11.279 undefined behavior
04:27:12.720 so yeah everybody those are null
04:27:14.399 pointers in c plus
04:27:19.760 hey guys in this topic we're going to
04:27:21.520 create a game of tic-tac-toe we'll be
04:27:23.680 working with random numbers you may or
04:27:25.520 may not need to include this header file
04:27:27.600 include
04:27:29.760 c
04:27:30.560 time we'll add some function
04:27:32.479 declarations then some definitions
04:27:34.960 void
04:27:36.319 draw
04:27:37.199 board
04:27:38.479 there will be one parameter
04:27:40.640 a pointer to an array named spaces
04:27:44.479 spaces will be a one-dimensional array
04:27:46.560 that will keep track of all the markers
04:27:48.319 like what spots are taken what spots are
04:27:50.319 occupied
04:27:54.159 player move
04:27:57.680 the parameters will be a pointer to
04:27:59.920 spaces
04:28:01.359 and char
04:28:02.800 player
04:28:05.680 computer
04:28:06.840 move
04:28:08.399 a pointer to spaces
04:28:10.960 char
04:28:11.920 computer
04:28:15.120 check winner
04:28:17.279 a pointer to spaces
04:28:19.359 char player
04:28:20.880 and char computer
04:28:24.319 then lastly
04:28:27.040 check
04:28:28.000 tie
04:28:29.520 and all we need is a pointer to our
04:28:31.439 array spaces
04:28:33.279 oh uh check winner and check tie will
04:28:36.000 both return a boolean value
04:28:40.560 okay let's add some function
04:28:42.159 declarations so after the main function
04:28:44.640 let's paste these
04:28:53.840 we do need to return some value for
04:28:55.920 check winner and check tie because there
04:28:57.520 is a return type just for now as a
04:28:59.680 placeholder i'm going to return zero
04:29:04.239 but we'll change that later
04:29:06.159 let's head to the main function and
04:29:07.520 declare everything that we'll need
04:29:09.920 a character array named spaces
04:29:14.319 the size will be nine nine spaces
04:29:18.319 will have nine elements each contains an
04:29:20.319 empty space
04:29:30.800 one two three four five six seven eight
04:29:33.680 nine good
04:29:36.159 char player
04:29:38.239 pick a character that you'd like to be
04:29:40.479 you could do x or something else
04:29:46.239 computer
04:29:48.000 pick a character for the computer
04:29:50.640 let's begin with o
04:29:54.560 boolean
04:29:55.760 running i'll set the sequel to true
04:29:58.560 when we begin our game we will
04:30:00.080 immediately invoke the drawboard
04:30:02.319 function
04:30:04.000 then pass in our array
04:30:06.159 so remember when we pass an array to a
04:30:08.399 function it decays into a pointer
04:30:11.600 so we don't need to create a pointer for
04:30:13.279 this array
04:30:14.479 within the dropboard function we will
04:30:16.399 display a grid
04:30:18.960 so let's write something like this
04:30:21.359 standard output
04:30:23.199 i'll add five spaces one two three four
04:30:26.479 five then a vertical bar
04:30:28.960 five spaces again one two three four
04:30:31.600 five
04:30:33.120 vertical bar
04:30:34.560 one two three four five
04:30:37.680 then a new line
04:30:41.600 okay let's copy this line
04:30:45.359 right in the middle i'm going to add one
04:30:47.199 of the elements of our array spaces
04:30:49.520 so right about there
04:30:53.760 spaces at index zero
04:30:59.120 i'm going to copy this section of code
04:31:02.159 right in the middle between the two
04:31:03.439 vertical bars i'll paste what we copied
04:31:06.239 spaces at index one
04:31:09.279 then again right in the middle
04:31:12.800 paste what you have
04:31:14.399 spaces at index 2.
04:31:18.399 this time we'll create a horizontal bar
04:31:21.520 let's copy this
04:31:23.279 we'll replace the spaces with
04:31:25.120 underscores
04:31:26.960 so right about there
04:31:35.439 okay let's see what we have
04:31:38.720 okay yeah something like this
04:31:40.560 we'll have a player or the computer
04:31:42.159 right in the center
04:31:44.560 so let's copy this line on top
04:31:47.520 paste it underneath
04:31:49.199 copy this line that displays elements of
04:31:51.040 our array
04:31:53.040 paste it underneath but change the
04:31:54.960 element numbers
04:31:56.319 three
04:31:57.520 four
04:31:58.960 five
04:32:00.000 then we'll copy this line
04:32:03.359 paste it
04:32:04.840 underneath let's double check to see
04:32:06.960 what we have
04:32:08.720 okay we're getting somewhere
04:32:10.720 let's copy this line
04:32:13.199 paste it
04:32:15.439 copy one of these lines where we display
04:32:17.199 the elements of the array
04:32:21.760 paste it underneath
04:32:23.840 so we are missing
04:32:25.680 elements six
04:32:27.920 seven
04:32:29.520 eight
04:32:32.720 let's copy one of these empty lines
04:32:36.479 paste it underneath
04:32:38.800 uh then before and after we display this
04:32:40.960 grid i'll just display a new line
04:32:43.279 standard output
04:32:45.840 new line
04:32:47.600 and let's do that after
04:32:52.720 okay let's see what we have
04:32:58.319 yeah not too bad there's our grid of
04:33:00.399 nine spaces okay that is the drawboard
04:33:03.760 function we can close out of this we're
04:33:05.359 done with it when we invoke the
04:33:07.199 drawboard function we will pass in our
04:33:09.199 array which decays to a pointer and then
04:33:12.240 prints our board
04:33:13.680 let's add a while loop after the
04:33:15.039 drawboard function
04:33:16.958 while
04:33:17.840 our condition is running running is set
04:33:20.160 to true initially
04:33:22.240 when we exit out of the game we'll set
04:33:23.919 running to be false
04:33:25.520 the first thing that we'll do is invoke
04:33:27.199 the player move function
04:33:29.118 player move but we need to pass in our
04:33:32.160 array spaces
04:33:34.240 as well as a player
04:33:36.000 player
04:33:37.199 then let's fill in the player move
04:33:38.958 function
04:33:40.799 okay player move
04:33:42.561 i'll create a local variable named
04:33:44.480 number
04:33:45.919 the user will enter in a number between
04:33:48.160 one and nine depending on what space
04:33:50.561 they'd like to occupy with their marker
04:33:52.480 i'll create a do while loop
04:33:54.561 do
04:33:55.840 while
04:33:57.039 the condition will be
04:33:59.438 not
04:34:00.561 number
04:34:01.919 is greater than zero
04:34:04.320 or
04:34:05.359 not
04:34:06.320 number
04:34:07.520 is less than eight
04:34:09.680 the user can only enter in a number
04:34:11.520 between
04:34:12.400 0 and 8. those numbers correspond to the
04:34:15.438 elements of our array elements with
04:34:17.438 indices 0 through 8.
04:34:19.840 within the do while loop we'll ask for
04:34:21.840 some user input standard output
04:34:26.320 enter a spot
04:34:29.520 to place a marker
04:34:32.799 one through nine
04:34:34.240 whatever the user types in we'll just
04:34:35.680 subtract one because the user doesn't
04:34:37.840 know that arrays start with zero
04:34:39.438 supposedly
04:34:41.599 standard input
04:34:44.080 number
04:34:45.680 so the user will enter in a number
04:34:47.438 between one and nine
04:34:49.359 then we will decrement the number by one
04:34:52.080 because the array starts with zero
04:34:57.680 if
04:34:59.199 spaces
04:35:00.561 at index of number whatever the user
04:35:03.438 types in
04:35:04.561 is equal to an empty space
04:35:07.118 if that space isn't occupied
04:35:09.759 we'll add that marker to that spot
04:35:12.000 spaces at index of number
04:35:15.039 equals
04:35:17.199 the player's marker
04:35:19.118 then we'd like to break out of this
04:35:20.639 while loop so after the player moves
04:35:23.680 let's draw the board again to reflect
04:35:25.840 any changes
04:35:30.080 okay enter a spot to place a marker how
04:35:32.480 about one yeah there's our marker let's
04:35:34.719 try it again
04:35:37.039 how about nine
04:35:38.879 yep and we are in the last spot the
04:35:41.118 bottom right corner let's enter in a
04:35:43.118 number that's outside of this range like
04:35:45.599 100
04:35:46.799 enter a spot to place a marker uh
04:35:48.879 negative one okay so we're limited to
04:35:51.599 the numbers one through nine even if i
04:35:53.599 were to type zero we still can't uh so
04:35:56.240 let's try something in the middle that
04:35:57.840 would be one two three four five
04:36:02.320 yeah and there's our marker i'm just
04:36:04.160 gonna add a colon then a space
04:36:06.561 okay and that is the player move
04:36:08.080 function
04:36:09.520 we can close out of this function
04:36:12.561 let's work on the computer move function
04:36:14.480 next
04:36:15.919 within the while loop let's invoke that
04:36:17.840 function
04:36:18.799 pass in our spaces array
04:36:21.438 as well as whatever character the
04:36:23.039 computer is
04:36:24.480 then we will draw the board again right
04:36:26.160 after
04:36:27.199 just update it within the computer move
04:36:29.520 function we'll create a local variable
04:36:31.118 named number
04:36:33.680 we'll need a seed to generate a random
04:36:35.438 number
04:36:36.480 s rand
04:36:38.400 within the parentheses
04:36:40.240 invoke the time function pass in zero or
04:36:42.879 null
04:36:45.118 and we should be able to generate some
04:36:46.400 random numbers
04:36:48.719 so i'm going to create a while loop
04:36:50.879 while the condition will be true
04:36:53.520 i would like to generate a random number
04:36:55.199 between 0 through 8.
04:36:57.520 we'll take number set the sequel to
04:37:00.561 rand function
04:37:02.000 modulus nine
04:37:04.240 number will be random between zero and
04:37:06.320 eight technically
04:37:07.680 if we pick a spot number that is
04:37:09.278 occupied already we'll need to reroll a
04:37:11.199 random number
04:37:14.160 if
04:37:15.199 spaces
04:37:16.879 at index of number
04:37:19.599 is equal to an empty space
04:37:22.160 we'll take spaces
04:37:24.000 at index of number
04:37:26.080 set the sql to the computer's marker
04:37:30.080 then break out of this while loop
04:37:32.879 let's test this function
04:37:35.438 after we pick a spot the computer will
04:37:37.039 pick a spot too
04:37:38.799 yep so the computer picked a spot right
04:37:40.639 in the middle let's try it one more time
04:37:42.561 i'll pick the spot in the middle again
04:37:43.919 so that would be five
04:37:46.000 and our computer picked spot number two
04:37:48.400 cool let's close out of the computer
04:37:50.160 move function
04:37:51.919 after the player moves then we draw the
04:37:53.919 board again we will check a winner
04:37:57.680 i'll use an if statement within the
04:37:59.520 condition of the if statement we will
04:38:01.199 invoke the check winner function
04:38:04.160 the check winner function returns a
04:38:05.919 boolean value so that's why we're
04:38:08.080 placing it within the if statement but
04:38:10.160 we need to pass in a couple arguments
04:38:11.919 our spaces
04:38:13.520 the player and the computer
04:38:16.639 if there's a winner if this evaluates to
04:38:18.879 be true
04:38:19.919 we will set running equal to false
04:38:23.199 and we will break
04:38:25.118 let's add this if statement to after the
04:38:27.039 computer moves too
04:38:32.400 okay let's fill in the check winner
04:38:34.160 function
04:38:35.599 so right down here
04:38:38.799 we'll need to check all of the different
04:38:40.240 win conditions they're several normally
04:38:42.958 i would use a switch but it's going to
04:38:44.480 get very complicated especially for
04:38:46.639 beginners i think just to make this
04:38:48.400 easier we'll use a bunch of if and else
04:38:50.719 if statements
04:38:53.118 within the first condition of the if
04:38:54.958 statement we'll check to see if the
04:38:56.958 first row all has matching characters so
04:38:59.919 we can do that by saying
04:39:01.919 spaces
04:39:03.118 at index of zero
04:39:06.561 is equal to spaces at index of one
04:39:11.039 and
04:39:11.919 spaces at index of one
04:39:15.278 is equal to
04:39:16.719 spaces at index of two
04:39:19.680 if all three characters in the first row
04:39:22.080 are the same that means that somebody
04:39:24.080 won
04:39:24.879 i'm going to use the ternary operator
04:39:26.639 here we have to determine who won the
04:39:28.958 player or the computer let's check to
04:39:30.958 see if the first index spaces at index 0
04:39:34.958 is equal to the player's marker
04:39:37.360 ternary operator like we're asking a
04:39:39.040 question
04:39:40.240 if the player occupies the first row
04:39:43.040 then we'll print standard output
04:39:46.560 u
04:39:48.240 win
04:39:50.400 otherwise standard
04:39:52.958 output
04:39:55.600 you
04:39:57.200 lose
04:39:59.520 then i'm just going to add a new line
04:40:01.680 here
04:40:02.400 and here
04:40:04.638 okay there's one more thing we have to
04:40:06.000 do with this condition and i'll explain
04:40:07.760 that so let's run this
04:40:11.040 i'll pick spot number nine
04:40:15.040 you lose the reason that we lost is that
04:40:17.520 we're checking to see if the first row
04:40:19.520 all has the same characters they're
04:40:21.280 technically all empty spaces so our
04:40:23.600 program thinks that somebody won because
04:40:25.840 all of these characters match there are
04:40:27.840 three empty spaces i'm going to amend
04:40:30.160 this if statement we'll want to ensure
04:40:31.920 that none of the spaces are empty and
04:40:33.840 really we only need to check the first
04:40:35.280 space i'll make this amendment
04:40:37.760 spaces at index of zero
04:40:41.440 does not equal
04:40:43.520 an empty space
04:40:45.840 and
04:40:46.878 all these other conditions
04:40:48.718 if you'd like to keep this more
04:40:49.760 organized you can always surround some
04:40:51.600 of these conditions with parentheses
04:40:54.718 i think it's more legible that way
04:40:58.638 let's try that again just to be sure
04:41:00.080 that it's working i'll pick something in
04:41:01.520 the middle
04:41:03.200 okay yeah so the computer doesn't win
04:41:05.120 automatically if there's three empty
04:41:06.958 spaces in the first row okay so that is
04:41:09.280 the first win condition
04:41:11.200 let's copy this condition
04:41:13.600 i'll add
04:41:14.798 else if
04:41:16.560 now we'll check the second row if space
04:41:18.878 is at index 3 is not equal to an empty
04:41:21.360 space
04:41:22.240 and space is at index 3
04:41:25.360 is equal to spaces at index four
04:41:28.878 and spaces at index four is equal to
04:41:31.760 spaces at index five
04:41:33.760 then does spaces at index three equal to
04:41:36.480 player okay so that is row two let's
04:41:39.200 copy and paste that else if statement
04:41:41.600 then we'll need to check the last row
04:41:43.840 space is at index six
04:41:46.320 six
04:41:47.440 is six equal to seven
04:41:50.240 and is seven equal to eight
04:41:52.878 so these conditions will check all of
04:41:54.638 the rows then we'll need columns
04:41:57.520 let's copy one of these elsif statements
04:41:59.440 paste it
04:42:00.560 so we have 0 0
04:42:04.080 is
04:42:04.958 0 equal to 3
04:42:07.440 and is three
04:42:09.760 equal to six
04:42:13.200 okay now time for the second column
04:42:17.040 space is at index one
04:42:20.240 one right here as well
04:42:23.600 is one
04:42:24.958 equal to four
04:42:26.480 and is four equal to seven
04:42:30.000 copy this again paste it
04:42:34.638 then we have the third column
04:42:37.680 two
04:42:38.958 two
04:42:41.520 is two equal to five
04:42:44.480 and is five equal to eight
04:42:48.080 okay now the diagonals
04:42:55.760 space is at zero
04:42:57.920 zero
04:42:59.680 is zero equal to four
04:43:03.440 and is four equal to eight
04:43:07.600 then the last diagonal
04:43:12.080 space is at index two
04:43:14.718 two
04:43:16.638 is two equal to 4
04:43:19.200 and is 4 equal to 6.
04:43:22.718 if there's no win conditions
04:43:25.280 we'll have an else statement
04:43:27.360 we will return
04:43:28.958 false
04:43:30.160 then all we have to do at the end of
04:43:31.360 this function is to return true somebody
04:43:33.920 won
04:43:35.200 okay so let's test this
04:43:39.440 i'll try and win with the first row
04:43:42.080 one
04:43:42.958 two
04:43:43.840 three
04:43:44.718 you win this time i'm gonna try and lose
04:43:48.638 one
04:43:50.240 two
04:43:53.040 four
04:43:56.560 seven
04:43:57.600 whoops seven's taken uh eight
04:44:00.560 there we go you lose
04:44:02.560 we can close out of the check winner
04:44:04.160 function we know that it's working
04:44:06.400 then we just need to check to see if
04:44:07.760 there's a tie if there's no more spaces
04:44:09.760 available within the main function after
04:44:12.400 our if statements we'll add else if
04:44:16.718 we'll invoke the check tie function
04:44:20.798 pass in our spaces
04:44:23.360 check tie returns a boolean value if
04:44:26.080 it's
04:44:26.840 true we will set running to be false
04:44:30.160 then break
04:44:32.000 then add that after the computer move
04:44:34.080 section 2 so right here
04:44:38.798 then let's fill in this function
04:44:41.680 within the check tie function we'll
04:44:43.440 iterate over the elements of our array
04:44:45.200 spaces we'll use a for loop
04:44:48.480 four
04:44:49.280 and i equals zero we'll continue this as
04:44:52.320 long as i is less than nine because
04:44:54.958 there's a total size of nine spaces
04:44:58.080 increment i by one
04:45:00.878 if
04:45:01.680 spaces
04:45:02.878 at index of i
04:45:04.958 is equal to
04:45:06.320 an empty space
04:45:08.000 that means we can continue return false
04:45:11.280 there's still empty spaces
04:45:13.440 if we iterate over our array and there's
04:45:15.440 no empty spaces well then we'll display
04:45:18.958 standard output
04:45:22.000 it's
04:45:23.200 a
04:45:24.718 tie
04:45:26.958 i'll add a new line
04:45:29.840 then we will return
04:45:31.680 true
04:45:32.718 and we can get rid of that
04:45:36.320 okay so let's close out of this check
04:45:38.000 tie function
04:45:40.718 then after we exit our game outside of
04:45:42.718 this while loop
04:45:44.000 let's display a message
04:45:45.760 standard output
04:45:48.400 thanks for playing
04:45:52.160 all right and that's everything let's
04:45:53.440 run this i'm gonna try and get a tie
04:45:55.360 this time
04:45:59.120 one
04:46:01.040 two
04:46:03.600 six
04:46:07.040 seven
04:46:09.600 eight
04:46:10.958 it's a tie thanks for playing
04:46:13.520 all right everybody that is a game of
04:46:15.040 tic-tac-toe for beginners
04:46:17.040 if you would like a copy of this code
04:46:18.560 i'll post this in the comment section
04:46:20.160 down below and well yeah that's a game
04:46:22.240 of tic-tac-toe using c plus
04:46:28.240 hey everybody we finally made it to
04:46:30.080 dynamic memory dynamic memory is memory
04:46:33.120 that is allocated after the program is
04:46:35.600 already compiled and running to allocate
04:46:37.920 dynamic memory we use this new keyword
04:46:40.400 it's an operator it allows us to
04:46:42.320 allocate memory in the heap rather than
04:46:44.958 the stack it's useful when we don't know
04:46:47.280 how much memory we'll need it makes our
04:46:49.200 programs more flexible especially when
04:46:51.200 accepting user input because we have no
04:46:53.520 idea what the user is going to type in
04:46:55.360 here's an example we'll start with a
04:46:57.040 basic integer variable but we'll
04:46:59.040 allocate memory in the heap rather than
04:47:00.958 the stack by using that new keyword i'll
04:47:02.958 create a pointer
04:47:04.320 int
04:47:06.000 the reference operator p
04:47:08.638 num
04:47:09.600 now it's good practice when you declare
04:47:11.280 a pointer but don't assign it right away
04:47:13.440 to give it a value of null meaning no
04:47:15.760 value to allocate memory in the heap
04:47:18.160 rather than the stack i'll take my
04:47:19.920 pointer set the sql to
04:47:22.320 use the new operator then a data type
04:47:25.200 i'll use up enough space in the heap for
04:47:27.760 one integer the new operator will return
04:47:30.160 an address we're storing that address
04:47:32.240 within pnum because it's a pointer it's
04:47:34.638 pointing to a memory location where
04:47:36.480 we're going to store an integer later on
04:47:38.480 in your program whenever you would like
04:47:39.920 to store a value we can use the
04:47:42.080 dereference operator our pointer then
04:47:44.958 assign some value
04:47:46.958 like 21 i don't know just for fun i'm
04:47:49.840 going to display the address that's
04:47:51.520 stored within the pointer
04:47:53.760 address
04:47:57.280 p num
04:47:59.360 then i'll add a new line
04:48:02.480 as well as the value
04:48:06.560 value
04:48:07.920 dereference operator p
04:48:10.840 number
04:48:12.480 our pointer is storing this address and
04:48:14.958 at this address in the heap that address
04:48:17.280 contains this value 21. now it's very
04:48:20.320 good practice if not expected whenever
04:48:23.280 you use the new operator you'll also
04:48:25.600 want to use the delete operator when
04:48:27.600 you're no longer using that memory space
04:48:29.760 so at the end of this program or earlier
04:48:31.840 if you choose
04:48:32.958 we will delete
04:48:34.638 our pointer
04:48:36.160 delete p num
04:48:38.000 we're freeing up the memory at this
04:48:39.840 address if you don't you may cause a
04:48:41.920 memory leak and it's best to avoid that
04:48:44.320 whenever you use the new operator you
04:48:46.400 probably should be using the delete
04:48:47.920 operator someplace within your program
04:48:50.240 here's another example we're going to
04:48:52.240 dynamically create an array let's create
04:48:54.638 an array of grades
04:48:56.638 char
04:48:57.600 then we'll need a pointer
04:48:59.360 the reference operator p
04:49:02.160 grades
04:49:04.000 set the sequel to null if we're not
04:49:06.160 going to assign this pointer right away
04:49:08.240 then to dynamically create an array we
04:49:10.480 will take our pointer set the sql to
04:49:13.680 new
04:49:14.718 the data type char
04:49:16.878 if this is an array we add a set of
04:49:18.480 straight brackets within the straight
04:49:20.480 brackets we will list a size if i have
04:49:22.560 five grades to enter in i would type in
04:49:24.480 five but if we already know the size of
04:49:26.400 the array before we even run the program
04:49:28.798 we might as well do that normally like
04:49:30.320 create a normal array there's no point
04:49:32.160 to allocating memory dynamically we
04:49:34.160 would want to do that when we don't know
04:49:35.680 what the size is going to be so i
04:49:37.440 propose we ask for some user input
04:49:40.000 let's say int size
04:49:43.600 will create a prompt standard output
04:49:47.600 how many grades to enter in
04:49:54.240 standard input
04:49:56.240 size
04:49:57.600 will dynamically allocate enough memory
04:49:59.840 in the heap depending on how many grades
04:50:02.240 the user has to enter in
04:50:04.638 i'll just create a for loop so that we
04:50:06.560 will ask the user to enter in some
04:50:08.160 grades
04:50:09.600 and i equals zero i will continue this
04:50:12.480 as long as i is less than size
04:50:15.200 increment i by
04:50:16.840 one standard output
04:50:20.798 enter grade
04:50:22.560 number
04:50:24.480 i plus 1 because i will be 0 to begin
04:50:27.440 with
04:50:29.040 and i'm just going to add colon space
04:50:31.360 afterwards
04:50:33.360 standard
04:50:34.878 input
04:50:37.200 p
04:50:38.080 grades that's our pointer now we can
04:50:40.718 either add plus i
04:50:43.120 or use those straight brackets at index
04:50:45.680 of i either way
04:50:48.400 let's display all of the grades
04:50:51.840 and i equals zero
04:50:54.320 i is less than size
04:50:56.320 i plus plus
04:50:58.718 standard output
04:51:01.280 p
04:51:02.000 grades
04:51:03.040 at index of i i'll separate each with
04:51:05.600 the space
04:51:06.798 and remember if we no longer need this
04:51:08.718 array we should delete it to prevent a
04:51:10.718 memory leak
04:51:11.920 if we have to delete an array we'll add
04:51:14.080 a set of straight brackets after delete
04:51:16.400 then our pointer
04:51:18.400 p grades
04:51:22.000 and let's try it
04:51:24.958 how many grades to enter in
04:51:26.798 so we don't know what the user is going
04:51:28.000 to type
04:51:29.600 let's say
04:51:30.798 six grades
04:51:32.320 enter grade one
04:51:33.760 a b c d f a
04:51:37.840 and here are the grades
04:51:39.840 so that's why dynamic memory is useful
04:51:42.240 it's memory that is allocated after the
04:51:44.320 program is already compiled and running
04:51:46.798 we use the new operator to allocate
04:51:48.878 memory in the heap rather than the stack
04:51:51.920 it's useful when we don't know how much
04:51:53.840 memory we will need it makes our
04:51:55.760 programs more flexible especially when
04:51:58.160 accepting user input so that is an
04:52:00.400 introduction to dynamic memory we'll
04:52:02.400 have more practice with this in the
04:52:03.760 future so don't worry if you would like
04:52:05.920 a copy of the code that we worked on
04:52:07.440 i'll post that in the comments section
04:52:08.958 down below and well yeah that's an
04:52:11.040 introduction to dynamic memory in c plus
04:52:17.120 hey guys i gotta explain recursion
04:52:19.360 recursion is a programming technique
04:52:21.360 where a function invokes itself from
04:52:23.840 within we break a complex concept into
04:52:26.878 repeatable single steps many problems we
04:52:30.000 can approach iteratively or recursively
04:52:32.878 some of the advantages of recursion
04:52:34.560 include
04:52:35.520 less coderight and typically it's
04:52:37.520 cleaner it's also useful for sorting and
04:52:40.320 searching algorithms however some of the
04:52:42.400 disadvantages of recursion is that it
04:52:44.480 uses more memory and a slower there's a
04:52:47.280 trade-off it's up to you if you'd rather
04:52:49.200 use an iterative approach or a recursive
04:52:51.520 approach here's an example we'll break a
04:52:53.680 complex concept maybe such as walking
04:52:56.240 into repeatable single steps to
04:52:58.480 accomplish the task of walking we would
04:53:00.320 take a single step and then just repeat
04:53:02.080 that a bunch of times we'll do this
04:53:03.680 first iteratively then recursively
04:53:07.040 so let's create a function to walk
04:53:10.240 void
04:53:11.280 walk
04:53:12.320 there will be one parameter a number of
04:53:14.958 steps
04:53:16.400 let's define this walk function
04:53:20.560 we'll use an iterative approach first to
04:53:22.798 do that we can use a for loop
04:53:24.718 we'll set
04:53:26.320 int i equals zero we'll continue this as
04:53:29.760 long as i
04:53:31.200 is less than
04:53:32.798 our steps then increment i by one
04:53:36.480 i will display
04:53:38.958 just you take a step
04:53:43.040 then i'll add a new line
04:53:45.680 so we will invoke this function pass in
04:53:48.240 how many steps we would like to walk i
04:53:50.400 would like to walk 100 steps
04:53:54.718 and here we go
04:53:56.560 we printed you take a step 100 times
04:53:59.840 this is an iterative approach if we were
04:54:02.400 to take a recursive approach we would
04:54:04.718 invoke this function from within itself
04:54:07.360 so i'm going to turn this for loop into
04:54:09.360 an if statement
04:54:12.320 we'll need a base case when do we stop
04:54:14.638 if
04:54:15.520 steps
04:54:17.440 is greater than
04:54:19.200 zero
04:54:20.560 we will display you take a step then i'm
04:54:23.280 going to invoke the walk function from
04:54:25.440 within itself then i will pass in steps
04:54:28.798 minus 1. this would be a recursive
04:54:31.440 approach we're invoking the walk
04:54:33.280 function from within itself
04:54:35.360 you'll end up in a function within a
04:54:37.520 function within a function within a
04:54:39.760 function so on and so forth so when i
04:54:42.080 run this
04:54:44.160 this would do the same thing but we've
04:54:45.920 done so recursively the advantages with
04:54:48.560 recursion is that the code tends to be
04:54:50.878 easier to write i find this if statement
04:54:53.120 a lot easier to understand than that for
04:54:55.360 loop although they're both pretty simple
04:54:57.680 however with recursion it uses more
04:54:59.680 memory and it takes more processing time
04:55:02.160 in the case with our walk function i
04:55:03.760 would probably stick with an iterative
04:55:05.440 approach there's really not much benefit
04:55:07.760 in this case but in the case of let's
04:55:09.760 say a searching algorithm or navigating
04:55:12.000 a tree data structure recursion would
04:55:14.160 really help us with that so let's say we
04:55:16.320 don't have a base case that's when we
04:55:18.080 stop what if i just call the walk
04:55:20.000 function forever
04:55:24.798 well we end up in an infinite loop
04:55:27.040 and we would encounter what's called a
04:55:28.798 stack overflow
04:55:30.320 when you invoke a function you add
04:55:32.160 what's called a frame to the stack when
04:55:34.240 your stack is overloaded you'll
04:55:36.080 encounter a stack overflow
04:55:38.480 so that's one problem with recursion
04:55:40.958 so let's try a different example
04:55:43.120 we'll create a factorial function
04:55:45.600 if you don't remember factorial is a
04:55:47.440 mathematics concept where you take a
04:55:49.280 number and you multiply that number
04:55:51.680 times the previous number minus one
04:55:54.000 times the previous number minus one
04:55:56.400 times the previous number minus one
04:55:58.560 until you reach one you multiply all
04:56:00.560 these numbers and you're given a result
04:56:02.718 i'm going to demonstrate a function to
04:56:04.320 do that both iteratively then
04:56:06.080 recursively let's begin with an
04:56:08.080 iterative approach we will return an
04:56:10.320 integer this function will be named
04:56:12.480 factorial we'll pass in an integer named
04:56:15.840 num
04:56:16.958 i'll immediately display the output
04:56:18.958 standard output
04:56:20.958 factorial then pass in some number maybe
04:56:23.920 10.
04:56:25.920 let's define this function
04:56:30.718 if i was to take an iterative approach i
04:56:32.958 would write something like this
04:56:35.280 end result this will be a local variable
04:56:38.400 i'll set this equal to one
04:56:40.560 i'll create a for loop
04:56:44.400 and i
04:56:45.600 equals one
04:56:47.760 we'll continue this as long as i is less
04:56:50.480 than or equal to our number
04:56:53.040 increment i by one
04:56:55.280 i will take
04:56:56.480 our result
04:56:57.840 equals result
04:56:59.600 times whatever i currently is
04:57:02.320 at the end of this program we will
04:57:04.080 return result
04:57:06.320 factorial ten that would be
04:57:09.040 three million six hundred twenty eight
04:57:10.560 thousand eight hundred
04:57:13.600 if i was taking a recursive approach i
04:57:15.520 would write something like this we would
04:57:17.520 need a base case when do we stop
04:57:21.120 if num
04:57:22.560 is greater than 1
04:57:25.440 we will return
04:57:27.760 num times
04:57:29.760 invoke factorial again
04:57:32.400 our number minus one
04:57:36.000 else we will simply return one
04:57:39.840 this would do the same thing but
04:57:41.280 recursively factorial ten is three
04:57:43.840 million six hundred twenty eight
04:57:45.200 thousand eight hundred
04:57:47.360 those were two different approaches to
04:57:48.958 the same problem when we did this
04:57:50.718 recursively we have a function call
04:57:53.120 inside of a function call inside of a
04:57:54.958 function call inside of a function call
04:57:56.958 you get the idea personally i find a
04:57:59.280 recursive approach to be a lot easier to
04:58:01.360 read and understand although remember it
04:58:03.680 uses more memory and a slower when you
04:58:06.080 start to learn about sorting algorithms
04:58:07.920 that's when recursion is really going to
04:58:09.680 help you quite a lot it will simplify
04:58:11.840 the steps so that's recursion everybody
04:58:14.320 it's a programming technique where a
04:58:16.160 function invokes itself from within
04:58:18.798 we break a complex concept into
04:58:21.200 repeatable single steps whenever you see
04:58:23.680 a function invoking itself from within
04:58:25.920 you'll know that that's recursion hey if
04:58:27.680 you would like a copy of this code i'll
04:58:29.360 post this in the comment section down
04:58:31.040 below and well yeah that's recursion in
04:58:33.680 c plus
04:58:37.280 hey everyone let's discuss function
04:58:39.440 templates a function template describes
04:58:42.480 what a function looks like they can be
04:58:44.400 used to generate as many overloaded
04:58:46.718 functions as needed each using different
04:58:49.280 data types how is this useful suppose we
04:58:51.840 have a max function that will accept and
04:58:54.560 return an integer
04:58:56.878 int
04:58:57.840 max
04:58:59.040 the parameters will be
04:59:00.718 int x
04:59:02.160 and y
04:59:04.958 will return
04:59:06.400 i'll use the ternary operator here
04:59:09.040 is x greater than y
04:59:12.958 if so return x
04:59:15.760 if not return y
04:59:18.000 this function is compatible with
04:59:19.680 integers as arguments
04:59:21.600 let's display standard output max then
04:59:25.200 pass in two integers like one and two
04:59:31.280 so this would return the number two but
04:59:33.840 what if i would like to use this
04:59:35.040 function with doubles such as 1.1
04:59:38.958 and 2.1
04:59:41.680 while we're truncating that decimal
04:59:43.360 portion we're returning to not 2.1 if i
04:59:46.718 want this function to be compatible with
04:59:48.638 doubles normally i would have to create
04:59:50.560 an overloaded function that accepts
04:59:52.480 doubles and returns a double
04:59:54.718 replace int with double
04:59:58.958 and i guess this would work technically
05:00:00.878 the value returned is 2.1 what about
05:00:03.520 characters
05:00:04.958 how about the character 1
05:00:08.000 and the character 2.
05:00:10.000 technically we could use the max version
05:00:12.320 that accepts integers because there's an
05:00:14.320 associated ascii value with each of
05:00:16.240 these characters but i would like an
05:00:17.840 overloaded function that accepts and
05:00:19.680 returns characters
05:00:21.360 char
05:00:22.560 char
05:00:23.360 char
05:00:26.160 so this would return the character 2.
05:00:28.958 this is a lot of work creating three
05:00:30.718 overloaded functions that each do the
05:00:32.560 same thing the only difference is that
05:00:34.638 they accept and return different data
05:00:36.560 types what if we could write one
05:00:38.400 function that will accept any data type
05:00:40.718 well that's what function templates are
05:00:42.560 to create a function template take your
05:00:44.638 function replace any data type with t
05:00:48.080 we're returning an integer let's instead
05:00:50.080 return t the data type of x will be t
05:00:53.440 same thing with y using t as a common
05:00:55.840 naming convention i like to think of it
05:00:57.840 as thing like we're not sure what the
05:00:59.920 data type is we're returning a thing
05:01:02.958 that's just how i think of it however
05:01:04.958 our compiler doesn't know what t is
05:01:06.958 exactly we'll need to add a template
05:01:09.280 parameter declaration before this
05:01:11.600 function template definition we'll add a
05:01:14.080 declaration of what t is so type
05:01:17.120 template
05:01:18.240 angle brackets
05:01:20.080 type name
05:01:21.280 t
05:01:22.400 and that's it this function template
05:01:24.560 will work with many data types
05:01:27.040 characters
05:01:28.638 doubles
05:01:33.040 integers
05:01:37.360 you name it so yeah just replace the
05:01:39.520 data type with t then be sure to add a
05:01:42.400 template parameter declaration now
05:01:44.560 here's a scenario what if you need to
05:01:46.480 mix and match the data types i'll find
05:01:48.638 what the max is between the integer 1
05:01:51.520 and the double 2.1
05:01:55.440 well we have a problem
05:01:57.040 no matching function for call 2 max int
05:02:00.560 double with this function template it's
05:02:03.120 only set up to receive arguments of the
05:02:05.360 same data type now we're passing in two
05:02:08.080 different data types what we could do
05:02:10.000 within our template parameter
05:02:11.840 declaration is add another template name
05:02:15.440 i'm going to add
05:02:17.120 type
05:02:18.160 name u because u comes after t in the
05:02:20.798 alphabet then if you needed more you
05:02:22.638 could add v w x so on and so forth i'll
05:02:26.080 change one of these t's to a u this
05:02:28.560 function template is set up to receive
05:02:30.638 up to two different data types as
05:02:32.320 arguments but there's one more change we
05:02:34.560 need to make
05:02:36.400 so we don't have that error anymore but
05:02:38.400 the decimal portion of our double is
05:02:40.560 truncated it's returning two
05:02:42.958 that's because we're still returning t
05:02:45.600 and t we set to be an integer in this
05:02:47.520 case do we set the return type to be t
05:02:50.560 or u
05:02:51.680 actually better yet we can set this to
05:02:53.680 auto
05:02:54.878 using the auto keyword the compiler will
05:02:57.200 deduce what the return type should be
05:02:59.440 this should return 2.1
05:03:02.480 all right everybody that is a function
05:03:04.400 template it describes what a function
05:03:06.560 looks like
05:03:07.680 they can be used to generate as many
05:03:09.840 overloaded functions as needed each
05:03:12.160 using different data types i like to
05:03:14.160 think of it like a cookie cutter we're
05:03:16.160 determining what the shape is but the
05:03:18.320 arguments the dough that we use for our
05:03:20.240 cookies can be different but the cookies
05:03:22.560 will end up having the same shape one of
05:03:24.320 the main benefits of using function
05:03:26.000 templates is that we only have to write
05:03:28.000 a function once and then it's compatible
05:03:30.240 with different data types so you don't
05:03:32.160 need multiple versions of the same
05:03:33.760 function we'll generate functions using
05:03:35.920 this template as needed so yeah those
05:03:38.160 are function templates everybody your
05:03:40.080 assignment if you choose to do so is to
05:03:41.920 write a function template in the comment
05:03:43.760 section down below and well yeah those
05:03:46.160 are function templates in c plus
05:03:51.280 well okay then everybody we gotta talk
05:03:53.520 about structs a struct is a structure
05:03:56.798 that groups related variables under one
05:03:59.920 name think of an array an array can
05:04:01.920 store multiple values of the same data
05:04:04.480 type well a struct can store multiple
05:04:07.200 values of different data types we can
05:04:09.840 store strings along with ins doubles
05:04:12.320 booleans etc to create a struct let's do
05:04:14.878 so outside of the main function
05:04:17.360 type struct
05:04:19.040 then we need an identifier this is kind
05:04:21.520 of like the data type suppose we're
05:04:23.840 going to group related variables for
05:04:26.000 students
05:04:27.680 i'll name this identifier student
05:04:30.240 within the structure of student
05:04:32.080 variables that we declare are known as
05:04:34.560 members i think each student should have
05:04:36.798 a name member this will be of the string
05:04:38.718 data type string name
05:04:40.958 i'll declare this but not yet assign it
05:04:43.120 as well as a gpa that could be of the
05:04:45.280 double data type
05:04:47.920 then a boolean variable if they're
05:04:50.240 currently enrolled or not
05:04:52.638 enrolled
05:04:54.320 then be sure to end your struct with a
05:04:55.920 semicolon our struct student is kind of
05:04:58.718 like its own data type we can use this
05:05:00.798 data type to declare variables i'll
05:05:02.958 create a student variable of this data
05:05:05.040 type and that variable will have these
05:05:07.360 three different members a name a gpa and
05:05:10.160 a boolean variable for being enrolled
05:05:12.320 much like with creating a variable we
05:05:14.080 type the data type student and then some
05:05:16.560 name some identifier let's name the
05:05:18.718 first student student one
05:05:21.760 student one will have its own name gpa
05:05:24.798 and enrolled status if i would like to
05:05:27.040 assign the name member of student one i
05:05:29.520 would type
05:05:30.798 the name of the student student one
05:05:32.798 followed by dot members can be accessed
05:05:35.440 with a dot also known as the class
05:05:38.080 member axis operator i'll assign the
05:05:40.638 name member and set the sequel to
05:05:43.040 spongebob
05:05:45.200 i'll assign student one's gpa
05:05:48.680 student1.gpa i'll give spongebob a solid
05:05:51.440 3.2 then i could set his enrolled status
05:05:56.080 student one dot enrolled
05:05:59.440 i'll set this to be true
05:06:01.280 then we could access these members i'll
05:06:03.040 display them
05:06:04.240 standard output
05:06:07.360 student1 dot name
05:06:10.400 i'll add a new line
05:06:14.080 let's do the same thing with gpa and
05:06:16.878 enrolled
05:06:18.360 student1.gpa student1.enrolled
05:06:22.080 this is what this looks like we have a
05:06:24.240 student variable the name member is
05:06:26.480 spongebob spongebob has a gpa of 3.2
05:06:30.080 when accessing boolean variables 1
05:06:32.480 corresponds with true 0 corresponds with
05:06:35.280 false enrolled is set to true so that
05:06:37.280 would return one let's reuse the struct
05:06:39.920 to create a second student
05:06:42.240 i'll just copy what we have here
05:06:44.400 then paste it
05:06:46.638 we'll give the second student a
05:06:48.080 different identifier such as student two
05:06:52.878 student two will have a name member of
05:06:55.280 patrick
05:06:56.878 a gpa of 2.1
05:07:00.480 and he will be enrolled that's set to
05:07:02.320 true
05:07:03.680 let's display student two's members
05:07:07.798 student2.name student2.gpa
05:07:10.798 then student2.enrolled
05:07:13.600 these first members correspond with
05:07:15.200 student1 spongebob 3.2 one for true
05:07:20.160 the second set is for student two
05:07:21.920 patrick has a gpa of 2.1 and patrick is
05:07:25.040 currently enrolled okay one last example
05:07:27.280 let's create student three
05:07:29.680 let's copy what we have paste it
05:07:33.280 student student3
05:07:35.760 student3.name
05:07:37.400 student3.gpa student3.enrolled
05:07:40.320 student 3's name will be squidward
05:07:43.520 squidward has a gpa of 1.5
05:07:46.878 let's set enrolled to be false
05:07:49.520 then display student three's members
05:07:54.000 student three dot name student three dot
05:07:56.480 gpa student three dot enrolled
05:08:00.480 and here are student threes members
05:08:02.480 squidward 1.5 and 0 that means false now
05:08:06.798 with members you can set a default value
05:08:09.440 i'll set enrolled to be true
05:08:11.760 then we don't need to explicitly state
05:08:13.600 that
05:08:17.520 underneath spongebob patrick and
05:08:19.040 squidward their enrolled member is all
05:08:21.120 set to 1. with members you can set a
05:08:23.520 default value so yeah those are structs
05:08:26.160 it's a structure that groups related
05:08:28.480 variables under one name structs can
05:08:30.798 contain many different data types
05:08:33.120 variables in a struct are known as
05:08:35.120 members and members can be accessed with
05:08:37.680 a dot the class member axis operator so
05:08:40.958 those are structs your assignment is to
05:08:42.878 post a struct in the comments section
05:08:44.638 down below and well yeah those are
05:08:46.638 strucks in c plus
05:08:51.360 hey everybody in this topic i'm going to
05:08:53.120 show you how we can pass a struct to a
05:08:55.360 function in c plus plus suppose we have
05:08:57.920 a struct the identifier of the struct
05:09:00.320 will be cars
05:09:02.400 then we'll create some members related
05:09:04.160 to cars
05:09:05.360 how about a model standard string model
05:09:09.440 a year end here
05:09:11.680 then a color standard string color
05:09:16.240 then let's go ahead and create two car
05:09:18.240 strucks
05:09:19.680 how about car
05:09:21.200 car one
05:09:23.360 car
05:09:24.480 car two then we'll assign the members
05:09:28.718 car one
05:09:29.760 dot model
05:09:30.958 pick a model of a card that you like
05:09:36.080 then a year
05:09:40.160 and a color
05:09:44.560 let's do the same thing with cartoon
05:09:51.920 car 2. model car 2.ear car 2.color
05:09:56.240 let's pick some different data
05:10:02.320 that'll work
05:10:03.520 suppose we have a function to display
05:10:05.440 the members of a
05:10:06.840 car void
05:10:09.280 how about print car we're printing the
05:10:11.760 members
05:10:13.280 we'll need some parameters
05:10:15.440 the data type of what we're passing in
05:10:18.320 are car structs so we'll list that as
05:10:20.718 the data type
05:10:22.400 then some nickname for the argument that
05:10:24.320 we receive how about just car
05:10:27.200 then i will display the members standard
05:10:29.600 output
05:10:30.878 car
05:10:32.160 dot model
05:10:34.080 should probably add a new line too
05:10:38.320 then do the same thing with year and
05:10:40.160 color
05:10:43.200 car dot ear
05:10:44.560 car dot color
05:10:46.400 let's test this by printing car one
05:10:49.040 print car 1 we will pass the name of a
05:10:52.080 struct as an argument
05:10:54.798 then i think we're just missing a
05:10:56.000 function declaration so if you're
05:10:57.680 missing that be sure to add that
05:11:00.240 there
05:11:01.280 now let's run this
05:11:04.080 okay here's our car
05:11:05.760 mustang 2023 and the color's red
05:11:08.798 now with structs they're passed by value
05:11:11.520 rather than pass by reference if we pass
05:11:14.080 a struct as an argument what we're doing
05:11:16.240 is creating a copy of the original
05:11:18.000 struct to demonstrate that let's display
05:11:20.160 the address of car 1 before and within
05:11:22.718 the function
05:11:24.160 standard
05:11:25.200 output
05:11:27.440 address of operator
05:11:29.120 car 1
05:11:30.320 i'll add a new line
05:11:33.440 then let's do that within the function
05:11:35.120 too
05:11:37.440 the parameter name is car not car one
05:11:41.200 there so let's try that
05:11:44.560 so these addresses are different
05:11:46.958 when we pass the struct to a function
05:11:49.280 the function will create a copy of it
05:11:50.958 it's passed by value we're displaying
05:11:52.958 the members of the copy rather than the
05:11:55.040 original if you need to work with the
05:11:56.958 original struct you can use the address
05:11:58.958 of operator we're passing a reference to
05:12:01.120 the original car struct
05:12:03.120 then be sure to change that within the
05:12:04.878 function declaration as well
05:12:06.958 so let's take a look at the addresses
05:12:08.400 now
05:12:10.958 yeah these addresses are the same
05:12:14.160 car 2 is feeling pretty lonely so let's
05:12:16.160 print car 2 as well
05:12:17.920 print car
05:12:19.520 pass in car 2 as an argument to this
05:12:21.600 function
05:12:24.240 so we should have
05:12:25.680 car 1
05:12:26.798 and car 2.
05:12:28.638 this time let's change one of the
05:12:29.920 members within a function
05:12:33.680 let's create a function to paint car
05:12:36.320 paint it a different color
05:12:38.080 paint
05:12:39.200 car
05:12:40.240 there will be two arguments
05:12:43.760 an address to a car
05:12:46.240 as well as a color which will be of the
05:12:48.638 string data type
05:12:51.760 be sure to add a function declaration if
05:12:53.680 you're missing it
05:12:58.000 then within this function we will take
05:13:00.638 our car
05:13:01.920 dot color
05:13:03.200 equals
05:13:04.480 the new color that we receive
05:13:07.760 now before we print our cars let's paint
05:13:09.920 them a different color
05:13:11.920 paint car
05:13:13.360 we have two arguments this time a car
05:13:15.680 struck
05:13:16.878 and a new color let's paint our mustang
05:13:19.360 silver
05:13:22.798 then let's paint cartoon maybe gold
05:13:27.040 then let's display this
05:13:30.480 okay our mustang is now silver and our
05:13:33.200 corvette is now gold so if we didn't use
05:13:36.080 the address of operator when painting
05:13:38.080 our car
05:13:39.120 let me show you what happens
05:13:43.920 our cars are still the original colors
05:13:46.400 red and blue what we did within this
05:13:48.560 function is that we created a copy of
05:13:50.320 our car strucks
05:13:51.760 and change the color of the copies
05:13:54.160 rather than the originals so if you need
05:13:56.240 to make any changes to the original you
05:13:58.320 would want to use the address of
05:13:59.920 operator so that's how to pass structs
05:14:02.000 to functions
05:14:03.280 you can pass by value which can be
05:14:05.200 expensive or you can pass by reference
05:14:07.920 your assignment if you choose to do so
05:14:10.240 is to post a function that accepts a
05:14:12.240 struct as an argument and that's how to
05:14:14.160 pass structs to functions in c plus
05:14:19.200 hey everybody we gotta talk about enums
05:14:21.280 enums also means enumerations it's a
05:14:24.080 user-defined data type that consists of
05:14:26.718 paired named integer constants they're
05:14:29.360 great if you have a set of potential
05:14:31.200 options here's an example suppose we
05:14:33.680 have a day of the week standard string
05:14:37.280 today
05:14:38.400 then pick a day
05:14:39.840 i'll pick sunday normally you can't use
05:14:42.000 strings within switches but we can use
05:14:44.320 enums which are kind of similar let me
05:14:46.718 explain
05:14:47.680 so i'm going to create a switch
05:14:49.760 we will examine today
05:14:51.920 normally we can't do this because it's a
05:14:53.600 string we'll examine today against many
05:14:55.840 matching cases
05:14:57.680 case
05:14:58.878 sunday and i'll speed up the footage
05:15:09.280 okay here's my switch depending on what
05:15:11.280 day of the week it is we'll display a
05:15:12.798 custom message it is either sunday
05:15:15.600 through saturday one of these days so
05:15:17.920 normally we can't do strings within
05:15:19.360 switches this is what happens when we
05:15:21.520 attempt that
05:15:23.440 error switch quantity not an integer
05:15:26.160 something similar that we can use are
05:15:28.080 enums they're paired named integer
05:15:30.718 constants we have a name and an
05:15:33.040 associated value they're interchangeable
05:15:35.840 at the top of my program i will declare
05:15:38.480 enum then a name for the set of
05:15:40.638 enumerations let's say day for day of
05:15:43.360 the week
05:15:44.878 we have
05:15:46.400 sunday
05:15:47.680 monday
05:15:49.680 tuesday
05:15:52.160 and you know the rest
05:16:00.080 you can associate a value with each of
05:16:01.920 these names
05:16:03.040 sunday equals zero
05:16:05.680 monday equals one
05:16:07.600 then we'll just continue on with the
05:16:08.958 rest of these
05:16:13.120 i'm going to group these together like
05:16:14.798 that
05:16:23.520 okay we have our enum setup this
05:16:26.080 identifier is kind of like the new data
05:16:28.160 type
05:16:29.120 we're not working with strings anymore
05:16:31.040 we're working with days
05:16:33.120 these are a set of potential options
05:16:35.760 each option is a pair of a name and some
05:16:38.638 associated value you can really pick any
05:16:41.200 value i went with the numbers 0 through
05:16:43.520 6 to represent the day of the week i'm
05:16:45.680 going to set today
05:16:47.520 to
05:16:48.958 sunday
05:16:50.240 this name
05:16:51.280 we can now use this within a switch
05:16:53.520 there's an associated integer value
05:16:56.080 but we'll change the cases from strings
05:16:58.160 to that enum data type
05:17:04.798 and this would work
05:17:07.520 it is sunday
05:17:08.958 within the cases you could use the
05:17:10.638 associated values as well
05:17:12.718 i'm gonna change today to be friday
05:17:16.560 case zero is sunday monday is one
05:17:19.920 two three four five six
05:17:25.280 it is friday
05:17:26.798 so that also works but i don't think
05:17:28.718 it's as readable
05:17:30.480 another cool thing with enums is that
05:17:32.400 enum variables take only one value of
05:17:35.040 the set if i try and make up some value
05:17:37.840 like pizza day well we can't do that
05:17:43.040 pizza day was not declared in the scope
05:17:45.680 here's a few other enum examples you
05:17:48.160 could create a set of enums for flavors
05:17:50.240 vanilla chocolate strawberry mint an
05:17:52.878 important note is that if you're working
05:17:54.400 with enums and you don't assign an
05:17:56.320 integer value to each of these names
05:17:58.480 you'll implicitly assign zero to the
05:18:00.798 first name then one two three kind of
05:18:03.760 like what i did up here but we
05:18:05.120 explicitly assigned to those values we
05:18:07.440 have six colors
05:18:10.400 or maybe planets i have a set of enums
05:18:13.120 of the nine planets in our solar system
05:18:15.280 the associated integer is the size of
05:18:17.600 each planet in kilometers
05:18:19.600 so yeah those are enums they're a
05:18:21.600 user-defined data type that consists of
05:18:24.320 paired named integer constants
05:18:27.280 they're great if you have a set of
05:18:28.798 potential options your assignment is to
05:18:31.360 post a set of enums in the comments
05:18:33.440 section down below and well yeah those
05:18:36.080 are enums in c plus plus
05:18:40.798 hey everybody so we have finally made it
05:18:43.120 to object oriented programming an object
05:18:46.080 think of it as a collection of
05:18:48.240 attributes and methods
05:18:50.000 attributes are characteristics of an
05:18:52.240 object methods are functions that an
05:18:54.798 object can perform
05:18:56.400 objects can be used to mimic real-world
05:18:59.040 items so look around you right now next
05:19:01.920 to me i have a phone
05:19:04.080 a book and a dog think of attributes as
05:19:07.440 characteristics
05:19:08.958 what kinds of characteristics would a
05:19:10.718 phone have maybe a version number a
05:19:13.760 charge a service provider objects can
05:19:16.958 also contain methods what kinds of
05:19:19.200 actions can a phone perform they can
05:19:21.280 make calls receive calls play games now
05:19:24.878 with a book some of the attributes of a
05:19:27.200 book could be
05:19:28.400 maybe an author number of pages let's
05:19:31.360 see what kinds of methods can a book
05:19:33.040 perform really not much you can open a
05:19:35.280 book and you can close it so those are
05:19:37.200 just a few okay lastly how about a dog
05:19:39.760 object some of the attributes of a dog
05:19:41.840 could be a name
05:19:43.280 an age
05:19:44.560 maybe a breed of dog then what kinds of
05:19:46.958 actions can dogs perform they can eat
05:19:50.080 they can bark they can sleep maybe play
05:19:52.798 fetch so i think you get the idea an
05:19:55.280 object is a collection of attributes and
05:19:57.280 methods now to create an object we can
05:19:59.760 use a class
05:20:01.280 a class acts as a blueprint to create
05:20:03.760 objects let's create a class to create
05:20:06.480 human objects
05:20:08.560 i will type class
05:20:10.878 human
05:20:12.160 curly braces
05:20:13.680 i'm going to add a public axis modifier
05:20:17.200 we'll learn about axis modifiers pretty
05:20:19.120 soon i would like these attributes and
05:20:21.200 methods to be publicly accessible let's
05:20:24.240 start with the attributes of humans what
05:20:26.558 kinds of characteristics can humans have
05:20:29.040 how about a name
05:20:32.480 this will be of the string data type
05:20:34.958 i'll declare this attribute but not yet
05:20:36.958 assign it
05:20:38.958 maybe an occupation like a job
05:20:41.280 standard string
05:20:43.360 occupation
05:20:46.240 then maybe an age int age
05:20:49.120 our class human has these attributes
05:20:52.400 humans have a name an occupation and an
05:20:55.120 age that's good enough for this example
05:20:57.440 now let's cover methods a method is a
05:21:00.160 function that belongs to a class it's
05:21:02.798 something that an object can do an
05:21:04.878 action it can perform what sorts of
05:21:06.878 actions should our humans be able to
05:21:08.718 perform how about an eat method
05:21:12.480 void eat
05:21:15.440 i'll just display a message standard
05:21:17.440 output
05:21:19.120 let's say this
05:21:21.040 person is eating
05:21:24.400 humans can drink
05:21:26.320 void drink
05:21:29.120 standard output
05:21:32.240 this person is drinking
05:21:36.558 okay one last example
05:21:38.638 how about sleep human sleep right void
05:21:42.000 sleep
05:21:43.760 standard output
05:21:46.320 this person is sleeping
05:21:51.520 good enough oh then make sure we add a
05:21:53.680 semicolon to the end of the class
05:21:55.520 perfect okay so we now have a human
05:21:58.240 class
05:21:59.200 we can use this class as a blueprint to
05:22:02.080 create human objects each human object
05:22:04.878 will have a name an occupation and an
05:22:08.080 age they can also eat drink or sleep
05:22:12.320 they have their own functions which we
05:22:14.320 call methods so to create a human object
05:22:17.280 we will type the name of the class
05:22:20.480 human
05:22:22.240 then a unique identifier
05:22:25.040 how about human one that's creative
05:22:28.638 so human one is an object
05:22:31.120 human one has a name an occupation and
05:22:33.920 an age but we have not assigned these
05:22:36.080 attributes
05:22:37.840 let's say human one's name human one
05:22:41.600 member axis modifier which is a dot
05:22:44.958 name
05:22:45.840 equals rick
05:22:49.520 then human one's
05:22:52.240 occupation
05:22:54.798 equals
05:22:56.000 scientist
05:22:58.958 human one's
05:23:00.958 age equals 70.
05:23:04.160 let's verify that this worked by
05:23:05.920 printing out these attributes
05:23:08.240 standard output
05:23:10.718 human one dot name
05:23:14.320 i'll add a new line
05:23:18.558 then let's repeat this for occupation
05:23:20.638 and age
05:23:21.840 human one dot occupation human
05:23:25.520 dot age
05:23:30.000 human one's name is rick his occupation
05:23:33.040 is a scientist his age is 70 years old
05:23:37.280 so this part is kind of similar to
05:23:39.280 structs
05:23:40.558 however objects can also perform actions
05:23:43.360 they have methods
05:23:45.040 rick can eat drink and sleep
05:23:48.480 so to invoke those methods i would type
05:23:50.798 the name of my object human1 and let's
05:23:53.920 have human one eat
05:23:57.280 so humanone dot eat
05:23:59.680 add a set of parentheses to invoke this
05:24:01.600 method
05:24:04.080 okay this person is eating let's also
05:24:07.200 test drink and sleep
05:24:10.480 human one dot drink
05:24:15.280 human one dot sleep
05:24:21.600 okay this person is eating this person
05:24:23.600 is drinking this person is sleeping and
05:24:26.080 that is our human human one
05:24:28.160 for more practice let's create a second
05:24:29.840 human
05:24:31.280 human
05:24:32.480 human to
05:24:35.040 i'm going to copy these lines
05:24:38.480 let's change human one to human two
05:24:42.558 human two's name will be morty
05:24:45.680 occupation will be student
05:24:48.240 age what about 15
05:24:51.200 i'm going to display the attributes of
05:24:53.120 human 2 this time
05:24:55.200 then i'll have human 2 invoke its
05:24:57.040 methods
05:24:58.240 eat drink then sleep
05:25:01.360 ok human 2's name is morty their
05:25:04.160 occupation is a student
05:25:06.160 morty is 15 years old then morty can
05:25:08.558 perform these actions eat drink and
05:25:11.520 sleep
05:25:12.400 now you can assign some default
05:25:13.920 attributes
05:25:15.120 so let's say that all humans we create
05:25:17.440 will be named rick it's kind of like
05:25:19.200 we're cloning him
05:25:21.440 his occupation will be
05:25:24.080 scientist
05:25:26.320 age will be 70.
05:25:29.200 i'm not going to assign these attributes
05:25:30.958 what i did is that i added some default
05:25:33.520 attributes
05:25:35.200 so we have human one and human two
05:25:40.480 i'll display the attributes of human one
05:25:42.480 first then human two
05:25:44.400 human one dot name occupation age
05:25:49.120 then we have human two's attributes as
05:25:50.718 well
05:25:51.600 so remember i am not assigning these
05:25:53.440 attributes within the main function
05:25:56.798 we have two humans they're both named
05:25:58.638 rick they're both scientists and they're
05:26:00.638 both age 70. okay now here's one last
05:26:03.680 example to really get the hang of
05:26:05.360 objects let's create a different class
05:26:07.440 this time how about cars
05:26:09.840 class car
05:26:12.400 let's add a public axis modifier
05:26:15.200 then what kinds of attributes would cars
05:26:16.958 have
05:26:18.000 perhaps a make
05:26:20.320 standard string make
05:26:23.840 a model
05:26:25.280 standard string model
05:26:28.878 a year that would be an int
05:26:31.280 then maybe a color standard string color
05:26:36.240 you can add some default attributes but
05:26:38.400 i'll just leave those empty for now
05:26:40.718 you can add some methods
05:26:42.480 what kinds of actions can cars take
05:26:44.878 i guess you can accelerate
05:26:46.638 void accelerate
05:26:50.320 standard output uh what can we print
05:26:54.400 you step on the gas
05:27:00.400 then maybe break
05:27:02.400 void break
05:27:05.680 standard output
05:27:08.240 you step on the brakes
05:27:13.280 then be sure to add a semicolon to the
05:27:15.200 end of your class because i always
05:27:16.798 forget to do that
05:27:18.240 okay we now have a car class it acts as
05:27:21.120 a blueprint to create car objects
05:27:23.600 to create an object we would type the
05:27:25.120 name of the class
05:27:26.638 car in this example
05:27:28.320 then a unique identifier for the object
05:27:30.638 let's say car one
05:27:32.638 then we can assign some of the
05:27:33.920 attributes of this car object
05:27:36.000 car one dot make
05:27:39.680 maybe ford
05:27:42.558 car one dot model
05:27:47.120 equals mustang i like mustangs
05:27:50.480 car one dot year
05:27:52.878 equals 20 23
05:27:55.680 then a color car one dot color
05:27:59.040 maybe silver
05:28:01.440 okay then just to test these let's print
05:28:03.360 these attributes
05:28:06.160 standard output
05:28:08.400 car one
05:28:09.760 dot make
05:28:11.520 add a new line
05:28:13.600 let's copy this line paste it three
05:28:16.080 times
05:28:18.320 then we'll display the model
05:28:20.958 year
05:28:22.080 then color
05:28:24.400 okay our car object is a ford mustang
05:28:27.040 the year is 2023 the color is silver
05:28:30.718 not only does our car have attributes
05:28:32.400 but it has methods actions it can
05:28:34.160 perform as well
05:28:35.680 our car can accelerate and it can break
05:28:38.080 let's test that
05:28:41.200 car1 dot
05:28:43.520 accelerate
05:28:47.440 car one dot break
05:28:51.600 okay you step on the gas you step on the
05:28:54.080 brakes
05:28:55.440 then if i need a second car object i can
05:28:57.520 type car
05:28:58.878 car two
05:29:00.480 then i can assign the attributes and i
05:29:02.958 have access to its methods so yeah
05:29:05.040 that's an object everybody it's a
05:29:07.040 collection of attributes and methods
05:29:10.000 attributes are characteristics of an
05:29:12.400 object methods are functions that an
05:29:15.200 object can perform
05:29:16.878 so yeah those are objects everybody in
05:29:19.360 the next video we're going to cover
05:29:20.798 constructors
05:29:22.160 your assignment is to post a class in
05:29:24.718 the comment section down below so yeah
05:29:27.040 that's an introduction to object
05:29:28.638 oriented programming in c plus
05:29:34.080 hey everybody welcome back so in today's
05:29:36.240 video we're going to discuss
05:29:37.440 constructors a constructor is a special
05:29:40.638 method within a class that is
05:29:43.280 automatically called when an object is
05:29:45.600 instantiated it's useful for assigning
05:29:48.400 values to attributes as arguments before
05:29:51.920 when we were assigning attributes to an
05:29:53.680 object we would say for example
05:29:56.080 car one dot
05:29:58.878 make equals ford
05:30:01.440 well with the constructor we can do that
05:30:03.280 automatically here's an example this
05:30:05.840 time let's create a student class
05:30:08.798 class
05:30:09.920 student
05:30:13.040 i'll add a public access modifier what
05:30:16.240 attributes should students have
05:30:18.320 how about a name standard string name
05:30:22.558 int age
05:30:24.160 double gpa sounds good to me
05:30:27.120 then if i need to create a student
05:30:28.480 object i would type the name of the
05:30:30.480 class student
05:30:32.240 a unique identifier for this specific
05:30:34.638 object let's say student1
05:30:38.160 then to assign some of the attributes
05:30:40.160 right away i could use a constructor we
05:30:43.040 do have a constructor that is
05:30:44.558 automatically called behind the scenes
05:30:47.280 but we could explicitly set one up
05:30:50.000 the constructor has the same name as the
05:30:52.000 class
05:30:53.680 in this case student
05:30:55.280 add a set of parentheses add a set of
05:30:57.200 curly braces
05:30:58.638 think of this as a function
05:31:00.718 we can set up parameters
05:31:02.718 when we instantiate a student object we
05:31:05.280 will automatically call this function
05:31:07.520 the constructor then pass arguments
05:31:10.400 let's set up some parameters we have
05:31:12.240 standard string name
05:31:15.280 int age
05:31:16.798 double
05:31:17.760 gpa
05:31:20.080 then when i instantiate a student object
05:31:22.638 i will add a set of parentheses after
05:31:24.798 the object name then pass in my
05:31:26.958 arguments let me just zoom in real quick
05:31:30.000 okay in order to instantiate a student
05:31:32.320 object we need to pass in a name
05:31:34.798 an age and a gpa
05:31:37.200 so for the first student
05:31:39.120 student one's name will be spongebob
05:31:41.760 his age will be
05:31:43.520 i don't know how old spongebob is let's
05:31:45.280 say he's 25.
05:31:47.120 spongebob's gpa will be a solid
05:31:50.400 3.2
05:31:52.878 when we instantiate our student object
05:31:54.878 we will pass these values as arguments
05:31:57.920 to the constructor
05:31:59.520 now to assign these attributes
05:32:01.840 with these parameters
05:32:03.520 we first need to select these attributes
05:32:06.240 in this example i gave them the same
05:32:08.000 name
05:32:08.878 just to remove ambiguity if i'm
05:32:11.200 referring to these attributes i will
05:32:13.600 type this
05:32:15.440 then an arrow
05:32:16.958 name equals the name of the parameter
05:32:20.638 name
05:32:22.160 this name equals my name parameter
05:32:26.080 this
05:32:26.878 arrow age equals my age parameter
05:32:30.878 this
05:32:32.400 aero
05:32:33.520 gpa equals my gpa
05:32:38.638 so now let's test this i will display
05:32:40.638 student one's name age and gpa
05:32:45.440 standard
05:32:46.718 output
05:32:49.160 student1 dot
05:32:51.600 name
05:32:52.798 add a new line
05:32:56.958 then we have age
05:32:59.680 then gpa
05:33:03.680 okay we got spongebob he's 25 years old
05:33:06.480 his gpa is 3.2 so you can see that we
05:33:10.000 don't need to necessarily add these
05:33:12.080 values to these attributes manually
05:33:14.480 you can do that automatically with the
05:33:15.920 constructor so another way in which you
05:33:18.000 may see this constructor set up is with
05:33:20.558 the parameter names being different from
05:33:22.480 the attribute names perhaps instead of
05:33:24.878 name age and gpa let's say x
05:33:27.760 y
05:33:28.878 then z
05:33:30.160 if the attribute names are different
05:33:31.840 from the parameter names you don't need
05:33:34.160 the this keyword
05:33:37.200 you could say name equals x age equals y
05:33:40.718 gpa equals z
05:33:42.798 and this would work too
05:33:45.280 if you prefer this way of doing things
05:33:46.798 you can do that uh just my own personal
05:33:49.040 preference i like to use the this
05:33:50.638 keyword and then keep my parameters the
05:33:52.480 same but that's just me you do you let's
05:33:54.878 create a couple more students and it's
05:33:56.558 kind of nice because we can reuse this
05:33:58.320 constructor
05:33:59.760 let's create student two
05:34:01.360 student student two
05:34:04.160 student two will be patrick
05:34:07.280 i don't know how old patrick is let's
05:34:08.958 say patrick is 40.
05:34:12.000 uh patrick's gpa will be 1.5
05:34:16.240 okay to test this let's display student
05:34:18.798 twos and name age and gpa
05:34:23.120 okay we got patrick he's 40 years old
05:34:25.520 gpa is 1.5
05:34:27.680 one last student
05:34:29.360 student
05:34:30.400 student three
05:34:32.080 student three will be sandy
05:34:34.878 sandy is uh how about 21 years old
05:34:39.920 and sandy's gpa is a perfect 4.0
05:34:45.520 okay now we'll display student 3's name
05:34:48.558 age gpa
05:34:52.240 okay we got sandy her age is 21
05:34:55.760 gpa is for well 4.0 let's do one last
05:34:59.840 example just to reinforce our
05:35:01.360 understanding of constructors
05:35:03.280 let's create an entirely new class let's
05:35:05.520 go back to our car class
05:35:07.920 i'm going to get rid of all this
05:35:10.480 so we need a class
05:35:12.160 class car
05:35:14.638 set of curly braces add a semicolon to
05:35:16.878 the end i will add a public access
05:35:19.360 modifier
05:35:20.638 in the last topic we decided that cars
05:35:22.798 had four attributes
05:35:24.558 a make
05:35:25.680 standard string make
05:35:29.040 a model standard string model
05:35:33.440 and year
05:35:35.360 standard string color
05:35:39.680 now we'll create a constructor for our
05:35:41.360 car objects it has the same name as the
05:35:44.000 class name car
05:35:46.080 set of parentheses set of curly braces
05:35:48.798 we can set up some parameters
05:35:50.878 we have make model year and color i
05:35:53.680 think i'm just going to copy this to
05:35:54.878 save time
05:35:56.320 you can rename these if you want
05:35:59.600 but i like to keep them the same
05:36:06.400 then i will assign this
05:36:08.558 arrow
05:36:09.520 make equals make
05:36:12.160 this
05:36:13.040 arrow
05:36:14.080 model equals model
05:36:17.440 this
05:36:19.760 arrow
05:36:20.798 year
05:36:21.840 equals year
05:36:25.280 this
05:36:26.240 arrow color
05:36:28.320 equals color when we create a car object
05:36:31.600 we'll need to pass in these arguments
05:36:35.440 i will create car car 1 add a set of
05:36:38.320 parentheses pass in my arguments
05:36:40.718 a make
05:36:41.920 model year and color i'll create a chevy
05:36:47.040 corvette
05:36:48.958 the year will be 2022
05:36:52.160 the color is blue
05:36:56.080 i'm going to display the attributes
05:36:58.558 standard output car1 dot make
05:37:02.558 i'll add a new line
05:37:04.718 then i will display the model year then
05:37:07.280 color
05:37:11.520 model
05:37:13.280 year
05:37:14.638 color
05:37:18.400 car 1 is a chevy corvette the year is
05:37:20.638 2022 the color is blue
05:37:23.120 let's create a second car car car 2
05:37:27.840 car 2 will be a ford
05:37:31.440 mustang
05:37:34.718 the year will be 2023 the color will be
05:37:37.760 red
05:37:38.718 i will display cartoons attributes
05:37:43.680 we have a forward mustang the year is
05:37:45.440 2023 the color is red
05:37:47.760 so yeah that's a constructor everybody a
05:37:50.080 constructor is a special method that is
05:37:52.878 automatically called when an object is
05:37:54.958 instantiated it's useful for assigning
05:37:57.520 values to attributes as arguments when
05:38:00.558 you create an object from a class
05:38:02.878 add a set of parentheses
05:38:04.878 then add your arguments
05:38:06.558 within the constructor you can assign
05:38:08.558 those arguments to the attributes of
05:38:10.558 that class in the next topic we'll cover
05:38:13.200 overloaded constructors if you're
05:38:15.120 looking for some additional practice in
05:38:17.440 the comments section down below post a
05:38:20.000 class that contains a constructor and
05:38:22.480 well yeah those are constructors in c
05:38:25.040 plus
05:38:28.480 overloaded constructors are when we have
05:38:30.878 multiple constructors with the same name
05:38:33.600 but different parameters they allow for
05:38:36.000 a varying number of arguments when
05:38:37.760 instantiating an object here's an
05:38:39.680 example we'll create pizza objects from
05:38:41.760 a pizza class let's type class
05:38:44.638 pizza add a set of curly braces a
05:38:47.040 semicolon to the end
05:38:49.360 we'll make our members publicly
05:38:51.040 accessible
05:38:52.240 so pizzas they can have a variable
05:38:54.878 number of toppings right you can have no
05:38:56.718 toppings one topping two toppings three
05:38:59.200 toppings suppose we have just one
05:39:01.520 topping to begin with topping one and
05:39:04.320 that will be of the string data type
05:39:06.558 standard string topping one
05:39:10.320 then i will create a pizza constructor
05:39:12.240 it has the same name as the class name
05:39:14.240 pizza parentheses curly braces
05:39:17.360 we'll set up some parameters
05:39:20.160 standard string topping one in order to
05:39:22.400 construct a pizza we have to pass in one
05:39:24.558 topping
05:39:25.760 so let's do that we have pizza
05:39:28.480 pizza one
05:39:29.840 and i will pass in one argument for a
05:39:31.920 topping
05:39:33.360 i feel like pepperoni
05:39:36.000 then we'll just need to assign this
05:39:37.920 argument to this attribute
05:39:40.558 this
05:39:41.440 arrow
05:39:42.480 topping one
05:39:44.160 equals topping one the name of this
05:39:46.638 parameter then to test this let's
05:39:48.558 display topping one
05:39:50.160 standard output
05:39:52.320 pizza
05:39:53.520 one
05:39:54.400 dot topping one
05:40:03.280 okay we have pizza one that contains
05:40:05.440 pepperoni
05:40:06.718 now what if you would like a pizza that
05:40:08.320 has two toppings
05:40:10.080 suppose we have pizza two pizza
05:40:13.200 pizza two
05:40:14.718 this time i'm going to attempt to pass
05:40:16.558 in two arguments
05:40:18.320 how about mushrooms
05:40:22.480 and peppers
05:40:26.000 well when i run this program
05:40:28.798 we're going to have an error
05:40:30.798 error no matching function for call to
05:40:33.360 pizza with two arguments
05:40:36.320 we can create an additional constructor
05:40:38.958 that accepts different arguments
05:40:41.760 let's copy what we have and paste it
05:40:45.120 this constructor will take two string
05:40:47.360 arguments
05:40:48.638 topping one and topping two
05:40:52.638 so we have two toppings this time and i
05:40:54.558 should probably create another attribute
05:40:56.080 for a second topping
05:40:57.680 standard string
05:40:59.600 topping two
05:41:05.120 this topping two equals topping two
05:41:09.440 so now with pizza two let's display
05:41:11.600 topping one
05:41:13.040 as well as topping two
05:41:18.240 now pizza two
05:41:20.320 contains mushrooms and peppers
05:41:23.280 what if you would like a pizza with no
05:41:24.958 toppings like a plain cheese pizza well
05:41:27.600 we could set that up
05:41:29.440 pizza
05:41:30.558 pizza three
05:41:33.200 i'm going to attempt to add a set of
05:41:34.878 parentheses after pizza 3 but pass in no
05:41:37.200 arguments
05:41:40.878 but we have a warning our compiler is
05:41:42.798 saying we should get rid of the
05:41:43.760 parentheses
05:41:48.320 if we're passing in no arguments we
05:41:49.920 don't need that set of parentheses but
05:41:51.920 we still have an error here
05:41:56.160 no matching function call for pizza with
05:41:58.638 no arguments
05:42:00.480 if we're creating an object and passing
05:42:02.558 in no arguments we'll need a matching
05:42:04.160 constructor
05:42:05.520 so at the top i'll create a pizza
05:42:07.600 constructor with no arguments
05:42:10.638 and that should make that error go away
05:42:14.320 so this should run and compile just fine
05:42:16.000 then
05:42:17.440 yep no errors
05:42:19.600 so yeah those are overloaded
05:42:21.040 constructors
05:42:22.400 you can have multiple constructors with
05:42:24.878 the same name as long as the parameters
05:42:27.200 are different we have three constructors
05:42:29.520 with the same name we can create a pizza
05:42:31.760 with no toppings one topping or two
05:42:34.400 toppings overloaded constructors allow
05:42:37.120 for multiple objects with a varying
05:42:39.440 number of attributes if you're looking
05:42:41.600 for some additional exercises post a
05:42:43.600 class with overloaded constructors in
05:42:45.520 the comments section down below and well
05:42:47.680 yeah those are overloaded constructors
05:42:49.840 and c plus
05:42:53.520 hey everyone let's talk about getters
05:42:55.440 and setters getters and setters are used
05:42:58.000 within this concept of abstraction where
05:43:00.638 we hide any unnecessary data from
05:43:03.280 outside of a class getters are functions
05:43:06.240 that make a private attribute readable
05:43:09.120 setters are functions that make a
05:43:11.200 private attribute writable here's an
05:43:14.080 example
05:43:15.520 i'm going to create a stove object class
05:43:19.360 stove
05:43:21.600 then i will instantiate a stove object
05:43:24.320 stove
05:43:25.440 stove
05:43:26.638 in previous topics when we created
05:43:28.718 attributes we would use the public
05:43:30.558 access specifier
05:43:32.240 then write any attributes
05:43:34.400 in this example let's say int
05:43:37.280 temperature
05:43:38.958 i'll go ahead and set this to zero right
05:43:40.558 away
05:43:41.360 since this attribute temperature is
05:43:43.440 public it's accessible from outside of
05:43:46.080 the class that means that people can
05:43:48.080 change it for example
05:43:50.000 i will take my stove object
05:43:52.240 set the temperature attribute to a
05:43:54.798 really high setting that doesn't exist
05:43:56.718 like
05:43:57.520 a million
05:44:00.320 this is fine
05:44:02.320 then i can display the temperature
05:44:04.000 standard output
05:44:06.558 the
05:44:07.558 temperature setting
05:44:11.200 is
05:44:13.600 stove dot temperature
05:44:20.160 the temperature setting is one million
05:44:23.600 i don't want people to mess with my
05:44:25.200 temperature attribute
05:44:26.638 what i could do instead is set these
05:44:29.040 attributes to be private
05:44:33.280 we're following that rule of abstraction
05:44:35.680 we're hiding any unnecessary data from a
05:44:38.160 user that they don't need we no longer
05:44:40.638 have access to this temperature
05:44:42.000 attribute from outside of the class you
05:44:44.160 can see we have some red underlines
05:44:48.320 temperature is private within this
05:44:50.160 context this is a hidden attribute from
05:44:52.798 the outside world if i need access to
05:44:55.360 the value found within this temperature
05:44:57.760 i can write a getter it's a function
05:45:00.160 that will make an attribute readable
05:45:02.558 i'll add a public access specifier
05:45:05.840 then write a getter we're returning an
05:45:08.080 integer
05:45:09.760 i'll write get then the attribute name
05:45:13.280 temperature
05:45:15.120 all i'm going to do is return
05:45:18.000 our temperature
05:45:20.480 i can no longer update or change the
05:45:22.320 temperature it's readable but not
05:45:24.480 writable so i'm going to turn this line
05:45:26.480 into a comment
05:45:28.480 in place of accessing this attribute
05:45:30.480 directly i'm going to invoke the get
05:45:33.040 temperature method
05:45:35.840 dot get temperature add a set of
05:45:37.760 parentheses
05:45:39.360 now the current temperature setting is
05:45:41.120 set to zero adding a getter will make an
05:45:43.840 attribute readable if you need a private
05:45:46.638 attribute to also be writable you can
05:45:48.958 add a setter
05:45:50.718 void
05:45:51.920 set
05:45:52.878 temperature
05:45:58.958 this
05:46:00.320 arrow
05:46:01.440 temperature
05:46:02.638 equals our temperature that we pass in
05:46:05.920 then we just need a parameter
05:46:08.240 int temperature
05:46:10.160 in order for a user to change the
05:46:12.000 temperature they would need to invoke
05:46:13.760 the set temperature method
05:46:16.798 then they can pass in a new temperature
05:46:18.878 using this setter they can still set the
05:46:21.120 temperature to whatever they want like a
05:46:23.520 million in the previous example
05:46:28.558 the temperature setting is set to 1
05:46:30.240 million within a setter we can add some
05:46:32.798 additional logic or checks
05:46:35.040 before we do set the temperature let's
05:46:36.718 check to see what the temperature is
05:46:39.520 if
05:46:40.400 the temperature the user passes in
05:46:43.280 is less than zero
05:46:46.320 we will set this temperature
05:46:49.120 to be
05:46:50.160 zero
05:46:52.558 else if
05:46:55.440 the temperature
05:46:57.280 is greater than or equal to 10
05:47:00.320 suppose this is a knob with different
05:47:02.240 settings the numbers 0 through 10 this
05:47:04.798 temperature
05:47:06.160 equals 10.
05:47:08.160 in case they type in a million it'll
05:47:10.320 just max out at 10.
05:47:14.480 else
05:47:16.080 this temperature
05:47:17.440 equals temperature
05:47:20.160 i could attempt to set the temperature
05:47:21.840 to a million but it would just max out
05:47:23.920 at ten
05:47:24.958 or we could try a negative number like
05:47:26.878 negative three
05:47:29.760 well now the temperature setting is set
05:47:31.520 to zero
05:47:32.638 as if the stove was off or anything
05:47:34.878 between maybe five something right in
05:47:36.718 the middle
05:47:38.638 the temperature setting is five
05:47:40.958 so yeah that's kind of the purpose of
05:47:42.558 getters and setters they make a private
05:47:45.040 attribute either readable or writable or
05:47:48.878 both if you use both one additional step
05:47:51.440 you can take too is that if you have a
05:47:53.040 constructor you can invoke the setters
05:47:55.600 within a constructor within my stove
05:47:58.000 class i have a constructor
05:48:00.718 if we were to receive a temperature
05:48:04.480 we could set the temperature right away
05:48:06.638 so we already have this line of code
05:48:08.400 within our setter so we don't
05:48:10.400 necessarily need this line again
05:48:12.638 we would instead invoke the setter
05:48:17.520 set temperature
05:48:19.040 pass in our temperature
05:48:23.200 then if i was to instantiate a stove
05:48:25.040 object i would have to pass in a
05:48:26.320 temperature i'll set it to be zero
05:48:30.320 and this temperature setting is set to
05:48:32.480 zero
05:48:33.920 so yeah those are getters and setters
05:48:35.680 everybody a getter makes a private
05:48:38.240 attribute readable a setter makes a
05:48:41.200 private attribute writable within the
05:48:43.920 getters and setters you can perform
05:48:45.840 additional checks or logic which is
05:48:48.240 pretty nice
05:48:49.280 if you're looking for some additional
05:48:50.638 practice post a class that has a getter
05:48:53.360 and setter in the comment section down
05:48:55.040 below and well yeah those are getters
05:48:57.360 and setters and c plus
05:49:01.840 hey guys let's talk about inheritance
05:49:03.840 inheritance is when a class can receive
05:49:06.638 attributes and methods from another
05:49:08.798 class
05:49:09.680 the receiving class is known as a child
05:49:12.160 class
05:49:13.200 the class that's being inherited from is
05:49:15.280 known as the parent class it's kind of
05:49:17.360 like how children will inherit their
05:49:19.200 parents genes and some of their physical
05:49:21.120 traits it's kind of the same concept a
05:49:23.120 benefit of inheritance is that it helps
05:49:25.120 to reuse similar code found within
05:49:27.680 multiple classes here's an example we
05:49:30.320 will create an animal class the animal
05:49:32.718 class will be the parent class
05:49:35.440 class animal
05:49:40.000 i'll make these members publicly
05:49:41.840 accessible
05:49:43.120 all animals will have a boolean
05:49:45.440 attribute that we will name alive
05:49:48.718 if you're an animal you're alive then
05:49:51.200 let's add a method maybe an eat method
05:49:53.760 all animals should be able to eat
05:49:56.878 void
05:49:58.958 eat
05:50:00.798 well just print a generic message
05:50:02.798 standard output
05:50:04.958 this animal is eating
05:50:10.558 i'm going to create two classes a dog
05:50:13.040 class and a cat class they will inherit
05:50:16.080 from the animal class
05:50:18.558 let's begin with dog
05:50:20.400 class
05:50:21.360 dog to inherit from another class you
05:50:24.400 would add a colon
05:50:26.480 then public
05:50:27.840 the name of the parent class
05:50:29.680 dog will inherit from the animal class
05:50:33.920 that is out of curly braces semicolon at
05:50:36.638 the end
05:50:37.520 and we now have a dog class
05:50:39.920 now check this out if i create a dog
05:50:42.080 object it will have a boolean variable
05:50:44.718 named alive as well as an eat method
05:50:47.360 so let's create a dog object dog dog
05:50:52.958 so i'm going to display that boolean
05:50:54.638 variable
05:50:57.040 dot alive
05:51:02.000 if i display this attribute
05:51:04.638 this will give me one which means true
05:51:08.240 this dog object also has an eat method
05:51:13.798 dog.e add a set of parentheses to invoke
05:51:16.638 it
05:51:18.958 this animal is eating
05:51:21.120 so even though there's nothing within
05:51:22.558 this dog class it's inheriting
05:51:24.400 everything from within the animal class
05:51:26.958 and we could add some additional
05:51:28.558 attributes and methods as well
05:51:30.558 maybe just a method this time i would
05:51:32.638 like to give my dog the ability to speak
05:51:35.200 so let's make this public
05:51:38.840 void maybe bark
05:51:42.160 standard output
05:51:44.480 the dog goes woof
05:51:50.718 my dog is alive and it can eat my dog
05:51:53.360 can also bark as well it has its own
05:51:55.200 attributes and methods too
05:51:57.280 i would like my dog to bark
05:52:03.120 okay
05:52:04.000 my dog is alive that's set to one the
05:52:06.080 animal is eating the dog goes woof
05:52:09.120 so now let's create a cat class
05:52:12.638 class
05:52:13.840 cat
05:52:14.878 the cat class will inherit from the
05:52:16.718 animal class
05:52:20.000 i'll make its members publicly
05:52:21.680 accessible
05:52:23.120 i will give cats a meow function void
05:52:27.040 meow
05:52:29.120 standard output
05:52:31.600 the cat goes meow
05:52:36.798 there okay now we can create a cat
05:52:39.120 object
05:52:40.080 cat
05:52:41.040 cat
05:52:42.240 let's print the alive boolean variable
05:52:44.558 of my cat
05:52:46.878 cat dot eat now i'm going to try and use
05:52:49.200 the bark method of a cat
05:52:52.000 which we don't have
05:52:53.520 let's attempt to use that
05:52:56.080 so class cat has no member named bark
05:52:59.120 that's because that method is found
05:53:00.878 within the dog class and not the cat
05:53:03.360 class cats have a meow method i'm
05:53:06.000 instead going to use the meow method
05:53:10.400 are cat's alive the animal is eating the
05:53:13.040 cat goes meow so that's kind of how
05:53:15.120 inheritance works a class can inherit
05:53:17.920 attributes and methods from another
05:53:19.680 class it helps with code reusability you
05:53:22.718 know technically you could add these
05:53:24.320 attributes and methods to each of these
05:53:26.000 classes for example
05:53:28.400 i'll just add the boolean variable alive
05:53:30.718 to each of these classes
05:53:33.680 as well as the eat method
05:53:38.000 you know this would work too but we're
05:53:39.840 repeating ourselves and with programming
05:53:42.320 we try not to repeat ourselves if we
05:53:43.920 don't have
05:53:44.840 to especially because if we have to make
05:53:47.120 a change to the eat method let's change
05:53:49.520 eat to
05:53:50.718 nom nom nom
05:53:52.798 well i would have to go to each class
05:53:54.558 and make that change manually and that
05:53:56.718 can be inconvenient if i have hundreds
05:53:58.558 of different classes it would be a lot
05:54:00.480 easier if i just had to make that change
05:54:02.160 in one place
05:54:03.600 so i'm going to revert all those changes
05:54:07.760 if i need to make a change to one of
05:54:09.600 these methods i'm going to change it to
05:54:11.920 display
05:54:13.040 nom nom nom
05:54:16.480 well then i just have to make that
05:54:17.680 change in one place instead of for every
05:54:20.160 individual class
05:54:21.920 let's try another example we'll create a
05:54:24.000 class named shape
05:54:26.558 this will be the parent class
05:54:29.760 we'll make the members publicly
05:54:31.520 accessible
05:54:32.878 any class that inherits from the shape
05:54:34.718 class will have a double attribute that
05:54:37.600 we will name
05:54:38.878 area for surface area
05:54:41.680 double
05:54:42.558 volume
05:54:44.000 in this example we won't have any
05:54:45.440 methods this time just some attributes
05:54:47.840 i'm going to create class
05:54:50.080 cube
05:54:51.120 cube is the child class it will inherit
05:54:53.520 from the parent class shape so colon
05:54:57.680 public the name of the parent
05:55:00.558 shape
05:55:02.000 even though there's nothing within my
05:55:03.360 cube class my cube class has an area and
05:55:06.718 volume attribute
05:55:09.440 then let's make a sphere class class
05:55:13.120 sphere
05:55:15.440 there we go
05:55:17.120 i'm going to add a public axis modifier
05:55:19.920 all cubes will have a double
05:55:22.638 side property then with spheres
05:55:25.840 they will have
05:55:27.440 double
05:55:28.320 radius
05:55:29.680 then i'm going to add a constructor for
05:55:31.120 both cubes and spheres
05:55:33.360 let's begin with cube cube
05:55:37.120 then sphere
05:55:40.480 in order to instantiate a cube object i
05:55:42.638 need to pass in a side as an argument
05:55:44.558 when i construct an object
05:55:47.520 double side
05:55:50.160 then for the sphere we need a radius
05:55:53.360 double radius
05:55:55.440 i think what we'll do is that when we
05:55:56.878 construct a cube object and a sphere
05:55:59.040 object we'll calculate the area and the
05:56:01.760 volume based on either the side that we
05:56:04.080 pass in for a cube or the radius for a
05:56:07.040 sphere let's begin with the cube
05:56:09.600 first let's assign the length of a side
05:56:11.840 remember with a cube the length the
05:56:13.600 width and the height are all the same
05:56:16.000 this arrow side equals side
05:56:18.958 to calculate the area we can use this
05:56:20.718 formula
05:56:22.000 so this area equals
05:56:25.600 side
05:56:26.798 times side
05:56:28.400 times six because there are six sides to
05:56:30.958 a cube
05:56:31.920 then if you need the volume you could
05:56:33.200 say this
05:56:34.400 arrow
05:56:35.360 volume equals side to the power of three
05:56:38.958 we could just say side times side times
05:56:41.840 side just to keep it simple
05:56:44.080 now with the sphere it's a little more
05:56:45.760 complex
05:56:47.200 first let's assign the radius this arrow
05:56:50.160 radius equals radius
05:56:54.320 let's calculate the area of a sphere
05:56:57.280 this arrow
05:56:58.958 area
05:57:00.000 equals
05:57:01.120 to calculate the area of a sphere that
05:57:03.760 would be 4
05:57:05.600 times pi let's just say 3.14159
05:57:10.160 times radius squared
05:57:13.440 so radius times radius
05:57:17.920 then let's calculate the volume this
05:57:20.320 arrow
05:57:21.360 volume
05:57:22.558 equals
05:57:23.760 to calculate the volume of a sphere the
05:57:25.920 formula is
05:57:27.440 4 divided by 3
05:57:29.360 times pi
05:57:30.638 times radius cubed so that would be 4
05:57:33.760 divided by 3.0 make sure to divide by
05:57:37.040 3.0 and not 3 because in this case we
05:57:39.920 would be using integer division we would
05:57:42.240 like to keep that decimal so 3.0
05:57:45.760 times pi that's 3.14159
05:57:49.680 times radius cubed to keep it simple we
05:57:51.920 can say radius
05:57:53.520 times radius
05:57:55.120 times radius
05:57:58.080 and there we go
05:58:00.240 okay so let's create a cube object to
05:58:02.320 begin with
05:58:03.840 cube
05:58:05.520 i'll name this object just cube then in
05:58:08.000 order to construct a cube object we need
05:58:09.840 to pass in the length of a side let's
05:58:12.400 say 10
05:58:14.798 so my cube class inherits the area and
05:58:17.680 volume attribute from the shape class
05:58:19.840 within the constructor of the cube class
05:58:21.600 we will calculate what the area and the
05:58:23.360 volume is going to be
05:58:27.200 and i will display that standard output
05:58:32.160 area
05:58:35.680 cube dot area
05:58:38.240 then i'll add centimeters
05:58:42.320 then let's do the same thing with volume
05:58:45.840 volume
05:58:47.680 cube dot volume
05:58:50.240 if the length of a side is
05:58:52.840 10 the area is going to be 600
05:58:55.760 centimeters squared
05:58:57.360 the volume is 1000 centimeters cubed
05:59:00.798 now let's try this with our sphere
05:59:02.958 sphere
05:59:04.400 i'll name this object sphere then we
05:59:06.718 will pass in the radius
05:59:09.040 let's say 5.
05:59:10.878 i would like to display the spheres area
05:59:14.000 and the sphere's volume
05:59:16.638 the area would be 314 centimeters
05:59:19.440 squared
05:59:20.798 the volume is 523 centimeters cubed
05:59:25.920 so yeah that's inheritance everybody
05:59:28.320 a class can inherit attributes and
05:59:30.558 methods from another class
05:59:32.638 if you have multiple classes and they
05:59:35.280 share similar attributes or methods
05:59:37.760 you can place them within a parent class
05:59:40.320 and all of those individual classes can
05:59:42.638 inherit from that one common class it
05:59:44.798 helps with code reusability and you
05:59:46.480 don't have to repeat yourself if you're
05:59:48.240 looking for some additional practice
05:59:50.240 post a parent class and a child class in
05:59:52.878 the comments section down below and well
05:59:55.200 yeah that's an introduction to
05:59:56.638 inheritance in c plus
